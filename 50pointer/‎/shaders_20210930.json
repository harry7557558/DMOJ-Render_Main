{
 "userName": "harry7557558",
 "date": "2021-09-30T17:01:06.572Z",
 "numShaders": 73,
 "shaders": [
  {
   "ver": "0.1",
   "info": {
    "id": "ttSSDc",
    "date": "1580178987",
    "viewed": 23,
    "name": "Self-Adaptive Super Sampling",
    "description": "Much faster than brute force super sampling. \nNote that the sawteeth at the side of the cup are not recognized. \nI think this can be improved by using a depth buffer. ",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "supersampling",
     "cup"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsfGRn",
       "filepath": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#if 0\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 c0 = texelFetch(iChannel0,ivec2(fragCoord),0).xyz;\n    float d = 0.0;\n    for (int i=-1;i<=1;i++) {\n        for (int j=-1;j<=1;j++) {\n            if (i!=0&&j!=0) {\n        \t\tvec3 c = texelFetch(iChannel0,ivec2(fragCoord)+ivec2(i,j),0).xyz;\n                c -= c0;\n                d = max(d,length(c));\n            }\n        }\n    }\n    float dif = d;\n    \n    int AA = 1; float a;\n    //fragColor = vec4(dif,dif,dif,0.); return;\n    if (dif<0.2){\n        fragColor=vec4(c0,1.0);\n        return;\n    }\n    else if (dif<0.8) AA=2, a=0.3;\n    else AA=3, a=0.8;\n    \n    vec3 col;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++)\n    \tcol += calcCol(fragCoord+(vec2(i,j)+vec2(0.5))/float(AA),\n                       iResolution.xy, iMouse, iTime, iChannel1);\n    col/=float(AA*AA);\n    if (fract(iTime)>0.5) col=mix(col,vec3(1,0,0),a);\n    fragColor = vec4(col,1.0);\n}\n\n#else\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#define C(i,j) cols[3*(i)+(j)]\n    vec3 cols[9];\n    for (int i=-1;i<=1;i++) for (int j=-1;j<=1;j++){\n        C(i+1,j+1) = texelFetch(iChannel0,ivec2(fragCoord)+ivec2(i,j),0).xyz;\n    }\n    vec3 dx,dy;\n    for (int i=0;i<3;i++){\n        float m=i==1?2.0:1.0;\n        dx+=m*max(abs(C(2,i)-C(1,i)),abs(C(1,i)-C(0,i)));\n        dy+=m*max(abs(C(i,2)-C(i,1)),abs(C(i,1)-C(i,0)));\n    }\n    vec3 g = sqrt(dx*dx+dy*dy);\n    float dif = dot(g,vec3(0.3,0.59,0.11));\n    \n    int AA = 1; float a;\n    if (dif<0.5){\n        fragColor=vec4(C(1,1),1.0);\n        return;\n    }\n    else if (dif<2.0) AA=2, a=0.3;\n    else AA=3, a=0.8;\n    \n    vec3 col;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++)\n    \tcol += calcCol(fragCoord+(vec2(i,j)+vec2(0.5))/float(AA),\n                       iResolution.xy, iMouse, iTime, iChannel1);\n    col/=float(AA*AA);\n    if (fract(iTime)>0.5) col=mix(col,vec3(1,0,0),a);\n    fragColor = vec4(col,1.0);\n}\n#endif",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define PI 3.14159265358979\n\nfloat opExtrusion(float sd, float h, vec3 P) {\n    if (P.z >= 0. && P.z <= h) return sd > 0. ? sd : max(sd, max(-P.z, P.z - h));\n\tif (P.z > h) return sd > 0. ? sqrt(sd*sd + (P.z - h)*(P.z - h)) : P.z - h;\n\tif (P.z < 0.) return sd > 0. ? sqrt(sd*sd + P.z*P.z) : -P.z;\n}\n\nfloat sdCylinder(float r, float min_z, float max_z, vec3 p) {\n    p.z-=min_z, max_z-=min_z, min_z=0.0;\n    float d=length(p.xy)-r;\n    if (p.z>0.0 && p.z<max_z) return max(d, max(-p.z, p.z-max_z));\n    if (p.z>max_z) p.z-=max_z;\n    else p.z=-p.z;\n    return d<0.0?p.z:sqrt(d*d+p.z*p.z);\n}\n\nfloat sdPolygon(vec2 v[4], vec2 p) {\n\tfloat sd = dot(p - v[0], p - v[0]);\n\tfloat sgn = 1.0;\n\tvec2 e, w, b; float c;\n\tfor (int i = 0; i < 4; i++) {\n\t\te = v[(i+1)%4] - v[i];\n\t\tw = p - v[i];\n\t\tb = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n\t\tsd = min(sd, dot(b,b));\n\t\tif (e.y < 0.0) e.y = -e.y, w.y = -w.y;\n\t\tif (w.y > 0.0 && w.y < e.y && (w.y*e.x / e.y > w.x)) sgn =-sgn;\n\t}\n\treturn sgn*sqrt(sd);\n}\n\nfloat s_sub(float a, float b, float k) {\n\tfloat h = 0.5 - 0.5*(b + a) / k;\n\tif (h < 0.0) return a; if (h > 1.0) return -b;\n\treturn mix(a,-b,h) + k*h*(1.0 - h);\n}\n\nfloat s_min(float a, float b, float k) {\n\tfloat h = 0.5 + 0.5*(b - a) / k;\n\tif (h < 0.0) return b; if (h > 1.0) return a;\n\treturn mix(b,a,h) - k*h*(1.0 - h);\n}\n\nfloat sdCup(vec3 p) {\n    p.z-=0.23;\n    float cyl = sdCylinder(0.75, 0.0, 2.0, p);\n    float sd = abs(cyl - 0.15) - 0.08;\n    sd = s_sub(sd, 1.8 - p.z, 0.08);\n    vec3 q=p.xzy-vec3(1.03,0.38,-0.15);\n    float handle = sdPolygon(vec2[4](vec2(0,0.9),vec2(0.4,0.9),vec2(0.3,0.35),vec2(0,0.1)),q.xy);\n    handle=opExtrusion(abs(handle-0.2)-0.05, 0.3, q)-0.1;\n    handle=max(handle,0.12-cyl);\n    sd = s_min(sd, handle, 0.05);\n    return sd;\n}\n\nfloat map(vec3 p) {\n    p.z+=1.0;\n    return min(p.z, sdCup(p));\n}\n\n#define ZERO min(int(time),0)\n#define eps 1e-3\n#define MAX_STEP 256\n#define MAX_DIST 20.0\n\n\nvec3 light = normalize(vec3(-0.3, 0.1, 1));\n\nvec3 calcCol(in vec2 coord, in vec2 res, in vec4 iMouse, in float time, sampler2D g) {\n    vec3 Pos;\n    if (iMouse.z>0.){\n        float u = 2.0*PI*iMouse.x/res.x;\n        float v = 0.5*PI*iMouse.y/res.y;\n        Pos = 5.0*vec3(sin(u)*cos(v),cos(u)*cos(v),sin(v));\n    }\n    else{\n    \tfloat H = cos(0.4*time); H=3.5*H*H+0.5;\n    \tfloat R = sqrt(20.0-H*H)+0.2*(cos(time)+1.0);\n    \tPos=vec3(R*cos(time), R*sin(time), H);\n    }\n    \n    float rz=atan(-Pos.x,Pos.y), rx=atan(length(Pos.xy),-Pos.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 d = M*normalize(vec3(0.5*res.x-coord.x,-0.5*res.y+coord.y,0.7*length(res)));\n    \n    \n\t// cast ray\n\tfloat t = 100.0 * eps, dt;\n\tvec3 p = Pos + t * d;\n\tif (map(p) < 0.0) return vec3(0.0, 0.0, 0.0);\n\tfor (int i = ZERO; i < MAX_STEP; i++) {\n\t\tdt = map(Pos + t * d);\n\t\tt += dt;\n\t\tif (dt < -eps) return vec3(1.0, 0.0, 0.0);\n\t\tif (dt < eps) break;\n\t\tif (dt > MAX_DIST || i+1 == MAX_STEP) {\n            return vec3(0.0);\n\t\t\t//t = max(dot(d, light), 0.0);\n\t\t\t//return vec3(t, t, t);\n\t\t}\n\t}\n\tp = Pos + t * d;\n    vec3 col = vec3(0.87,0.8,0.7);\n    if (p.z+1.0<eps) col = texture(g,0.1*p.xy).rgb;\n    col *= exp(-0.01*dot(p.xy,p.xy));\n\n\t// calculate normal\n\tfloat k_111 = map(vec3(p.x + eps, p.y + eps, p.z + eps));\n\tfloat k_100 = map(vec3(p.x + eps, p.y - eps, p.z - eps));\n\tfloat k_010 = map(vec3(p.x - eps, p.y + eps, p.z - eps));\n\tfloat k_001 = map(vec3(p.x - eps, p.y - eps, p.z + eps));\n\tvec3 n = normalize(vec3(k_111 + k_100 - k_010 - k_001, k_111 - k_100 + k_010 - k_001, k_111 - k_100 - k_010 + k_001));\n\tif (dot(n, d) > 0.0) n = -n;\n\n\t// calculate shadow\n\td -= 2.0 * dot(d, n)*n;\n\tfloat r = 1.0;\n\tt = 0.01;\n\tfor (int i = ZERO; i < MAX_STEP; i++) {\n\t\tdt = map(p + t * light);\n\t\tr = min(r, 15.0 * dt / t);\n\t\tif (r < 0.01 || t > 2.0) break;\n\t\tt += 0.1*clamp(dt, 0.5, 2.0);\n\t}\n\tr = clamp(r, 0.0, 1.0);\n\n\t// final result\n\tfloat dif = clamp(dot(n, light), 0.0, 1.0);\n\treturn (dif*r + 0.2*pow(max(dot(d, light), 0.0), 4.0))*col + (0.5 - 0.5*dif)*vec3(0.1, 0.15, 0.25);\n    \n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "XsfGRn",
       "filepath": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col=calcCol(fragCoord+vec2(0.5),iResolution.xy,iMouse,iTime,iChannel0);\n    fragColor = vec4(clamp(col,0.0,1.0),1.0);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WtjSD3",
    "date": "1567308037",
    "viewed": 159,
    "name": "Implicit Heart",
    "description": "defined by implicit equation (x² + 9/4 y² + z²)³ - x² z³ - 9/80 y² z³ = 0",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "heart",
     "implicit",
     "love"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265358979\n#define AA 2\n\n#define EPSILON 1e-5\n\n#define MAX_STEP 1024\n#define MAX_DIST 20.0\n\nvec3 light = normalize(vec3(-0.3, 0.1, 1));\n\n// put any implicit equations you want to visualize there \\\n     (you may need to reduce the step length)\nfloat func(in vec3 p) {\n    float e = p.x*p.x + 2.25*p.y*p.y + p.z*p.z - 1.0;\n\treturn e*e*e - (p.x*p.x + 0.1125*p.y*p.y)*p.z*p.z*p.z;\n}\n\nvec3 calcGrad(vec3 p) {\n\tfloat k_111 = func(vec3(p.x + EPSILON, p.y + EPSILON, p.z + EPSILON));\n\tfloat k_100 = func(vec3(p.x + EPSILON, p.y - EPSILON, p.z - EPSILON));\n\tfloat k_010 = func(vec3(p.x - EPSILON, p.y + EPSILON, p.z - EPSILON));\n\tfloat k_001 = func(vec3(p.x - EPSILON, p.y - EPSILON, p.z + EPSILON));\n\tvec3 n = vec3(k_111 + k_100 - k_010 - k_001, k_111 - k_100 + k_010 - k_001, k_111 - k_100 - k_010 + k_001);\n\treturn n / (4.0 * EPSILON);\n}\n\nvec3 castRay(vec3 p, vec3 d) {\n\tfloat t = 100.0 * EPSILON, dt;\n\tvec3 P = p + t * d;\n\tif (func(p) < 0.0) return vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < MAX_STEP; i++) {\n\t\tdt = func(p + t * d);\n        dt /= length(calcGrad(p + t * d));\n\t\tt += 0.5*dt;\n\t\tif (dt < EPSILON) break;\n\t\tif (dt > MAX_DIST) {\n            P = normalize(p + t * d);\n            vec3 col = sin(30.0*P.x)+sin(30.0*P.y)+sin(30.0*P.z)>0.0 ?\n                vec3(0.2,0.6,1.0) : vec3(0.6,0.4,1.0);\n\t\t\tt = max(dot(d, light), 0.0);\n\t\t\treturn (0.3+0.7*t)*col;\n\t\t}\n\t}\n\tP = p + t * d;\n    vec3 n = normalize(calcGrad(P));\n    if (dot(n, d) > 0.0) n = -n;\n    \n    float dif = clamp(dot(n, light), 0.0, 1.0);\n    return (0.7*dif + 0.2*pow(max(dot(d, light), 0.0), 4.0) + 0.3)*vec3(1.0, 0.1, 0.6);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = 2.0*cos(0.4*iTime)+1.0;\n    float r = sqrt(20.0-h*h)+0.2*(cos(iTime)+1.0);\n    vec3 pos = vec3(r*cos(iTime), r*sin(iTime), h);\n    float Unit = 0.6*length(iResolution);\n    \n    float rz=atan(-pos.x,pos.y), rx=atan(length(pos.xy),-pos.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)/float(AA)),Unit);\n        col += castRay(pos,normalize(d));\n    }\n    col/=float(AA*AA);\n    \n    col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3l2XWc",
    "date": "1570296570",
    "viewed": 8,
    "name": "Untitled 0x00000001",
    "description": "temp",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define AA 3\n\n#define EPSILON 1e-3\n\n#define MAX_STEP 1024\n#define MAX_DIST 200.0\n\n#define Unit 2000.0\n\n\nfloat map(vec3 p) {\n    float sd=sd_regularstar(1.618,1.0,5,p.xy);\n    sd = opExtrusion(sd,2.0,p+vec3(0,0,0));\n    return max(abs(abs(sd) - 0.3) - 0.1, p.z - 0.5);\n}\n\nvec3 calcGrad(vec3 p) {\n\tfloat k_111 = map(vec3(p.x + EPSILON, p.y + EPSILON, p.z + EPSILON));\n\tfloat k_100 = map(vec3(p.x + EPSILON, p.y - EPSILON, p.z - EPSILON));\n\tfloat k_010 = map(vec3(p.x - EPSILON, p.y + EPSILON, p.z - EPSILON));\n\tfloat k_001 = map(vec3(p.x - EPSILON, p.y - EPSILON, p.z + EPSILON));\n\tvec3 n = vec3(k_111 + k_100 - k_010 - k_001, k_111 - k_100 + k_010 - k_001, k_111 - k_100 - k_010 + k_001);\n\treturn n / (4.0 * EPSILON);\n}\n\nvec3 castRay(vec3 p, vec3 d, vec3 light) {\n    // cast ray\n    float t = 100.0 * EPSILON, dt;\n\tvec3 P = p + t * d;\n\tif (map(p) < 0.0) return vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < MAX_STEP; i++) {\n\t\tdt = map(p + t * d);\n\t\tt += dt;\n        if (dt < -EPSILON) return vec3(1.0,0.0,0.0);\n\t\tif (dt < EPSILON) break;\n\t\tif (dt > MAX_DIST) {\n            vec3 col = vec3(1.0,1.0,1.0);\n\t\t\tt = max(dot(d, light), 0.0);\n\t\t\treturn t*t*col;\n\t\t}\n\t}\n\tP = p + t * d;\n    vec3 n = normalize(calcGrad(P));\n    if (dot(n, d) > 0.0) n = -n;\n    \n    // shadow\n    d -= 2.0 * dot(d, n)*n;\n\tfloat r = 1.0;\n\tt = 0.01;\n\tfor (int i = 0; i < MAX_STEP; i++) {\n\t\tdt = map(P + t * light);\n\t\tr = min(r, 15.0 * dt / t);\n\t\tif (r < 0.001 || t > 2.0) break;\n\t\tt += clamp(dt, 1.0, 2.0)*clamp(length(p) / Unit, 0.002, 0.2);\n\t}\n\tr = clamp(r,0.0,1.0);\n    \n    // final result\n    float dif = clamp(dot(n, light), 0.0, 1.0);\n    return (0.9*dif*r + 0.2*pow(max(dot(d,light),0.0),4.0) + 0.1)*vec3(0.9,0.8,0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = 4.0*(cos(0.4*iTime)+1.0)+3.0;\n    float r = sqrt(150.0-h*h) + 1.0*(cos(iTime)+1.0) + 8.0;\n    vec3 pos = vec3(r*cos(iTime), r*sin(iTime), h);\n    vec3 ctr = vec3(0.0,0.0,0.0);\n    vec3 dir = ctr-pos;\n    \n    float rz=atan(dir.x,-dir.y), rx=atan(length(dir.xy),dir.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 light = normalize(vec3(-0.3, 0.1, 1));\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)/float(AA)),Unit);\n        col += castRay(pos,normalize(d),light);\n    }\n    col/=float(AA*AA);\n    \n    col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    fragColor = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define PI 3.14159265358979\n\nfloat det(vec2 a, vec2 b){\n    return a.x*b.y-b.x*a.y;\n}\n\nfloat sd_circle(float r, in vec2 p) {\n\treturn length(p) - r;\n}\n\nfloat sd_segment(vec2 v1, vec2 v2, in vec2 p) {\n\tfloat t = dot(v2 - v1, p - v1);\n\tif (t < 0.0) return length(p - v1);\n\tif (t > dot(v2-v1, v2-v1)) return length(p - v2);\n\treturn abs(det(normalize(v2 - v1), p - v1));\n}\n\nfloat sd_box(vec2 Min, vec2 Max, in vec2 p) {\t// order doesn't matter\n\tif (p.x > Min.x == p.x < Max.x) {\n\t\tif (p.y > Min.y == p.y < Max.y) {\n\t\t\treturn -min(min(abs(p.x - Min.x), abs(p.x - Max.x)), min(abs(p.y - Min.y), abs(p.y - Max.y)));\n\t\t}\n\t\treturn min(abs(p.y - Min.y), abs(p.y - Max.y));\n\t}\n\telse if (p.y > Min.y == p.y < Max.y) return min(abs(p.x - Min.x), abs(p.x - Max.x));\n\treturn min(min(length(p - Min), length(p - Max)), min(length(p - vec2(Min.x, Max.y)), length(p - vec2(Max.x, Min.y))));\n}\n\nfloat sd_triangle(vec2 a, vec2 b, vec2 c, in vec2 p) {\n\ta -= p, b -= p, c -= p;\n\tif ((int(det(a, b) > 0.0) + int(det(b, c) > 0.0) + int(det(c, a) > 0.0)) % 3 != 0) {\t\t// outside\n\t\tfloat t, m, d = 1e+30, td;\n\t\tt = dot(a - b, a), m = dot(b-a,b-a); if (t > 0.0 && t < m) d = abs(det(a, b - a)) / sqrt(m);\n\t\tt = dot(b - c, b), m = dot(c-b,c-b); if (t > 0.0 && t < m) { td = abs(det(b, c - b)) / sqrt(m); if (td < d) d = td; }\n\t\tt = dot(c - a, c), m = dot(a-c,a-c); if (t > 0.0 && t < m) { td = abs(det(c, c - a)) / sqrt(m); if (td < d) d = td; }\n\t\ttd = length(a); if (td < d) d = td;\n\t\ttd = length(b); if (td < d) d = td;\n\t\ttd = length(c); if (td < d) d = td;\n\t\treturn d;\n\t}\n\telse {\t// inside\n\t\tfloat d = abs(det(a, normalize(b - a)));\n\t\tfloat td = abs(det(b, normalize(c - b))); if (td < d) d = td;\n\t\ttd = abs(det(c, normalize(a - c))); if (td < d) d = td;\n\t\treturn -d;\n\t}\n}\n\nfloat sd_regularpolygon(float r, int n, in vec2 P) {\t// first vertex at (0,r)\n\tfloat ang = 2.0 * PI / float(n);\n\tfloat rang = atan(P.x,P.y);\n\tfloat a = rang - ang * float(int(rang / ang)); if (a < 0.0) a += ang;\n\tvec2 p = length(P) * vec2(cos(a), sin(a)) - vec2(r, 0.0), e = r * vec2(cos(ang) - 1.0, sin(ang));\n\ta = dot(p, e);\n\tif (a < 0.0) return length(p); if (a > dot(e,e)) return length(p - e);\n\treturn det(p, normalize(e));\n}\n\nfloat sd_regularstar(float R, float r, int N, in vec2 P) {\t// 0<r<R, first vertex at (0,R)\n\tfloat ang = 2.0 * PI / float(N);\n\tfloat rang = atan(P.x,P.y);\n\tfloat a = rang - ang * float(int(rang / ang)); if (a < 0.0) a += ang;\n\tif (a > 0.5*ang) a = ang - a; ang /= 2.0;\n\tvec2 p = length(P) * vec2(cos(a), sin(a)) - vec2(R, 0), e = r * vec2(cos(ang), sin(ang)) - vec2(R, 0.0);\n\ta = dot(p, e);\n\tif (a < 0.0) return length(p);\n\tif (a > dot(e,e)) return length(P) < r ? -length(p - e) : length(p - e);\n\treturn det(p, normalize(e));\n}\n\nfloat sd_sector(float r, float ang, in vec2 p) {\t// centered at origin, range [-ang, ang], 0<ang<π\n\tfloat a = atan(p.y / p.x); if (p.x < 0.0) a += p.y > 0.0 ? PI : -PI; a = abs(a) - ang;\n\tfloat sd = length(p);\n\tif (a < 0.0) {\n\t\tif (sd > r) return sd - r;\n\t\tif (a > -PI / 2.0) sd = max(sd - r, sd*sin(a));\n\t\telse sd = max(sd - r, -sd);\n\t\treturn sd;\n\t}\n\tif (a > PI / 2.0) return sd;\n\tif (sd*cos(a) < r) return sd * sin(a);\n\treturn sqrt(sd*sd + r * r - 2.0 * r*sd*cos(a));\n}\n\nfloat sd_arc(float r, float ang, in vec2 p) {\t// centered at origin, range [-ang, ang], 0<ang<π\n\tfloat a = atan(p.y / p.x); if (p.x < 0.0) a += p.y > 0.0 ? PI : -PI; a = abs(a) - ang;\n\tfloat sd = length(p); if (a < 0.0) return abs(sd - r);\n\treturn length(vec2(p.x - r * cos(ang), abs(p.y) - r * sin(ang)));\n}\n\nfloat sd_ellipse(float a, float b, in vec2 P) {\t// a,b > 0\n\tvec2 p = abs(P);\n    if (p.x > p.y) { p = p.yx; float c=a; a=b, b=c; }\n\tfloat l = b * b - a * a;\n\tfloat m = a * p.x / l, m2 = m * m;\n\tfloat n = b * p.y / l, n2 = n * n;\n\tfloat c = (m2 + n2 - 1.0) / 3.0, c3 = c * c * c;\n\tfloat q = c3 + m2 * n2*2.0;\n\tfloat d = c3 + m2 * n2;\n\tfloat g = m + m * n2;\n\tfloat co;\n\tif (d < 0.0) {\n\t\tfloat p = acos(q / c3) / 3.0;\n\t\tfloat s = cos(p);\n\t\tfloat t = sin(p)*sqrt(3.0);\n\t\tfloat rx = sqrt(-c * (s + t + 2.0) + m2);\n\t\tfloat ry = sqrt(-c * (s - t + 2.0) + m2);\n\t\tco = (ry + (l > 0.0 ? rx : -rx) + abs(g) / (rx*ry) - m) / 2.0;\n\t}\n\telse {\n\t\tfloat h = 2.0*m*n*sqrt(d);\n\t\tfloat s = q + h > 0.0 ? pow(q + h, 1.0 / 3.0) : -pow(-q - h, 1.0 / 3.0);\n\t\tfloat u = q > h ? pow(q - h, 1.0 / 3.0) : -pow(h - q, 1.0 / 3.0);\n\t\tfloat rx = -s - u - c * 4.0 + 2.0*m2;\n\t\tfloat ry = (s - u)*sqrt(3.0);\n\t\tfloat rm = sqrt(rx*rx + ry * ry);\n\t\tfloat p = ry / sqrt(rm - rx);\n\t\tco = (p + 2.0*g / rm - m) / 2.0;\n\t}\n\tvec2 closestPoint = vec2(a*co, b*sqrt(1.0 - co * co));\n\tfloat sd = length(closestPoint - p);\n\tif (p.y > closestPoint.y) return sd;\n\treturn -sd;\n}\nfloat sd_ellipse_fast(float a, float b, in vec2 p) {\n\tfloat k0 = length(vec2(p.x / a, p.y / b));\n\tfloat k1 = length(vec2(p.x / (a*a), p.y / (b*b)));\n\treturn k0 * (k0 - 1.0) / k1;\n}\n\n\n\n\n\nfloat SD_sphere(float r, in vec3 p) {\n\treturn length(p) - r;\n}\n\nfloat SD_segment(vec3 v1, vec3 v2, in vec3 p) {\n\tfloat t = dot(v2-v1, p-v1);\n\tif (t < 0.0) return length(p - v1);\n\tif (t > dot(v2-v1, v2-v1)) return length(p-v2);\n\treturn length(cross(normalize(v2-v1), p-v1));\n}\n\nfloat SD_box(vec3 b, in vec3 p) {\n\tvec3 d = vec3(abs(p.x), abs(p.y), abs(p.z)) - b;\n\treturn length(max(d,0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat SD_torus(float R, float r, in vec3 p) {\t\t// xoy\n\tfloat d = length(p.xy) - R;\n\treturn sqrt(d * d + p.z * p.z) - r;\n}\n\nfloat SD_cylinder_z(float r, float min_z, float max_z, in vec3 p) {\t// perpendicular to xoy, min_z<max_z\n\tfloat d = length(p.xy) - r;\n\tif (p.z < max_z && p.z > min_z) return max(d, max(min_z - p.z, p.z - max_z));\n\tif (d < 0.0) return p.z > max_z ? p.z - max_z : min_z - p.z;\n\treturn p.z > max_z ? sqrt(d*d + (p.z - max_z)*(p.z - max_z)) : sqrt(d*d + (p.z - min_z)*(p.z - min_z));\n}\nfloat SD_cylinder(vec3 v1, vec3 v2, float r, in vec3 p) {\n\tvec3 dr = v2 - v1; float h = length(dr); dr /= h;\n\tfloat t = dot(dr, p - v1), d = length(cross(p - v1, dr)) - r;\n\tif (t < 0.0) {\n\t\tif (d > 0.0) return sqrt(d * d + t * t);\n\t\treturn -t;\n\t}\n\tif (t > h) {\n\t\tt -= h;\n\t\tif (d > 0.0) return sqrt(d * d + t * t);\n\t\treturn t;\n\t}\n\tif (d > 0.0) return d;\n\treturn max(max(-t, t - h), d);\n}\nfloat SD_cylinder(vec3 c, vec3 dir, float r, float h, in vec3 p) {\t// dir unit vectors\n\tc -= p;\n\tfloat t = -dot(dir, c);\n\tfloat d = length(cross(c, dir)) - r;\n\tif (t < 0.0) {\n\t\tif (d > 0.0) return sqrt(d * d + t * t);\n\t\treturn -t;\n\t}\n\tif (t > h) {\n\t\tt -= h;\n\t\tif (d > 0.0) return sqrt(d * d + t * t);\n\t\treturn t;\n\t}\n\tif (d > 0.0) return d;\n\treturn max(max(-t, t - h), d);\n}\n\nfloat SD_cone(vec3 c, vec3 dir, float r, float h, in vec3 p) {\t// dir unit vector,  h,r > 0.0\n\tc -= p;\n\tfloat t = -dot(dir, c);\n\tfloat d = length(cross(c, dir));\n\tif (t > h) {\n\t\tif (d < r) return t - h;\n\t\td -= r, t -= h; return sqrt(d * d + t * t);\n\t}\n\tif (t < 0.0) {\n\t\tif (r * d + h * t < 0.0) return sqrt(d * d + t * t);\n\t\treturn (h * d - r * t) / sqrt(h * h + r * r);\n\t}\n\tif (r * (d - r) + h * (t - h) > 0.0) {\n\t\td -= r, t -= h; return sqrt(d * d + t * t);\n\t}\n\td = (h * d - r * t) / sqrt(h * h + r * r);\n\tif (d > 0.0) return d;\n\treturn max(d, t - h);\n}\n\nfloat SD_ellipsoid(float xy, float z, in vec3 p) {\t// exact, rotating ellipse\n\treturn sd_ellipse(xy, z, vec2(length(p.xy), p.z));\n}\nfloat SD_ellipsoid(float a, float b, float c, in vec3 p) {\t// not exact, problem occurs inside and far outside\n\tfloat k0 = length(vec3(p.x / a, p.y / b, p.z / c));\n\tfloat k1 = length(vec3(p.x / (a*a), p.y / (b*b), p.z / (c*c)));\n\treturn k0 * (k0 - 1.0) / k1;\n}\n\nfloat SD_Bezier2(vec3 A, vec3 B, vec3 C, in vec3 P) {\n\tvec3 C2 = A - 2.0 * B + C, C1 = 2.0 * (B - A), C0 = A - P;\n\tfloat t = 2.0 * dot(C2, C2)\n\t\t, a = 3.0 * dot(C2, C1) / t, b = (2.0 * dot(C2, C0) + dot(C1, C1)) / t, c = dot(C1, C0) / t;\n\tfloat a2 = a * a, p = (-a2 / 3.0 + b) / 3.0, q = (a*a2 / 13.5 - a * b / 3.0 + c) / 2.0;\n\tfloat p3 = p * p*p, delta = q * q + p3;\n#define E (C2*t + C1)*t + C0\n\tif (delta > 0.0) {\n\t\tdelta = sqrt(delta);\n\t\tt = (delta > q ? pow(delta - q, 1.0/3.0) : -pow(q - delta, 1.0/3.0)) - (delta + q > 0.0 ? pow(delta + q, 1.0/3.0) : -pow(-delta - q, 1.0/3.0)) - a / 3.0;\n\t\treturn t > 1.0 ? length(P - C) : t < 0.0 ? length(C0) : length(E);\n\t}\n\telse {\n\t\tq = acos(-q / sqrt(-p3)) / 3.0, p = 2.0 * sqrt(-p), a /= 3.0;\n\t\tt = p * cos(q) - a;\n\t\tfloat sd = t > 1.0 ? dot(P-C,P-C) : t < 0.0 ? dot(C0,C0) : dot(E,E);\n\t\tt = -p * cos(q + PI / 3.0) - a;\n\t\tsd = min(sd, t > 1.0 ? dot(P-C,P-C) : t < 0.0 ? dot(C0,C0) : dot(E,E));\n\t\tt = -p * cos(q - PI / 3.0) - a;\n\t\tsd = min(sd, t > 1.0 ? dot(P-C,P-C) : t < 0.0 ? dot(C0,C0) : dot(E,E));\n\t\treturn sqrt(sd);\n\t}\n#undef E\n}\n\n\nfloat s_union(in float a, in float b, in float k) {\n\tfloat h = 0.5 + 0.5*(b - a) / k;\n\tif (h < 0.0) return b; if (h > 1.0) return a;\n\treturn (1.0 - h)*b + h * a - k * h * (1.0 - h);\n}\nfloat s_int(in float a, in float b, in float k) {\n\tfloat h = 0.5 - 0.5*(b - a) / k;\n\tif (h < 0.0) return b; if (h > 1.0) return a;\n\treturn (1.0 - h)*b + h * a + k * h * (1.0 - h);\n}\nfloat s_sub(in float a, in float b, in float k) {\n\tfloat h = 0.5 - 0.5*(b + a) / k;\n\tif (h < 0.0) return a; if (h > 1.0) return -b;\n\treturn (1.0 - h)*a - h * b + k * h * (1.0 - h);\n}\nfloat opExtrusion(float sd2, float h, in vec3 P) {\t// exact, extrude toward z-axis\n\tif (P.z >= 0.0 && P.z <= h) return sd2 > 0.0 ? sd2 : max(sd2, max(-P.z, P.z - h));\n\tif (P.z > h) return sd2 > 0.0 ? sqrt(sd2*sd2 + (P.z - h)*(P.z - h)) : P.z - h;\n\tif (P.z < 0.0) return sd2 > 0.0 ? sqrt(sd2*sd2 + P.z*P.z) : -P.z;\n}\n\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wl2SWd",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x00000003",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265358979\n\n#define AA 3\n\n#define EPSILON 1e-4\n\n#define MAX_STEP 128\n#define MAX_DIST 10.0\n\nfloat Unit = 500.0;\n\n\nfloat mapCube(vec3 p) {\n    float sd = max(max(abs(p.x),abs(p.y)),abs(p.z))-1.0;\n    float N=1.0;\n    for (int i=0;i<3;i++){\n        vec3 q = abs((mod(p-N,2.0*N))-N);\n        N*=1.0/3.0;\n        q/=N;\n        float xy = max(abs(q.x),abs(q.y))-1.0;\n        float yz = max(abs(q.y),abs(q.z))-1.0;\n        float xz = max(abs(q.x),abs(q.z))-1.0;\n        sd=max(sd,-N*min(min(xy,yz),xz));\n    }\n    return sd;\n}\n\nfloat mapSphere(vec3 p) {\n    float sd = length(p)-1.0;\n    float N=1.0;\n    for (int i=0;i<4;i++){\n        vec3 q = abs((mod(p-N,2.0*N))-N);\n        N*=1.0/3.0;\n        q/=N;\n        float xy = length(q.xy)-1.0;\n        float yz = length(q.yz)-1.0;\n        float xz = length(q.xz)-1.0;\n        sd=max(sd,-N*min(min(xy,yz),xz));\n    }\n    return sd;\n}\n\n#define map mapSphere\n\nvec3 calcGrad(vec3 p) {\n\tfloat k_111 = map(vec3(p.x + EPSILON, p.y + EPSILON, p.z + EPSILON));\n\tfloat k_100 = map(vec3(p.x + EPSILON, p.y - EPSILON, p.z - EPSILON));\n\tfloat k_010 = map(vec3(p.x - EPSILON, p.y + EPSILON, p.z - EPSILON));\n\tfloat k_001 = map(vec3(p.x - EPSILON, p.y - EPSILON, p.z + EPSILON));\n\tvec3 n = vec3(k_111 + k_100 - k_010 - k_001, k_111 - k_100 + k_010 - k_001, k_111 - k_100 - k_010 + k_001);\n\treturn n / (4.0 * EPSILON);\n}\n\nvec3 castRay(vec3 p, vec3 d, vec3 light) {\n    // cast ray\n    float t = 100.0 * EPSILON, dt;\n\tvec3 P = p + t * d;\n\tif (map(p) < 0.0) return vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < MAX_STEP; i++) {\n\t\tdt = map(p + t * d);\n\t\tt += dt;\n        if (dt < -EPSILON) return vec3(1.0,0.0,0.0);\n\t\tif (dt < EPSILON) break;\n\t\tif (dt > MAX_DIST) {\n            vec3 col = vec3(1.0,1.0,1.0);\n\t\t\tt = max(dot(d, light), 0.0);\n\t\t\treturn t*t*col;\n\t\t}\n\t}\n\tP = p + t * d;\n    vec3 n = normalize(calcGrad(P));\n    if (dot(n, d) > 0.0) n = -n;\n    \n    // shadow\n    d -= 2.0 * dot(d, n)*n;\n\tfloat r = 1.0;\n\tt = 0.01;\n\tfor (int i = 0; i < MAX_STEP; i++) {\n\t\tdt = map(P + t * light);\n\t\tr = min(r, 15.0 * dt / t);\n\t\tif (r < 0.01 || t > 1.0) break;\n\t\tt += 0.02*clamp(dt, 1.0, 2.0);\n\t}\n\tr = clamp(r,0.0,1.0);\n    \n    // final result\n    float dif = clamp(dot(n, light), 0.0, 1.0);\n    return (0.9*dif*r + 0.2*pow(max(dot(d,light),0.0),4.0) + 0.1)*vec3(0.9,0.8,0.8);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Unit = 0.75*length(iResolution);\n    float h = cos(0.4*iTime)+2.0;\n    float r = sqrt(10.0-h*h) + 0.2*cos(iTime) + 2.5;\n    vec3 pos = vec3(r*cos(iTime), r*sin(iTime), h);\n    //pos=vec3(-4,3,2);\n    \n    float rz=atan(-pos.x,pos.y), rx=atan(length(pos.xy),-pos.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 light = normalize(vec3(-0.2, 0.4, 0.8));\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)/float(AA)),Unit);\n        col += castRay(pos,normalize(d),light);\n    }\n    col/=float(AA*AA);\n    \n    col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    fragColor = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wl2SWt",
    "date": "1567531823",
    "viewed": 73,
    "name": "Mandelbrot++",
    "description": "zoom in to the Mandelbrot Set",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "mandelbrot",
     "complex",
     "iteration"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* Also check:\n * Mandelbrot Fractal: https://www.shadertoy.com/view/wl2SWt\n * Burning-Ship Fractal: https://www.shadertoy.com/view/wljSDt\n * Forest Fractal: https://www.shadertoy.com/view/tt2SDt\n * Crown Fractal: https://www.shadertoy.com/view/tl2SDt\n */\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p0 = vec2(-0.743643904987575,0.1318259145542959);\n    //vec2 p0 = vec2(0.3385847939577921,0.5733237332425829);\n    vec2 p1 = vec2(-0.65,0);\n    float m1 = 6.0/length(iResolution), m0 = 1e-5*m1;\n    float t = 1.0-1.0/(exp(3.0-iTime)+1.0);\n    vec2 p = mix(p0,p1,t);\n    float m = mix(m0,m1,t);\n    int MAX_ITER = int(min(floor(0.5/m),2000.0));\n    \n    vec3 col=vec3(0,0,0);\n    for (int u=0;u<AA;u++) {\n      for (int v=0;v<AA;v++){\n        vec2 z = vec2(0,0);\n        vec2 c = (fragCoord+vec2(u,v)/float(AA)-0.5*iResolution.xy)*m+p;\n        if (length(c-vec2(-1,0))>0.25 && length(c-vec2(-0.25,0))>0.5)\n        for (int i=0;i<MAX_ITER;i++){\n            z=vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+c;\n            float h = dot(z,z);\n            if (h>1.8447e+19){\n                float n = float(i)-log2(0.5*log2(h))+4.0;\n                float m = exp(-n*n/20000.0);\n                n = mix(4.0*pow((log(n+1.0)+1.0),2.0),n,m);\n              #if 1\n                  m = 5.0*sin(0.1*(n-6.0))+n;\n                  col += vec3(\n                      pow(sin((m-8.0)/20.0),6.0),\n                      pow(sin((m+1.0)/20.0),4.0),\n                      (0.8*pow(sin((m+2.0)/20.0),2.0)+0.2)*(1.0-pow(abs(sin((m-14.0)/20.0)),12.0))\n                  );\n              #else\n                  col += vec3(\n                      pow(sin((n-6.0)/20.0),6.0),\n                      pow(sin((n-2.0)/20.0),4.0),\n                      0.8*pow(sin((n+2.0)/20.0),2.0)+0.2-0.2*pow(abs(sin((n-18.0)/20.0)),6.0)\n                  );\n              #endif\n                break;\n            }\n        }\n      }\n    }\n    col/=float(AA*AA);\n    fragColor=vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wljSDt",
    "date": "1567533000",
    "viewed": 126,
    "name": "Burning-Ship ++",
    "description": "a zoom in to the Burning Ship Fractal",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fractal",
     "complex",
     "iteration"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* Also check:\n * Mandelbrot Fractal: https://www.shadertoy.com/view/wl2SWt\n * Burning-Ship Fractal: https://www.shadertoy.com/view/wljSDt\n * Forest Fractal: https://www.shadertoy.com/view/tt2SDt\n * Crown Fractal: https://www.shadertoy.com/view/tl2SDt\n */\n\n#define AA 6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p0 = vec2(-1.932246,6e-6);\n    vec2 p1 = vec2(-0.5,0.55);\n    float m1 = 6.0/length(iResolution), m0 = 1e-5*m1;\n    float t = 1.0-1.0/(exp(3.0-iTime)+1.0);\n    vec2 p = mix(p0,p1,t);\n    float m = mix(m0,m1,t);\n    int MAX_ITER = int(min(floor(0.5/m),2000.0));\n    \n    vec3 col=vec3(0,0,0);\n    for (int u=0;u<AA;u++) {\n      for (int v=0;v<AA;v++){\n        vec2 z = vec2(0,0);\n        vec2 c = (fragCoord+vec2(u,v)/float(AA)-0.5*iResolution.xy)*m+p;\n        for (int i=0;i<MAX_ITER;i++){\n            z=vec2(z.x*z.x-z.y*z.y,-abs(2.0*z.x*z.y))+c;\n            float h = dot(z,z);\n            if (h>1.8447e+19){\n                float n = float(i)-log2(0.5*log2(h))+4.0;\n                float m = exp(-n*n/20000.0);\n                n = mix(4.0*pow((log(n+1.0)+1.0),2.0),n,m);\n              #if 1\n                  m = 5.0*sin(0.1*(n-6.0))+n;\n                  col += vec3(\n                      pow(sin((m-8.0)/20.0),6.0),\n                      pow(sin((m+1.0)/20.0),4.0),\n                      (0.8*pow(sin((m+2.0)/20.0),2.0)+0.2)*(1.0-pow(abs(sin((m-14.0)/20.0)),12.0))\n                  );\n              #else\n                  col += vec3(\n                      pow(sin((n-6.0)/20.0),6.0),\n                      pow(sin((n-2.0)/20.0),4.0),\n                      0.8*pow(sin((n+2.0)/20.0),2.0)+0.2-0.2*pow(abs(sin((n-18.0)/20.0)),6.0)\n                  );\n              #endif\n                break;\n            }\n        }\n      }\n    }\n    col/=float(AA*AA);\n    fragColor=vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tt2SDt",
    "date": "1567533859",
    "viewed": 86,
    "name": "Forest-Fractal++",
    "description": "a zoom in to fractal defined by iteration z↦|Re(z²)|-|Im(z²)|i+c",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fractal",
     "complex",
     "iteration"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* Also check:\n * Mandelbrot Fractal: https://www.shadertoy.com/view/wl2SWt\n * Burning-Ship Fractal: https://www.shadertoy.com/view/wljSDt\n * Forest Fractal: https://www.shadertoy.com/view/tt2SDt\n * Crown Fractal: https://www.shadertoy.com/view/tl2SDt\n */\n\n#define AA 5\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 p0 = vec2(-1.9989191770689436,0.000002058504218357831); // I made a deep zoom in to this position with double-precision float and it looks very nice\n    vec2 p0 = vec2(-1.6837324337509336,1e-5);\n    vec2 p1 = vec2(-0.65,0.55);\n    float m1 = 6.0/length(iResolution), m0 = 1e-5*m1;\n    float t = 1.0-1.0/(exp(3.0-0.5*iTime)+1.0);\n    vec2 p = mix(p0,p1,t);\n    float m = mix(m0,m1,t);\n    int MAX_ITER = int(min(floor(0.5/m),2000.0));\n    \n    vec3 col=vec3(0,0,0);\n    for (int u=0;u<AA;u++) {\n      for (int v=0;v<AA;v++){\n        vec2 z = vec2(0,0);\n        vec2 c = (fragCoord+vec2(u,v)/float(AA)-0.5*iResolution.xy)*m+p;\n        for (int i=0;i<MAX_ITER;i++){\n            z=vec2(abs(z.x*z.x-z.y*z.y),-abs(2.0*z.x*z.y))+c;\n            float h = dot(z,z);\n            if (h>1.8447e+19){\n                float n = float(i)-log2(0.5*log2(h))+4.0;\n                float m = exp(-n*n/20000.0);\n                n = mix(4.0*pow((log(n+1.0)+1.0),2.0),n,m);\n              #if 1\n                  m = 5.0*sin(0.1*(n-6.0))+n;\n                  col += vec3(\n                      pow(sin((m-8.0)/20.0),6.0),\n                      pow(sin((m+1.0)/20.0),4.0),\n                      (0.8*pow(sin((m+2.0)/20.0),2.0)+0.2)*(1.0-pow(abs(sin((m-14.0)/20.0)),12.0))\n                  );\n              #else\n                  col += vec3(\n                      pow(sin((n-6.0)/20.0),6.0),\n                      pow(sin((n-2.0)/20.0),4.0),\n                      0.8*pow(sin((n+2.0)/20.0),2.0)+0.2-0.2*pow(abs(sin((n-18.0)/20.0)),6.0)\n                  );\n              #endif\n                break;\n            }\n        }\n      }\n    }\n    col/=float(AA*AA);\n    fragColor=vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tl2SDt",
    "date": "1567534664",
    "viewed": 89,
    "name": "Crown-Fractal++",
    "description": "a zoom in to fractal defined by iteration z↦Re(z³)-|Im(z³)|i+c",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fractal",
     "complex",
     "iteration"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/* Also check:\n * Mandelbrot Fractal: https://www.shadertoy.com/view/wl2SWt\n * Burning-Ship Fractal: https://www.shadertoy.com/view/wljSDt\n * Forest Fractal: https://www.shadertoy.com/view/tt2SDt\n * Crown Fractal: https://www.shadertoy.com/view/tl2SDt\n */\n\n#define AA 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p0 = vec2(0.0,1.285023);\n    vec2 p1 = vec2(0.0,0.4);\n    float m1 = 6.0/length(iResolution), m0 = 1e-5*m1;\n    float t = 1.0-1.0/(exp(3.0-iTime)+1.0);\n    vec2 p = mix(p0,p1,t);\n    float m = mix(m0,m1,t);\n    int MAX_ITER = int(min(floor(0.5/m),2000.0));\n    \n    vec3 col=vec3(0,0,0);\n    for (int u=0;u<AA;u++) {\n      for (int v=0;v<AA;v++){\n        vec2 z = vec2(0,0);\n        vec2 c = (fragCoord+vec2(u,v)/float(AA)-0.5*iResolution.xy)*m+p;\n        for (int i=0;i<MAX_ITER;i++){\n            z=vec2(z.x*(z.x*z.x-3.0*z.y*z.y),-abs(z.y*(3.0*z.x*z.x-z.y*z.y)))+c;\n            float h = dot(z,z);\n            if (h>2.8243e+11){\n                float n = float(i)-log(0.5*log(h)/log(3.0))/log(3.0)+4.0;\n                float m = exp(-n*n/20000.0);\n                n = mix(4.0*pow((log(n+1.0)+1.0),2.0),n,m);\n              #if 1\n                  m = 5.0*sin(0.1*(n-6.0))+n;\n                  col += vec3(\n                      pow(sin((m-8.0)/20.0),6.0),\n                      pow(sin((m+1.0)/20.0),4.0),\n                      (0.8*pow(sin((m+2.0)/20.0),2.0)+0.2)*(1.0-pow(abs(sin((m-14.0)/20.0)),12.0))\n                  );\n              #else\n                  col += vec3(\n                      pow(sin((n-6.0)/20.0),6.0),\n                      pow(sin((n-2.0)/20.0),4.0),\n                      0.8*pow(sin((n+2.0)/20.0),2.0)+0.2-0.2*pow(abs(sin((n-18.0)/20.0)),6.0)\n                  );\n              #endif\n                break;\n            }\n        }\n      }\n    }\n    col/=float(AA*AA);\n    fragColor=vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wscGz8",
    "date": "1567813560",
    "viewed": 64,
    "name": "Mandelbrot−Julia Relationship",
    "description": "Relationship between Mandelbrot and Julia set: the red dot in the Mandelbrot set represents c, where Julia set is defined by z↦z²+c. ",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fractal",
     "complex",
     "iteration"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define AA 2\n#define MAX_ITER 1024\n\nvec3 colorf(float n) {\n    float m = 5.0*sin(0.1*(n-6.0))+n;\n    return vec3(\n        pow(sin(0.05*(m-8.0)),6.0),\n        pow(sin(0.05*(m+1.0)),4.0),\n        (0.8*pow(sin(0.05*(m+2.0)),2.0)+0.2)*(1.0-pow(abs(sin(0.05*(m-14.0))),12.0))\n    );\n}\n\nvec3 Iter(vec2 z, vec2 c)\n{\n    for (int i=0;i<MAX_ITER;i++){\n        z = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y)+c;\n        float h = dot(z,z);\n        if (h>1.8447e+19){\n            float n = float(i)-log2(0.5*log2(h))+4.0;\n            return colorf(n);\n        }\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = length(iResolution);\n    float m = 7.0/d, s = 0.06*d;\n    vec2 b = iResolution.xy-sqrt(iResolution.xy*vec2(s));\n    \n    vec2 c = abs(asin(sin(0.017*iTime)))*vec2(cos(iTime)-0.4,0.8*sin(iTime));\n    \n    vec3 col=vec3(0,0,0);\n    for (int u=0;u<AA;u++){\n        for (int v=0;v<AA;v++){\n            vec2 p = fragCoord+vec2(u,v)/float(AA);\n            float sd = max(b.x-p.x,b.y-p.y);\n            if (abs(sd)<0.04*s)  // red border\n                col+=vec3(1.0,0.0,0.0);\n            else if (sd<0.0){  // Mandelbrot\n                p = 2.75*(p-b);\n                vec2 z = (p-0.5*iResolution.xy)*m;\n                if (length(z-c)<0.06) col+=vec3(1.0,0.0,0.0);  // red dot\n                else col += Iter(vec2(0.0),z);\n            }\n            else{  // Julia\n                vec2 z = (p-0.5*iResolution.xy)*m;\n                col += Iter(z, c);\n            }\n        }\n    }\n    col/=float(AA*AA);\n    fragColor=vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wstGRH",
    "date": "1569197670",
    "viewed": 2,
    "name": "Untitled 0x00000004",
    "description": "Sketchbook No.1",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define AA 2\n#define omega 1.0\n\n#define MAX_STEP 1024\n#define MAX_DIST 200.0\n#define EPSILON 1e-4\n\n#define PI 3.14159265358979\n\nfloat sdCylinder(vec3 p, float th, float r){\n    p.z=abs(p.z)-th;\n    float d = length(p.xy)-r;\n\tif (p.z<0.0) return d>0.0?d:max(d,max(-th-p.z,p.z));\n\treturn d<0.0?p.z:sqrt(d*d+p.z*p.z);\n}\n\nfloat sdCube(vec3 p, float r){\n    p=abs(p)-r;\n    return length(max(p,0.0)) + min(max(p.x,max(p.y,p.z)),0.0);\n}\n\nfloat sdDisk(vec3 p){\n    return sdCylinder(p,0.06,1.2);\n}\n\nfloat sdAxis(vec3 p){\n    return sdCylinder(p+vec3(0.0,0.0,0.2),1.3,0.07);\n}\n\nfloat sdDice(vec3 p){\n    return sdCube(p-vec3(0.9,0.0,0.2),0.1);\n}\n\nfloat map(vec3 p){\n    float sd=min(sdDisk(p),sdAxis(p));\n    sd=min(sd,sdDice(p));\n    return sd-0.02;\n}\n\nvec3 calcGrad(vec3 p){\n\tfloat k_111 = map(vec3(p.x + EPSILON, p.y + EPSILON, p.z + EPSILON));\n\tfloat k_100 = map(vec3(p.x + EPSILON, p.y - EPSILON, p.z - EPSILON));\n\tfloat k_010 = map(vec3(p.x - EPSILON, p.y + EPSILON, p.z - EPSILON));\n\tfloat k_001 = map(vec3(p.x - EPSILON, p.y - EPSILON, p.z + EPSILON));\n\tvec3 n = vec3(k_111 + k_100 - k_010 - k_001, k_111 - k_100 + k_010 - k_001, k_111 - k_100 - k_010 + k_001);\n\treturn n / (4.0 * EPSILON);\n}\n\nfloat calcShadow(vec3 p, vec3 light){\n    float t=0.01, dt;\n    for (int i=0;i<64;i++){\n        dt=map(p+t*light);\n        if (dt>MAX_DIST) break;\n        if (dt<EPSILON) return 0.5;\n        t+=dt;\n    }\n    return 1.0;\n}\n\nvec3 castRay(vec3 p, vec3 d, vec3 light){\n    float t=100.0*EPSILON, dt;\n    for (int i=0;i<MAX_STEP;i++){\n        dt = map(p+t*d);\n        t+=dt;\n        if (dt<EPSILON){\n            p=p+t*d;\n            vec3 n=calcGrad(p);\n            float k=0.3+0.7*max(dot(n,light),0.0);\n            k*=calcShadow(p,light);\n            vec3 col;\n            if (sdDice(p)-0.02<EPSILON) col=k*vec3(0.7,0.8,0.9);\n            else if (sdAxis(p)-0.02<EPSILON) col=k*vec3(0.9,0.8,0.7);\n            else if ((t=atan(p.y,p.x))>PI/3.0) col=k*vec3(0.8,1.0,1.0);\n            else if (t<-PI/3.0) col=k*vec3(1.0,0.8,1.0);\n            else col=k*vec3(1.0,1.0,0.8);\n            return col;\n        }\n        if (t>MAX_DIST) return vec3(0);\n        if (t<-EPSILON) return vec3(1,0,0);\n    }\n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Unit = 0.75*length(iResolution);\n    float h = 2.0;\n    float r = 5.0;\n    float t = -omega*iTime;\n    vec3 pos = vec3(r*cos(t), r*sin(t), h);\n    vec3 dir = vec3(0.0,0.0,-0.1)-pos;\n    \n    float rz=atan(dir.x,-dir.y), rx=atan(length(dir.xy),dir.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 l = normalize(vec3(0.4, 0.3, 0.7));\n    l = vec3(l.x*cos(t)-l.y*sin(t),l.x*sin(t)+l.y*cos(t),l.z);\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)/float(AA)),Unit);\n        col += castRay(pos,normalize(d),l);\n    }\n    col/=float(AA*AA);\n    \n    fragColor = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wddGRH",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x00000005",
    "description": "Sketchbook No.7",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define AA 2\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat ssub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\nvec2 hash2(vec2 p){\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// value and analytical gradient\nvec3 GenL(vec2 p){\n    //float st=sin(4833.87), ct=cos(4833.87), t=0.2*4833.87;\n    float st=sin(iTime), ct=cos(iTime), t=0.2*iTime;\n    float d = 1.5*(0.1*(p.x-p.y)*(p.x-p.y)-p.x-p.y+1.0);\n    float s = 1.0;\n    vec2 grad = 1.5*vec2(0.2*(p.x-p.y)-1.0,0.2*(p.y-p.x)-1.0);\n    for (int i=0;i<4;i++){\n        d += (sin(s*p.x-st)+cos(s*p.y+ct)\n           +3.0*sin(s*p.x+t)*cos(s*p.y-t))/s;\n        grad += vec2(cos(s*p.x-st)+3.0*cos(s*p.x+t)*cos(s*p.y-t),\n                     -sin(s*p.y+ct)-3.0*sin(s*p.x+t)*sin(s*p.y-t));\n        s*=2.0;\n    }\n    return vec3(d,grad);\n}\n\nfloat GenL1(vec2 p){\n    float d=1e+10;\n    for (int i=-8;i<8;i++){\n        for (int j=-8;j<8;j++){\n            vec2 rand=8.0*(hash2(vec2(i,j))-vec2(0.3));\n            rand-=p+vec2(sin(0.1*iTime+float(i)),cos(0.1*iTime+float(j)));\n            float sd=length(rand)-0.05;\n            if (d>0.0||sd>0.0) d=smin(d,sd,0.02);\n        }\n    }\n    return d+0.01*sin(20.0*p.x)*sin(20.0*p.y);\n}\n\n#define func(p) (GenL(p).x/length(GenL(p).yz))\n#define EPSILON 1e-3\nvec2 calcGrad(vec2 p){\n    float x = func(p+vec2(EPSILON,0.0))-func(p-vec2(EPSILON,0.0));\n    float y = func(p+vec2(0.0,EPSILON))-func(p-vec2(0.0,EPSILON));\n    return vec2(x,y)/(2.0*EPSILON);\n}\n\nvec3 colorf(float d){\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(60.0*d);\n\treturn mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.04,abs(d)) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 totcol = vec3(0.0);\n    for (int u=0;u<AA;u++) {\n        for (int v=0;v<AA;v++) {\n            vec2 p = 10.0*(fragCoord+vec2(u,v)/float(AA)-0.5*iResolution.xy)/length(iResolution.xy);\n            \n            vec3 G = GenL(p);\n            float g = G.x, mg = length(G.yz);\n            \n            vec3 col=vec3(1.0);\n            if (abs(g/mg)<0.03) col=vec3(0.2);\n            //else if (abs(g/mg+0.2)<0.02) col=vec3(0.5); \t// thickness not constant, need second derivative to correct\n            else if (abs((g+0.8)/mg)<0.02) col=vec3(0.5);\n            else if (g/mg>0.0){  // outside\n                col=vec3(0.1,0.4,0.7);\n            }\n            else if ((g+0.8)/mg<-0.02){  // inside\n                col=vec3(0.8,0.8,0.7);\n                float d=smax(GenL1(p),(g+1.2)/mg,0.2);\n                if (d<0.0) col=mix(vec3(0.1,0.5,0.3),vec3(0.2,0.7,1.0),clamp(-20.0*d,0.0,1.0));\n            }\n            else{  // border\n                col=vec3(0.7,0.5,0.3);\n            }\n            \n                //if (GenL1(p)<0.0) col=vec3(1,0,0);\n            //col=colorf(GenL1(p));\n            \n            totcol+=col;\n        }\n    }\n    totcol/=float(AA*AA);\n    fragColor = vec4(totcol,1.0);\n}\n\n\n\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wd3GzN",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x00000006",
    "description": "Sketchbook No.30",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#if AAS\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //fragColor=texelFetch(iChannel0,ivec2(fragCoord),0); return;\n#define C(i,j) cols[3*(i)+(j)]\n    vec3 cols[9];\n    for (int i=-1;i<=1;i++) for (int j=-1;j<=1;j++){\n        C(i+1,j+1) = texelFetch(iChannel0,ivec2(fragCoord)+ivec2(i,j),0).xyz;\n    }\n    vec3 dx,dy;\n    for (int i=0;i<3;i++){\n        float m=i==1?2.0:1.0;\n        dx+=m*max(abs(C(2,i)-C(1,i)),abs(C(1,i)-C(0,i)));\n        dy+=m*max(abs(C(i,2)-C(i,1)),abs(C(i,1)-C(i,0)));\n    }\n    vec3 g = sqrt(dx*dx+dy*dy);\n    if (dot(g,vec3(0.3,0.59,0.11))<0.8){\n        fragColor=vec4(C(1,1),1.0);\n        return;\n    }\n    //fragColor=vec4(1,0,0,0);return;\n    vec3 col;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++)\n    \tcol += calcCol(fragCoord+(vec2(i,j)+vec2(0.5))/float(AA), iResolution.xy, iTime);\n    col/=float(AA*AA);\n    fragColor = vec4(col,1.0);\n}\n\n#else\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col = texelFetch(iChannel0,ivec2(fragCoord),0).xyz;\n    fragColor = vec4(col,1.0);\n}\n\n#endif",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define AAS 1\n#define AA 3\n\n#define MAX_STEP 1024\n#define MAX_D 200.0\n#define MIN_D 0.01\n\nconst vec3 light = normalize(vec3(-0.3, 0.1, 1));\n\nfloat sdSphere(vec3 c, float r, in vec3 p){\n    return length(p-c)-r;\n}\nfloat sdBox(in vec3 b, in vec3 p) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\nfloat sdBox(in vec3 Min, in vec3 Max, in vec3 p){\n    return sdBox(0.5*(Max-Min),p-0.5*(Max+Min));\n}\n\nfloat map(in vec3 p, in float t) {\n    float base=sdBox(vec3(-1000.0,-1000.0,-10.0),vec3(0.0,0.0,2.5),p);  // base\n    float d=base;\n    base=sdBox(vec3(-5.0,-6.0,-10.0),vec3(1.0,-2.5,10.0),p);  // notch\n    d=max(d,-base);\n    base=sdBox(vec3(-1000.0,-1000.0,-10.0),vec3(-9.0,-5.5,3.5),p); \t// stage\n    d=min(d,base);\n    base=sdBox(vec3(-25.0,-30.0,-10.0),vec3(-20.0,-18.0,6.0),p);  // building\n    d=min(d,base);\n    base=sdBox(vec3(-26.0,-28.0,-10.0),vec3(-25.0,-27.0,7.0),p);  // chimney\n    d=min(d,base);\n    base=sdBox(vec3(-4.2,2.0,-10.0),vec3(-1.5,3.5,2.8),p);  // platform L\n    d=min(d,base);\n    base=sdBox(vec3(-8.0,5.2,-10.0),vec3(-1.2,6.2,2.0),p);  // platform R\n    d=min(d,base);\n    base=sdBox(vec3(-3.4,3.5,1.4),vec3(-2.2,5.2,2.0),p);  // bridge\n    d=min(d,base);\n    base=sdBox(vec3(4.0,2.0,-10.0),vec3(10.0,4.0,3.5),p);  // platform F\n    d=min(d,base);\n    base=sdSphere(vec3(5.0,3.0,4.0),0.5,p);  // ball\n    d=min(d,base);\n    d=min(d,0.1*sin(5.0*p.x+t)*sin(5.0*p.y-t)+p.z);  // wave\n    return d;\n    return 0.8*d;\n}\n\nvec3 calcGrad(in vec3 p, in float t) {\n    const float e=1e-3;\n\tfloat k_111 = map(vec3(p.x+e, p.y+e, p.z+e),t);\n\tfloat k_100 = map(vec3(p.x+e, p.y-e, p.z-e),t);\n\tfloat k_010 = map(vec3(p.x-e, p.y+e, p.z-e),t);\n\tfloat k_001 = map(vec3(p.x-e, p.y-e, p.z+e),t);\n\tvec3 n = vec3(k_111+k_100-k_010-k_001, k_111-k_100+k_010-k_001, k_111-k_100-k_010+k_001);\n\treturn n / (4.0 * e);\n}\n\nvec3 castRay(in vec3 p, in vec3 d, in float time) {\n    float t = MIN_D, dt;\n\tvec3 P = p + t * d;\n\tfor (int i = 0; i < MAX_STEP; i++) {\n\t\tdt = map(p+t*d, time);\n\t\tt += dt;\n        if (dt < -MIN_D) return vec3(1,0,0);\n        if (dt < MIN_D) {\n\t\t\tP = p + t * d;\n    \t\tvec3 n = normalize(calcGrad(P, time));\n    \t\tfloat dif = clamp(dot(n, light), 0.0, 1.0);\n    \t\treturn (0.9*dif + 0.2*pow(max(dot(d,light),0.0),4.0) + 0.1)*vec3(0.9,0.8,0.8);\n        }\n\t\tif (dt > MAX_D) break;\n\t}\n    return vec3(max(dot(d,light),0.0));\n}\n\n\nvec3 calcCol(in vec2 coord, in vec2 res, in float time) {\n    vec3 pos = vec3(12.0+cos(0.3*time),16.0+sin(0.4*time),8.0+sin(0.5*time));\n    vec3 ctr = vec3(-5.0,-5.0,2.5)+vec3(cos(0.5*time));\n    vec3 dir = ctr-pos;\n\n    float rz=atan(dir.x,-dir.y), rx=atan(length(dir.xy),dir.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n\n\n    vec3 d = M*vec3(0.5*res.x-coord.x,-0.5*res.y+coord.y,0.8*length(res));\n    vec3 col = castRay(pos,normalize(d), time);\n\n    col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    return col;\n}\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#if AAS\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col=calcCol(fragCoord+vec2(0.5),iResolution.xy,iTime);\n    fragColor = vec4(clamp(col,0.0,1.0),1.0);\n}\n\n#else\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 col;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++)\n    \tcol += calcCol(fragCoord+(vec2(i,j)+vec2(0.5))/float(AA), iResolution.xy, iTime);\n    col/=float(AA*AA);\n    fragColor = vec4(col,1.0);\n}\n\n#endif",
     "name": "Buf A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wdc3RB",
    "date": "1569197432",
    "viewed": 158,
    "name": "Untitled 0x00000007",
    "description": "simple test of non-recursive ray tracing",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "raytracing"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define AA 2\n#define Unit 0.5*length(iResolution.xy)\n\n#define EPSILON 1e-5\n\nstruct Sphere{\n    vec3 O;\n    float r;\n};\nbool sphInt(in Sphere S, in vec3 P, in vec3 d, out float t, out vec3 n) {\t// doesn't work when inside\n\tvec3 p = P - S.O; if (dot(p, d) >= 0.0) return false;\n\tvec3 k = cross(p, d); float rd2 = dot(k,k); if (rd2 >= S.r*S.r) return false;\n\tt = sqrt(dot(p,p) - rd2) - sqrt(S.r*S.r - rd2); if (t < EPSILON) return false;\n\tn = (p + t * d) / S.r; return true;\n}\nconst Sphere sph1 = Sphere(vec3(-2.0,-2.0,1.0),1.0);\nconst Sphere sph2 = Sphere(vec3(3.0,-2.0,1.3),1.3);\nconst Sphere sph3 = Sphere(vec3(1.0,3.0,1.8),1.8);\nconst Sphere sph4 = Sphere(vec3(1.0,1.0,0.4),0.4);\n\n\nvec3 traceRay(vec3 p, vec3 d, vec3 light){\n    vec3 col=vec3(1.0), ecol;\n    for (int i=0;i<64;i++){\n    \tfloat t, mt=1e+12; vec3 n, mn; bool r=false;\n    \tt=-p.z/d.z;\n        if (t>EPSILON){\n            mt=t, mn=vec3(0.0,0.0,1.0), r=true;\n            vec3 q=p+t*d;\n            ecol = ((int(floor(q.x))&1)==(int(floor(q.y))&1)) ? vec3(135,206,250)/256.0 : vec3(148,166,188)/256.0;\n        }\n    \tif (sphInt(sph1,p,d,t,n) && t<mt) r=true, mt=t, mn=n, ecol=vec3(221,160,221)/256.0;\n    \tif (sphInt(sph2,p,d,t,n) && t<mt) r=true, mt=t, mn=n, ecol=vec3(173,216,230)/256.0;\n    \tif (sphInt(sph3,p,d,t,n) && t<mt) r=true, mt=t, mn=n, ecol=vec3(255,182,193)/256.0;\n    \tif (sphInt(sph4,p,d,t,n) && t<mt) r=true, mt=t, mn=n, ecol=vec3(244,164,96)/256.0;\n        if (r) {\n            p+=mt*d;\n            d-=2.0*dot(mn,d)*mn;\n            col*=ecol;\n        }\n        else {\n            col *= vec3(max(dot(d,light),0.0));\n            break;\n        }\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = 2.0*(cos(0.4*iTime)+2.0);\n    float r = sqrt(40.0-h*h) + 0.5*(cos(iTime)+1.0) + 3.0;\n    vec3 pos = 2.0*vec3(r*cos(iTime), r*sin(iTime), h);\n    vec3 dir = vec3(0.0,0.0,1.0)-pos;\n    \n    float rz=atan(dir.x,-dir.y), rx=atan(length(dir.xy),dir.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    \n    vec3 light = normalize(vec3(0.0,0.0,1.0));\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)/float(AA)),Unit);\n        col += traceRay(pos,normalize(d),light);\n    }\n    col/=float(AA*AA);\n\n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3dcGRf",
    "date": "1578366574",
    "viewed": 120,
    "name": "Untitled 0x00000008",
    "description": "test 100% reflective surface",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define AA 2\n#define Unit 0.5*length(iResolution.xy)\n\n\n// Modeling\n\n#define MIN_D 1e-2\n#define MAX_D 1e+3\n#define RTMinD 1e-2\n#define RTMaxD 1e+12\n\nconst float h=0.5, h1=0.51, w=1.618, s=10.0, wp=1.0;\nconst vec2 r = vec2(s,s*w);\n\nfloat surf(vec3 p, out vec3 grad) {\n    float m=length(p.xy), n=m-iTime;\n    float r=h*sin(n);\n    m=h*cos(n)/m;\n    grad.x=p.x*m;\n    grad.y=p.y*m;\n    grad.z=1.0;\n    //return (p.z+r)/sqrt(dot(grad,grad)+1.0);\n    return 0.9*(p.z+r)/length(grad);\n}\nbool surfint(vec3 p, vec3 d, out float t, out vec3 n){\n    if (d.z>0.0 && p.z>h1) return false;\n    float sd;\n    t=10.0*MIN_D;\n    if (d.z<0.0&&p.z>h1) t=-(p.z-1.0)/d.z;\n    for (int i=0;i<100;i++){\n        sd=surf(p+t*d,n);\n        if (sd<-MIN_D) return false;\n        t+=sd;\n        if (t>MAX_D) return false;\n        if (t<MIN_D) break;\n    }\n    return true;\n}\n\nbool sphint(vec3 p, vec3 d, out float t, out vec3 n){\n    p.z-=h1+1.0;\n    if (dot(p, d) >= 0.0) return false;\n\tvec3 k = cross(p, d); float rd2 = dot(k,k); if (rd2 >= 1.0) return false;\n\tt = sqrt(dot(p,p) - rd2) - sqrt(1.0 - rd2); if (t < RTMinD) return false;\n\tn = p + t * d; return true;\n}\n\n// a debugging function, it looks nice so I decide to keep it\n// example image at iTime=1.90 see https://i.imgur.com/flZjpMR.png\n/*bool trackint(vec3 p, vec3 d, out float t, out vec3 n){\n    const float s=3.0;\n    float t1 = d.x+d.y/w, t2 = p.x+p.y/w, delta=4.0*s;\n    float a=2.*t1*t1, b=2.*t1*t2-delta*d.z, c=t2*t2+delta*(h1-p.z);\n    delta=sqrt(b*b-2.*a*c); if (delta<0.) return false;\n    delta=sqrt(delta)/a; b=-b/a;\n    t1=b+delta,t2=b-delta;\n    if (t1<RTMinD) t1=RTMaxD; if (t2<RTMinD) t2=RTMaxD;\n    t=min(t1,t2); if (t>=RTMaxD) return false;\n    vec3 q=p+t*d;\n    t1=0.5/s*(q.x+q.y/w), n=vec3(t1,t1/w,-1.);\n    t1=length(n.xy/vec2(1.,w)), t2=length(n.xy/vec2(1./w*w));\n  \tdelta=t1*(t1-1.0)/t2/length(n.xy);\n    if (abs(delta)>0.1) return false;\n    n=normalize(n);\n    return true;\n}*/\nbool trackint(vec3 p, vec3 d, out float t, out vec3 n){\n    float t1 = d.x+d.y/w, t2 = p.x+p.y/w, delta=4.0*s;\n    float a=t1*t1, b=2.*t1*t2-delta*d.z, c=t2*t2+delta*(h1-p.z);\n    delta=b*b-4.*a*c; if (delta<0.) return false;\n    a*=2.0,delta=sqrt(delta)/a; b=-b/a;\n    t1=b+delta,t2=b-delta;\n    vec3 q;\n#define Test(t0) q=p+t0*d; \\\n  a=0.5/s*(q.x+q.y/w), n=vec3(a,a/w,-1.); \\\n  b=length(q.xy/r), c=length(q.xy/(r*r)), a=b*(b-1.0)/c*length(n); \\\n  if (abs(a)<wp) t=t0;\n    t=RTMaxD;\n    if (t1>RTMinD) {Test(t1)}\n    if (t2>RTMinD&&t2<t) {Test(t2)}\n    if (t==RTMaxD) return false;\n    q=p+t*d;\n    a=0.5/s*(q.x+q.y/w), n=normalize(vec3(a,a/w,-1.));\n    return true;\n}\n\n\n// Rendering\n\n#define sunpos normalize(vec3(1.0,-1.0,0.5))\n#define fogcol vec3(1.0,0.7,0.4)\n#define skycol vec3(0.6,0.8,1.0)\n#define suncol vec3(0.9,0.8,0.5)\n#define fogD 0.008\n\nvec3 skycolor(vec3 d){\n    vec3 col;\n    float sky=(0.2-0.8)*max(d.z,0.0)+0.8;\n    col=sky*skycol;\n    float horizon=pow(1.0-d.z*d.z,100.0);\n    col=mix(col,vec3(1.0),horizon);\n    float sun=max(dot(d,sunpos),0.0);\n    col+=pow(sun,150.0)*suncol;\n    return col;\n}\nfloat fog(vec3 d){\n    if (d.z<=0.0) return 1.0;\n    return pow(1.0-d.z*d.z,200.0);\n}\n\nvec3 calcCol(vec3 p, vec3 d){\n    float a=0.0;\n    for (int i=0;i<16;i++){\n    \tfloat t=0.0, mt=MAX_D; vec3 n, mn; bool r=false;\n        if (sphint(p,d,t,n)) r=true, mn=n, mt=t; \t// vec3(135,250,206)/256.0;\n        if (trackint(p,d,t,n) && t<mt) r=true, mn=n, mt=t; \t// vec3(250,206,135)/256.0\n        if (surfint(p,d,t,n) && t<mt) mt=t, mn=normalize(n), r=true; \t// vec3(135,206,250)/256.0\n        if (r) {\n            p+=mt*d;\n            d-=2.0*dot(mn,d)*mn;\n        \ta+=mt;\n        }\n        else { // calculate sky color as final output\n            a=exp(-fogD*a);\n            vec3 sky=skycolor(d);\n            sky=mix(sky,fogcol,fog(d));\n            return mix(fogcol,sky,a);\n        }\n    }\n    return fogcol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = cos(0.4*iTime)+2.0;\n    float r = 0.5*(cos(iTime)+1.0) + 10.0;\n    vec3 pos = 5.0*cos(0.5*iTime)*vec3(r*cos(iTime), r*sin(iTime), h);\n    vec3 dir = vec3(0.0,0.0,1.0+h1)-pos;\n\n    float rz=atan(dir.x,-dir.y), rx=atan(length(dir.xy),dir.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n\n    vec3 col = vec3(0.0,0.0,0.0), ecol;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d = M*vec3(0.5*iResolution.x-(fragCoord.x+float(i)/float(AA)),-0.5*iResolution.y+(fragCoord.y+float(j)/float(AA)),Unit);\n        ecol = calcCol(pos,normalize(d));\n    \tif (dot(ecol,vec3(0.3,0.59,0.11))<0.1) ecol=fogcol;\n        col+=ecol;\n    }\n\n    fragColor = vec4(col/float(AA*AA),1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wsc3D2",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x00000009",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float hash(float a){\n    return fract(sin(12.9898*a+12.87)*43758.5453);\n}\nfloat hash2(vec2 p){\n\treturn fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n}\nfloat hash3(vec3 p){\n    //return 0.5*(hash2(p.xz)+hash2(p.yz));\n    //p = p.zyx;\n\treturn fract(sin(dot(p,vec3(12.9898,78.233,144.7272)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fcol, in vec2 coord ) {\n    //coord = vec2(sin(coord.x),sin(coord.y));\n    fcol = vec4(hash3(vec3(coord,fract(iTime))),\n                hash3(vec3(coord,fract(iTime+0.3))),\n                hash3(vec3(coord,fract(iTime+0.5))),\n               hash(iTime));\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WsySWt",
    "date": "1575254924",
    "viewed": 134,
    "name": "Float Limit Exceed",
    "description": "sawtooth effect produced by exceeding of float point accuracy limit",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "graph",
     "function"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float f(in float x){\n    return 0.25*(pow(exp(x)+exp(-x),2.0)-pow(exp(x)-exp(-x),2.0)); \t// always equal to 1\n}\n\nfloat grad(in float x){\n    const float eps = 1e-2;\n    float a = (f(x+eps)-f(x-eps))/(2.0*eps);\n    return sqrt(a*a+1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = 0.05*(sin(iTime)+2.0)*length(iResolution.xy);\n    vec2 p = (fragCoord-0.5*iResolution.xy)/s+vec2(10.0*sin(0.2*iTime),1.0);\n    float sd = 1.0-min(0.2*s*(abs(p.x)-0.008),1.0);\n    vec3 col = vec3(0,0,sd);\n    sd = min(s*(abs(p.y)-0.03),1.0);\n    col = mix(vec3(1,0,0),col,sd);\n\tsd = (f(p.x)-p.y)/grad(p.x);\n    sd = clamp(0.0,1.0,s*(abs(sd)-0.03));\n    col = mix(vec3(0,1,0),col,sd);\n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WdKXDt",
    "date": "1575344149",
    "viewed": 210,
    "name": "Frozen Fractals",
    "description": "And one thought crystallizes like an icy blast...\n\nFake snowflakes generated by mirroring complex fractals. \n",
    "likes": 6,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fractal",
     "iteration",
     "snowflake"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265358979\n#define AA 3\n\nint sn; \t// index of snowflake\n\nvec3 fractal(vec2 p){\n    p.x=-p.x-(cos(iTime)+5.0)/3.0;\n    vec3 col=vec3(0.0);\n    vec2 z = vec2(0.0);\n    int i;\n    for (i=0;i<64;i++){\n\n        // different iteration functions generate different snowflakes\n        if (sn==0) z=vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)+p;\n        else if (sn==3) z=vec2(z.x*z.x-z.y*z.y,-2.0*z.x*z.y)+p;\n        else if (sn==1) z=vec2(abs(z.x*z.x-z.y*z.y),2.0*z.x*z.y)+p;\n        else if (sn==4) z=vec2(abs(z.x*z.x-z.y*z.y),-2.0*z.x*z.y)+p;\n        else if (sn==2) z=vec2(z.x*z.x-z.y*z.y,-abs(2.0*z.x*z.y))+p;\n\n        // color function for Mandelbrot (https://www.shadertoy.com/view/wl2SWt)\n        float h = dot(z,z);\n        if (h>1.8447e+19){\n            float n = float(i)-log2(.5*log2(h))+4.;\n            float m = exp(-n*n/20000.);\n            n = mix(4.*pow((log(n+1.)+1.),2.),n,m);\n            m = 5.*sin(.1*(n-6.))+n;\n            col += vec3(\n                pow(sin((m-8.)/20.),6.),\n                pow(sin((m+1.)/20.),4.),\n                (.8*pow(sin((m+2.)/20.),2.)+.2)*(1.-pow(abs(sin((m-14.)/20.)),12.))\n            );\n            break;\n        }\n    }\n    if (i==64) col=vec3(1.0);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float s = 0.3*length(iResolution.xy);\n    vec3 col=vec3(0.0);\n    sn = int(iTime/(2.*PI))%5;\n    for (int u=0;u<AA;u++){\n        for (int v=0;v<AA;v++){\n    \t\tvec2 p = (fragCoord+vec2(u,v)/float(AA)-0.5*iResolution.xy)/s;\n            // rotation and mirroring\n    \t\tfloat m = length(p);\n    \t\tfloat a = abs(mod(atan(p.y,p.x)+iTime,PI/3.0)-PI/6.0);\n    \t\tcol += fractal(vec2(m*cos(a),m*sin(a)));\n        }\n    }\n    fragColor = vec4(col/float(AA*AA),1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wttGzM",
    "date": "0",
    "viewed": 0,
    "name": "Implicit SDF",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define Scale 0.1\n\nconst vec2 r=vec2(1.618,1.0);\n\nfloat imp(float x, float y){\n    vec2 p=vec2(x,y)/r; return dot(p,p)-1.0;\n    //return sqrt(x*x+y*y)-1.0;\n    //return 0.35*x*x+y*y-1.0;\n    //return x*x*x*x+y*y*y*y-1.0;\n}\n\nfloat sd_grad(vec2 p){\n    // divide by numerical gradient\n    {\n    \tfloat eps=0.001;\n    \tfloat dx = imp(p.x+eps,p.y)-imp(p.x-eps,p.y);\n    \tfloat dy = imp(p.x,p.y+eps)-imp(p.x,p.y-eps);\n    \tfloat g = length(vec2(dx,dy)/(2.0*eps));\n    \t//return imp(p.x,p.y)/g;\n    }\n    \n    // divide by analytical gradient\n    {\n        float k1=length(p/r), k2=length(p/(r*r));\n    \t//return (k1*k1-1.0)/(2.*k2);\n    }\n    \n    // divide by analytical second gradient\n    {\n    \tvec2 p1=p/r, p2=p1/r, p3=p2/r;\n        float A=dot(p1,p1)-1.0, B=2.0*length(p2);\n        vec2 a=2.0*p2, b=p3/length(p2);\n        vec2 grad=(a*B-A*b)/(B*B);\n        return A/length(a)/length(grad);\n    }\n    \n    // iq's approximation\n    {\n    \tfloat k1=length(p/r), k2=length(p/(r*r));\n    \treturn k1*(k1-1.0)/k2;\n    }\n    \n}\n\n/*float sd_grad2(vec2 p){\n    float eps=0.01;\n    float dx = sd_grad(vec2(p.x+eps,p.y))-sd_grad(vec2(p.x-eps,p.y));\n    float dy = sd_grad(vec2(p.x,p.y+eps))-sd_grad(vec2(p.x,p.y-eps));\n    float g = length(vec2(dx,dy)/(2.0*eps));\n    return sd_grad(vec2(p.x,p.y))/g;\n}*/\n\n//#define sd(p) imp((p).x,(p).y)\n#define sd(p) sd_grad(p)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/(length(iResolution.xy)*Scale);\n\tfloat d = 5.0*sd(p)*Scale;\n    if (d!=d){\n\t\tfragColor = vec4(0.0,0.25,0.0,1.0);\n        return;\n    }\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(d)));\n\tfragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wl33RX",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x0000000C",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col=texture(iChannel0,fragCoord/iResolution.xy).rgb/float(iFrame+1);\n    col=texture(iChannel0,fragCoord/iResolution.xy).rgb;\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "float obj(vec3 p){\n    const float o=3.0;\n    p.x=mod(p.x,2.0*o)-o;\n    p.y=mod(p.y,2.0*o)-o;\n    p.z-=1.0;\n    return length(p)-1.0;\n}\n\nfloat map(vec3 p){\n    float d= obj(p);\n    //return d;\n    return p.z<d?p.z:d;\n}\n\nvec3 grad(vec3 p){\n    const float e=1e-3;\n\tfloat k_111 = map(vec3(p.x + e, p.y + e, p.z + e));\n\tfloat k_100 = map(vec3(p.x + e, p.y - e, p.z - e));\n\tfloat k_010 = map(vec3(p.x - e, p.y + e, p.z - e));\n\tfloat k_001 = map(vec3(p.x - e, p.y - e, p.z + e));\n\tvec3 n = vec3(k_111 + k_100 - k_010 - k_001, k_111 - k_100 + k_010 - k_001, k_111 - k_100 - k_010 + k_001);\n\treturn n / (4.0 * e);\n}\n\nvec3 trace(vec3 p, vec3 d){\n    vec3 col=vec3(1.0), ecol;\n    for (int n=0;n<64;n++){\n        bool r=false;\n    \tfloat t=1e-2, dt;\n    \tvec3 q=p+t*d;\n    \tfor (int i=0;i<4096;i++){\n    \t    dt=map(q);\n    \t    t+=dt;\n    \t    q+=dt*d;\n            if (dt<1e-4) {\n                r=true;\n                if (q.z<1e-4) ecol=(((int(floor(q.x))&1)==(int(floor(q.y))&1))?vec3(135,206,250):vec3(148,166,188))/256.0;\n                else ecol=vec3(0.9,0.9,0.95);\n                break;\n            }\n    \t    if (t>1000.0) break;\n    \t}\n        if (r) {\n            p=q;\n            vec3 n=grad(p);\n            d-=2.0*dot(n,d)*n;\n            col*=ecol;\n        }\n        else {\n    \t    float k=clamp(d.z,0.0,1.0);\n            col *= k;\n            break;\n        }\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 Col, in vec2 coord){\n    vec3 pos=vec3(0.0,10.0*iTime+2.0,1.0);\n    vec3 dir=vec3(0,1,0);\n    float rz=atan(dir.x,-dir.y), rx=atan(length(dir.xy),dir.z);\n    mat3 M=mat3(cos(rz),sin(rz),0,-sin(rz),cos(rz),0,0,0,1)*mat3(1,0,0,0,cos(rx),sin(rx),0,-sin(rx),cos(rx));\n    float u=0.0,v=0.0;\n    vec3 d = M*vec3(0.5*iResolution.x-(coord.x+u),-0.5*iResolution.y+(coord.y+v),0.5*length(iResolution.xy));\n    vec3 col = trace(pos,normalize(d));\n    Col=vec4(col+texture(iChannel0,coord/iResolution.xy).rgb,1.0);\n    Col=vec4(col,1.0);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wttGDB",
    "date": "1577836293",
    "viewed": 23,
    "name": "Sound Test 0x00000001",
    "description": "temp",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 a = calcSound(0.01*uv.x+iTime);\n    float w = a.x+a.y;\n    float c = 20.0*abs(w-uv.y+0.5);\n    vec3 col = vec3(smoothstep(0.5,0.0,c));\n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\nvec2 mainSound( in int samp,float time){\n    return calcSound(time);\n}\n",
     "name": "Sound",
     "description": "",
     "type": "sound"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "//https://i.stack.imgur.com/1NN4r.png\n\n#if 0\n\nconst int NS = 128;\nconst float dirS = 12.0;\nconst float vS = 240.0/60.0;\nconst int S[NS] = int[NS](\n    42,51,49,47,42,00,00,42,\n    42,51,49,47,44,00,00,00,\n    44,52,51,49,46,00,00,00,\n    54,54,52,49,51,00,00,00,\n    42,51,49,47,42,00,00,00,\n    42,51,49,47,44,00,00,44,\n    44,52,51,49,54,54,54,54,\n    56,54,52,49,47,00,00,00,\n    51,51,51,00,51,51,51,00,\n    51,54,47,49,51,00,00,00,\n    52,52,52,52,52,51,51,51,\n    51,49,49,51,49,00,54,00,\n    51,51,51,00,51,51,51,00,\n    51,54,47,49,51,00,00,00,\n    52,52,52,52,52,51,51,51,\n    54,54,52,49,47,00,00,00\n);\n\n#define BASS\nconst int NE = 128;\nconst float dirE = 12.0;\nconst float vE = 240.0/60.0;\nconst int E[NE] = int[NE](\n    35,00,42,00,35,00,42,00,\n    35,00,42,00,28,00,35,00,\n    28,00,35,00,30,00,37,00,\n    30,00,42,00,35,00,42,00,\n    35,00,42,00,35,00,42,00,\n    35,00,42,00,28,00,35,00,\n    28,00,35,00,30,00,37,00,\n    34,00,42,00,35,00,42,00,\n    35,47,42,47,35,47,42,47,\n    35,47,42,49,35,47,42,47,\n    40,52,47,52,35,47,42,47,\n    37,49,44,49,42,40,39,37,\n    35,47,42,47,35,47,42,47,\n    35,47,42,49,35,47,42,47,\n    40,52,47,52,35,47,42,47,\n    37,49,44,49,42,40,39,37\n);\n\n#else\n\nconst int NS = 128;\nconst float dirS = 14.0;\nconst float vS = 284.0/60.0;\nconst int S[NS] = int[NS](\n    47,48,40,47,00,48,00,00,\n    47,48,40,48,00,47,00,38,\n    45,47,38,45,00,47,00,38,\n    43,00,00,00,41,00,00,00,\n    47,48,40,47,00,48,00,00,\n    48,47,40,48,00,47,00,38,\n    45,47,38,45,00,47,00,38,\n    43,00,00,00,42,00,00,38,\n    40,00,40,00,40,00,40,40,\n    40,38,36,36,00,00,36,36,\n    38,38,00,00,00,36,35,33,\n    00,00,00,00,00,00,00,33,\n    40,40,40,40,00,00,43,43,\n    40,00,00,00,00,00,36,36,\n    38,40,00,00,00,38,36,38,\n    00,00,00,00,00,00,00,00\n);\n\n#define BASS\nconst int NE = 16;\nconst float dirE = 2.0;\nconst float vE = 35.5/60.0;\nconst int E[NE] = int[NE](\n    45,41,43,38,45,41,43,38,\n    40,36,38,38,40,36,38,38\n);\n\n#endif\n\n\n\n\n//=====================================================================\n\n\n\n#define freq(n) 440.0*exp2(((n)-49.0)/12.0)\n\n#define sinWave(f,t) sin(6.283185307*(f)*(t))\n#define triWave(f,t) (2.0*abs(2.0*fract(f*t-0.25)-1.0)-1.0)\n#define sqrWave(f,t) (fract((f)*(t))>0.5?-0.5:0.5)\n#define sthWave(f,t) (2.0*fract((f)*(t)-0.5)-1.0)\n#define wave(f,t) sinWave(f,t)\n\nfloat calcS(float t){\n    t*=vS;\n    int n = S[int(t)%NS];\n    if (n==0) return 0.0;\n    t=fract(t);\n    float m = t<0.9?1.0:mix(1.0,0.0,10.0*(t-0.9));\n    float f = freq(float(n)+dirS);\n    return m*wave(f,t/vS);\n}\n\n#ifdef BASS\nfloat calcE(float t){\n    t*=vE;\n    int n = E[int(t)%NE];\n    if (n==0) return 0.0;\n    t=fract(t);\n    float m = t<0.9?1.0:mix(1.0,0.0,10.0*(t-0.9));\n    float f = freq(float(n)+dirE);\n    return m*wave(f,t/vE);\n}\n#endif\n\n\n\nfloat beep(float t){\n    // pretty obivious in the image but sounds really horrible\n    return mod(t,2.0)<1.0?0.0:0.005*tan(2764.6*t);\n}\n\nvec2 calcSound(float time){\n    float a = calcS(time);\n#ifdef BASS\n    float b = calcE(time);\n#else\n    float b = a;\n#endif\n    //return 0.1*vec2(a,b)+beep(time);\n    return 0.1*vec2(a,b);\n}\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tlc3Dj",
    "date": "1577581479",
    "viewed": 137,
    "name": "Heat Conduction",
    "description": "Solving heat equation numerically",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "heatequation"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 col, in vec2 p ){\n    float t=texelFetch(iChannel0,ivec2(p),0).w;\n    float r=(((-11.7227*t+18.8479)*t-7.26786)*t+0.710379)*t+0.174578;\n    float g=(-3.11386*t+3.09609)*t+0.184932;\n    float b=(((-11.9359*t+28.3134)*t-21.022)*t+4.06718)*t+0.753008;\n    col = vec4(r,g,b,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define bf iChannel0\n\nfloat D(ivec2 p){\n    float c=texelFetch(bf,p,0).w;\n    float l=texelFetch(bf,p-ivec2(1,0),0).w;\n    float r=texelFetch(bf,p+ivec2(1,0),0).w;\n    float u=texelFetch(bf,p+ivec2(0,1),0).w;\n    float d=texelFetch(bf,p-ivec2(0,1),0).w;\n    return l+r+u+d-4.*c;\n}\n\nvoid mainImage( out vec4 col, in vec2 p ){\n    float k;\n    if (iFrame==0){\n    \tvec2 q=10.*(p-0.5*iResolution.xy)/length(iResolution.xy);\n        float x=q.x+0.5,y=q.y+0.7;\n        k = x*x*x*(x-2.)+y*y*y*(y-2.)+x<0.?1.:0.;\n    }\n    else{\n        k=texelFetch(bf,ivec2(p),0).w;\n    \tif (iMouse.z>0.&&length(p-iMouse.xy)<=10.) k+=.01;\n    \tk+=0.2*D(ivec2(p));\n    }\n    col = vec4(vec3(0.0),k);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ttGGzR",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x0000000A",
    "description": "Copy of iq's Elevated",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float hash(vec2 p){\n    return fract(23892.58*sin(dot(p,vec2(28.28,73.70))));\n}\n\n// value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 p = floor(x);\n\tfloat a = hash((p+vec2(0.5,0.5))/256.0);\n\tfloat b = hash((p+vec2(1.5,0.5))/256.0);\n\tfloat c = hash((p+vec2(0.5,1.5))/256.0);\n\tfloat d = hash((p+vec2(1.5,1.5))/256.0);\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat terrain( in vec2 x, int N )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<15; i++ )\n    {\n        vec3 n = noised(p);\n        /*d=n.yz;\n        a+=b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p*=2.0;*/\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = mat2(0.8,-0.6,0.6,0.8)*p*2.0;\n    }\n\n\treturn 120.0*a;\n}\n\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 5000.0;\n    float t = tmin;\n\tfor( int i=0; i<300; i++ ) {\n        vec3 pos = ro + t*rd;\n\t\tfloat h = pos.y - terrain( pos.xz, 9 );\n\t\tif( abs(h)<(0.002*t) || t>tmax ) break;\n\t\tt += 0.4*h;\n\t}\n    \n    if( t>tmax) return vec4(0.0);\n    \n\tvec3 pos = ro + t*rd;\n    vec2 eps = vec2( 0.002*t, 0.0 );\n    vec3 nor = normalize( vec3( terrain(pos.xz-eps.xy, 15) - terrain(pos.xz+eps.xy, 15),\n                            2.0*eps.x,\n                            terrain(pos.xz-eps.yx, 15) - terrain(pos.xz+eps.yx, 15) ) );\n    return vec4(vec3(mix(0.2,1.0,nor.z)),t);\n}\n\n\nvec3 camPath( float time )\n{\n\treturn 1100.0*vec3( cos(0.0+0.23*time), 0.0, cos(1.5+0.21*time) );\n}\n\nmat3 setCamera(in vec3 d, in float r)\n{\n\tvec3 cp = vec3(sin(r), cos(r), 0.0);\n\tvec3 cu = normalize( cross(d,cp) );\n\tvec3 cv = normalize( cross(cu,d) );\n    return mat3( cu, cv, d );\n}\n\nvoid moveCamera( float time, out vec3 oRo, out vec3 oTa, out float oCr, out float oFl )\n{\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrain( ro.xz, 3) + 20.0;\n\tta.y = ro.y - 20.0;\n\tfloat cr = 0.2*cos(0.1*time);\n    oRo = ro;\n    oTa = ta;\n    oCr = cr;\n    oFl = 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*0.1 - 0.1 + 0.3 + 4.0*iMouse.x/iResolution.x;\n\n    // camera position\n    vec3 ro, ta; float cr, fl;\n    moveCamera( time, ro, ta, cr, fl );\n\n    // camera2world transform    \n    mat3 cam = setCamera(normalize(ta-ro), cr );\n    //cam = setCamera(vec3(-1),0.0);\n\n    // pixel\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    float t = 5000.0;\n    vec3 tot = vec3(0.0);\n    vec2 s = p;\n\n\t// camera ray    \n\tvec3 rd = cam * normalize(vec3(s,fl));\n\n\tvec4 res = render( ro, rd );\n\tt = min( t, res.w );\n\t\n\ttot += res.xyz;\n\n    fragColor = vec4( tot, -1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wtGGz1",
    "date": "0",
    "viewed": 0,
    "name": "Sound Test 0x00000002",
    "description": "copied from https://www.shadertoy.com/view/wlyGRz",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 a = calcSound(0.01*uv.x+iTime);\n    float w = a.x+a.y;\n    float c = 20.0*abs(w-uv.y+0.5);\n    vec3 col = vec3(smoothstep(0.5,0.0,c));\n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Procedural Music Sequencer\n// by Hazel Quantock 2020\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License. https://creativecommons.org/licenses/by-sa/4.0/\n\n// random hash from here: https://www.shadertoy.com/view/4dVBzz\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) ((p)*M1)\n#define coord2(p) ((p).x*M1^(p).y*M2)\n#define coord3(p) ((p).x*M1^(p).y*M2^(p).z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\n\nint baseNote;\nfloat bps;\n\nint majorScale( int index )\n{\n    return (index*12)/7; //0,2,4,6,7,9,11,12,14,16,18,19,...\n}\n\nint pentatonicScale( int index )\n{\n    return (index*12)/5; //0,2,4,7,9,12,14,16,19,...\n}\n\nfloat frequency( int note )\n{\n    return 440. * exp2( float(note + baseNote) / 12. );\n}\n\nfloat triangleWave( int note, float time )\n{\n    return fract(frequency(note)*time)*2.-1.;\n}\n\nfloat squareWave( int note, float time )\n{\n    return step(.5,fract(frequency(note)*time))*2.-1.;\n}\n\nfloat sineWave( int note, float time )\n{\n    return sin(6.283185*frequency(note)*time);\n}\n\nvoid beat( out int i, out float f, float beatLength, float time )\n{\n    f = time*bps/beatLength;\n    i = int(floor( f ));\n    f -= float(i);\n}\n\nvec2 calcSound( float time )\n{\n    // YES!! iDate.w changes every time and sound is regenerated on rewind!\n    uint seed = coord1(uint(iDate.w));//uvec3(iDate));\n    vec4 rand = hash4(seed);\n    seed = coord1(seed);\n    \n    // todo: vary these on initialisation\n    baseNote = int(rand.x*12.999)-15;//-9; // relative to middle A\n    int inversion = int(rand.y*12.999)-5;\n    bps = 140./60.;\n    ivec4 triads = ivec4(hash4(seed)*6.999);\n    seed = coord1(seed);\n    \n    int beatsPerBar = 4*int(exp2(floor(rand.y*2.999)));\n    int barsPerPhrase = 4; // this currently has to match the number of triads\n    \n    // timings\n// this would be neater with a function taking number of beats returning int and float\n// which would also work for arp\n    int beat = int(floor(time*bps));\n    float beatf = time*bps-float(beat);\n    int bar = beat/beatsPerBar;\n    float barf = (float(beat-bar*beatsPerBar)+beatf)/float(beatsPerBar);\n    int phrase = bar/barsPerPhrase;\n    float phrasef = (float(bar-phrase*barsPerPhrase)+barf)/float(barsPerPhrase);\n// todo: have verse phrase, chorus phrase alternate a few times, then bridge phrase and final chorus phrase\n// only difference between phrases should be random seed\n\n    int barInPhrase = bar%barsPerPhrase;\n    int beatInBar = beat%beatsPerBar;\n\n    // note frequencies are: exp2(i/12.+octave)*baseFreq\n    \n    // 6 triads = alternate notes in the scale, starting on the first 6 notes\n    \n    // pick a triad for the bar\n    int triadBaseNote = triads[barInPhrase];\n    \n    // invert the triads into the same range\n    ivec3 triad =\n        ivec3(\n        \t((majorScale(triadBaseNote)-inversion)%12)+inversion,\n    \t\t((majorScale(triadBaseNote+2)-inversion)%12)+inversion,\n    \t\t((majorScale(triadBaseNote+4)-inversion)%12)+inversion\n        );\n    \n    // sort these notes! this is important for arp and bass\n    if ( triad.x < triad.y )\n    {\n        if ( triad.y < triad.z ) triad.xyz = triad.xyz;\n        else if ( triad.x < triad.z ) triad.xyz = triad.xzy;\n            else triad.xyz = triad.zxy;\n    }\n    else\n    {\n        if ( triad.x < triad.z ) triad.xyz = triad.yxz;\n        else if ( triad.y < triad.z ) triad.xyz = triad.yzx;\n            else triad.xyz = triad.zyx;\n    }\n\n    float f = 0.;\n    \n    // play the chord as pads\n    float padAmp = .1*smoothstep(0.,.1,barf)*smoothstep(1.,.5,barf);\n    f += (triangleWave(triad[0],time) + triangleWave(triad[1],time) + triangleWave(triad[2],time))*padAmp;\n    \n    // arpeggiator\n    int arpPerBeat = int(floor(pow(rand.w,2.)*4.999))+2; // I thought 5 would sound bad but it's ok actually\n    float arpf = time*bps * float(arpPerBeat);\n    int arpb = int(floor(arpf));\n    arpf -= float(arpb);\n    \n    // run through the notes of the triad\n    vec4 randArp = hash4(seed);\n    seed = coord1(seed);\n    int range = int(randArp.y*5.999+3.);\n    int arpNote =\n        randArp.z > .5 ?\n        abs(((arpb+int(randArp.x*100.999))%(range*2))-(range-1)) // yoyo\n    \t: arpb%range; // ascending\n    arpNote += int(randArp.w*5.999)-2;\n    float arpAmp = .1*step(arpf,.5);//smoothstep(0.,.001,arpf)*smoothstep(.5,.499,arpf);//pow(1.-arpf,2.);\n    \n    int octFudge = 2; // mods go wrong on -ves\n    arpNote += octFudge*3;\n    f += squareWave(triad[arpNote%3] + 12*(arpNote/3 - octFudge),time)*arpAmp;\n    \n    \n    // bass line - play the bottom note of the chord in a random rhythm\n\t// it's ok but the randomness is a bit too random\n    if ( hash1(coord2(uvec2(seed,barInPhrase)))*.9+.1 > hash1(coord2(uvec2(beatInBar,seed)))*2.*float(beatInBar)/float(beatsPerBar) )    {\n        float bassAmp = .4*smoothstep(.0,.001,beatf)*pow(1.-beatf,1.);\n        f += mix(\n            \tsineWave(triad[0]-12,time)*3.,\n            \ttriangleWave(triad[0]-24,time),\n            //mix(0.,.5,pow(1.-beatf,2.))) // quite a nice pluck effect\n            mix(0.,.3+.4*hash1(coord1(uint(beat))),pow(1.-beatf,2.))) // add a little randomness to the \"harshness\" of the pluck\n            * bassAmp;\n    }\n    \n    \n    // todo: Melody\n    // more complicated rhyhm than bass\n    // pick notes randomly from the pentatonic scale for the melody\n    // but start and end each phrase with a note from the triad\n    \n    \n    return vec2(f)*.3;\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\nvec2 mainSound( in int samp,float time){\n    return calcSound(time);\n}\n",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WtK3Ry",
    "date": "1579568369",
    "viewed": 189,
    "name": "Untitled 0x0000000D",
    "description": "basically a copy of my c++ code [url]https://github.com/Harry7557558/Graphics/blob/light2d/light2d%20(no%20recursion).cpp[/url] (not gl)",
    "likes": 8,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "light2d"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 c, in vec2 p) {\n\tc = texelFetch(iChannel0, ivec2(p), 0);\n    c /= float(iFrame+1);\n}\n\n\n// Bug fix history:\n// Buffer A line 70 originally uses 0.0*R!=0.0 to test NAN.\n// Shader optimizer foiled this trick.\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265358979\n\n// set SAMPLE to a smaller value if you have a slow machine\n#define SAMPLE 64\n#define EPSILON 1e-4\n#define MAX_STEP 64\n#define MAX_DIST 10.0\n#define MAX_RECU 50\n\nvec2 CENTER = vec2(0.0, 0.0);\nfloat SCALE = 100.0;\nfloat BULB = 2.0;\nfloat INDEX = 1.5;\n\n\nfloat hash(vec2 x){\n    return fract(sin(dot(x,vec2(12.9898,78.233)))*43758.5453);\n}\n\nvec2 Refract(vec2 I, vec2 N, float n1, float n2, out float R) {\n\tfloat eta = n1 / n2;\n\tfloat ci = -dot(N, I);\n\tif (ci < 0.) ci = -ci, N = -N;\n\tfloat ct = sqrt(1.0 - eta * eta * (1.0 - ci * ci));\n\tvec2 r = I * eta + N * (eta * ci - ct);\n\tfloat Rs = (n1 * ci - n2 * ct) / (n1 * ci + n2 * ct);\n\tfloat Rp = (n1 * ct - n2 * ci) / (n1 * ct + n2 * ci);\n\tR = 0.5 * (Rs * Rs + Rp * Rp);\n\treturn r;\n}\n\n\nfloat sdBulb(vec2 p) {\n\t//return length(p - vec2(3.0)) - 1.0;\n\t//return length(vec2(abs(p.x) - 3.0, abs(p.y) - 3.0)) - 0.5;\n\treturn length(vec2(p.x, p.y - 3.0)) - 1.0;\n}\n\nfloat sdObj(vec2 p) {\n\t//return length(p)-1.0;\t// circle\n\t//return (abs(p.x)>0.8?length(vec2(abs(p.x)-0.8,p.y)):abs(p.y))-0.8;\t// capsule\n\t//return max(abs(p.x) - 1.2, abs(p.y) - 0.75);\t// rectangle\n\t//return max(length(vec2(p.x,p.y-0.4))-1.0,p.y-0.5);\t// semi-circle\n\treturn min(max(abs(p.x),abs(p.y)-1.2), max(abs(p.x)-0.7,abs(p.y-0.5)))-0.2;\t// cross\n\t//p=abs(p); return min((p.y>1.0?length(p-vec2(0.65,1.0)):abs(p.x-0.65))-0.2, max(p.x-0.65,p.y)-0.2);\t// letter H\n}\n\nvec2 gradient(vec2 p) {\n\tfloat k = 0.001;\n\tfloat u = sdObj(vec2(p.x + k, p.y)) - sdObj(vec2(p.x - k, p.y));\n\tfloat v = sdObj(vec2(p.x, p.y + k)) - sdObj(vec2(p.x, p.y - k));\n\treturn vec2(u, v) * (0.5 / k);\n}\n\nfloat traceRay(vec2 p, vec2 d) {\n\tint N = 0;\n\twhile (N++ < MAX_RECU) {\n\t\tfloat t = 10.0*EPSILON, dt, sdb, sdo, ot, it, R;\n\t\tvec2 q, n, r;\n\t\tint i; for (i = 0; i < MAX_STEP; i++) {\n\t\t\tq = p + d * t;\n\t\t\tsdb = sdBulb(q);\n\t\t\tif (sdb <= EPSILON) return BULB;\n\t\t\tsdo = sdObj(q);\n\t\t\tdt = sdb > sdo ? sdo : sdb;\n\t\t\tif (abs(dt) <= EPSILON) {\n\t\t\t\tn = normalize(gradient(q)), r;\n\t\t\t\tif (dt >= 0.0) r = Refract(d, n, 1.0, INDEX, R);\n\t\t\t\telse r = Refract(d, n, INDEX, 1.0, R);\n\t\t\t\tif (isnan(R)) R = 1.0;  // bug fixed: 0.0*R!=0.0 got optimized\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tt += abs(dt);\n\t\t\tif (t > MAX_DIST) return 0.0;\n\t\t}\n\t\tif (i == MAX_STEP) return 0.0;\n\n\t\tt = hash(q + d * R + iTime);\n\t\tif (t < R) p = q, d = reflect(d, n);\n\t\telse p = q, d = r;\n\t}\n\treturn 0.0;\n}\n\nfloat Sample(vec2 p) {\n\tfloat c = 0.0;\n\tfloat s = 1.0 / SCALE, h = -0.5 / SCALE;\n\tfor (int i = 0; i < SAMPLE + min(iFrame, 0); i++) {\n\t\tfloat a = 2.0 * PI * (float(i) + hash(p + vec2(i) + iTime)) / float(SAMPLE);\n\t\tvec2 d = vec2(cos(a), sin(a));\n\t\tc += traceRay(p + vec2(hash(p + iTime - float(i))) * s, d);\n\t}\n\treturn c / float(SAMPLE);\n}\n\nvoid mainImage( out vec4 col, in vec2 coord ) {\n\tSCALE = 0.2*sqrt(iResolution.x*iResolution.y);\n\tvec2 p = (coord - iResolution.xy * 0.5) * (1.0 / SCALE) + CENTER * 0.5;\n\tfloat c = Sample(p);\n\tcol = vec4(vec3(c), 1.0);\n    col += texelFetch(iChannel0, ivec2(coord), 0);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3tK3z3",
    "date": "1579497743",
    "viewed": 114,
    "name": "Float Limit Exceed 95 chars",
    "description": "mirroring an oblique ellipse x² + y² - |x|·y = r²\nresult may be different on different hardware",
    "likes": 3,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "heart",
     "pink",
     "short",
     "cyan"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define mainImage(c,p) \\\n\tc.xy = 4.*p-iResolution.xy; \\\n\tc = sin(dot(c,c)-abs(c.x)*c.y+iTime+vec4(3,2,0,0))",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wly3WG",
    "date": "1579723999",
    "viewed": 183,
    "name": "Fitting Arc using Bézier",
    "description": "Least square fitting an unit arc using cubic bezier curve. \nEllipse fitting can be done by simply applying a linear transform. ",
    "likes": 12,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "bezier",
     "circle",
     "approximation",
     "arc",
     "fitting",
     "leastsquare",
     "2021"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/*\n\tFitting an unit arc using cubic bezier curve\n\tEllipse fitting can be done by simply applying a linear transform.\n\n\tBasic Idea:\n\n\tLet the start point be A(0,1) and the endpoint be B(cosθ,sinθ), the two other \n\tcontrol points be C(1,x) and D=B+x*(sinθ,-cosθ). Let the equation of the bezier \n\tcurve be P(t)=(1-t)³·A+3t(1-t)²·B+3t²(1-t)·C+t³·D and the error be \n\tE(x)=Integral[(P²-1)²,t,0,1]. This integral is be a quartic polynomial \n\tabout x. Let its derivative equal to zero and solve for x, thus determine \n\tcontrol point B and C.\n\n\tSince the calculation is very machanical and error-prone, I used WolframAlpha \n\tto do expanding, integration and differentiation.\n\n\tAs one can see, when θ<2rad, it's not easy to notice the difference between the \n\tcircle and the fitted curve.\n\n\t2020-03-05:\n\tAdd numerical approximation solutions generated by polynomial regression.\n\t(Simpson's integration in [0,2], 2×100000 samples, Gaussian elimination, double-precision)\n*/\n\n\n#define PI 3.1415926\n#define _13 0.333333333\n#define cbrt(x) ((x)>0.?pow(x,_13):-pow(-(x),_13))\n\n#define Clamp(x) clamp(x,0.,1.)\n\nstruct Bezier3{\n    vec2 A, B, C, D;\n};\n\n\n// ========================= Fitting Code =========================\n\n\nvoid fitArc(float a, out Bezier3 R) {\n    float S = sin(a), C = cos(a), x;\n#if 1\n    // derivative of error: error'=ax³+bx²+cx+d\n\tfloat s2 = S * S, c2 = C * C, sc2 = s2 + c2, sc22 = sc2 * sc2;\n\ta = 1. / (756.*(sc22 + 1.) + 810.*s2 - 1890.*(sc2 + 1.)*C + 2430.*c2);\n\tfloat c = (2520.*sc22 + 2736.*s2 + (-507.*sc2 - 6600.*C + 7215.)*C - 2628.) * a,\n\t\tb = (3996.*(sc2 + 1.) - 6750.*C)*S * a, d = (3439.*sc2 + 4276.*C - 7715.)*S * a;\n    // solve the cubic equation to determine the minima\n\tfloat p = (c - b * b * _13) * _13, q = -0.5 * ((b*b / 13.5 - c * _13) * b + d);\n\ta = q * q + p * p * p;\n\tx = a > 0.0 ? cbrt(q + sqrt(a)) + cbrt(q - sqrt(a)) - b * _13\n\t\t: 2.0 * pow(q*q - a, 0.5*_13) * cos(atan(sqrt(-a), q) * _13) - b * _13;\n    // 450+ time unit\n#else\n    // numerical approximation\n    // 12 time unit, ERR = 2.75e-04, RMSE = 8.02e-05, notable error\n    x = ((0.008561080643*a-0.002518989170)*a+0.334292025655)*a;\n    // 23 time unit, ERR = 2.51e-06, RMSE = 6.29e-07, few error\n    x = ((((0.000223623140*a-0.000237833794)*a+0.007216725971)*a-0.000130686154)*a+0.333353941704)*a;\n    // 28 time unit, ERR = 2.71e-07, RMSE = 6.11e-08, no visible error\n    x = (((((0.000027936409*a+0.000060660755)*a+0.000117720501)*a+0.006861171676)*a+0.000027337977)*a+0.333330238084)*a;\n#endif\n    // apply the solution of the equation to the control points\n    R.A=vec2(1,0), R.B=vec2(1,x), R.C=vec2(C+x*S,S-x*C), R.D=vec2(C,S);\n}\n\nfloat sdBezier3(in Bezier3 R, in vec2 p) {\n\tvec2 A = R.D-R.A+3.*(R.B-R.C), B = 3.*(R.C-2.*R.B+R.A), C = 3.*(R.B-R.A);\n\tvec2 a=vec2(1,0), b, pa=p-a, ba, q;\n\tfloat d = dot(pa,pa);\n\tfor (float dt=.02, t = dt; t < 1.; t += dt) {\n\t\tb = ((A*t + B)*t + C)*t + R.A;\n\t\tpa=p-a, ba=b-a, q=pa-ba*Clamp(dot(pa,ba)/dot(ba,ba));\n\t\td = min(d, dot(q,q));\n\t\ta = b;\n\t}\n\treturn sqrt(d);\n}\n\nvoid mainImage(out vec4 col, in vec2 P) {\n    vec2 res = iResolution.xy;\n    vec2 p = 6.0*(P-.5*res)/length(res);\n    float h = .2*length(res); \t// hardness of anti-aliasing\n\n    float ang = atan(p.y,p.x), a;\n    if (iMouse.z>0.){\n        vec2 d = iMouse.xy-.5*iResolution.xy;\n        a = atan(d.y,d.x);\n    }\n    else a = sin(iTime), a=PI*a*a;\n    if (ang<0.) ang+=2.*PI; if (a<0.) a+=2.*PI;\n\n    // axis\n    vec2 axis = Clamp(h*(abs(p)-.02));\n    vec3 bkg = mix(vec3(0,0,1),vec3(1),min(axis.x,axis.y));\n\n    // circle\n    float circ = Clamp(h*(abs(length(p)-1.)-.02));\n    vec3 c = mix(ang<a?vec3(1,0,0):vec3(.7),bkg,circ);\n\n    // bezier curve\n    Bezier3 R;\n    fitArc(a, R);\n    float d = sdBezier3(R,p);\n    c = mix(vec3(0),c,Clamp(h*(d-.01)));\n\n    // vertexes\n    d = min(length(p-R.B),length(p-R.C))-.04;\n    c = mix(vec3(0),mix(vec3(1),c,Clamp(h*d)),Clamp(h*(abs(d)-.002)));\n    d = min(length(p-R.A),length(p-R.D))-.05;\n    c = mix(vec3(0),mix(vec3(1),c,Clamp(h*d)),Clamp(h*(abs(d)-.005)));\n\n    col = vec4(c,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3tVGWG",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x0000000E",
    "description": "old religion assignment",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265358979\n#define AA 2\n\nconst vec3 atmo_col=vec3(0.0,0.7,1.3);\n\nvec3 sun = normalize(vec3(-1.0,-0.1,1.0));\n\nfloat star(vec3 d){\n    return pow(abs(noise3(600.0*d).x)+0.35,10.0);\n}\n\nvec3 earthcol(vec3 p){\n    float u=atan(p.x,p.z)/(2.*PI), v=0.5*(p.y+1.0);  // uniform distributed between 0 and 1\n    float k=cloud(20.0*vec2(u,v),iTime);\n    vec3 cloud=mix(vec3(1.0),vec3(0.5),k);\n    float l=max(dot(p,sun)+0.25,0.1);\n    return l*cloud;\n}\n\nvec3 calccol(vec3 p, vec3 d) {\n    float t=0.0, dt;\n    int i;\n\tvec3 k = cross(p,d); float rd2 = dot(k,k);\n    if (rd2 < 1.0) {  // earth\n        float t = sqrt(dot(p,p) - rd2) - sqrt(1.0 - rd2);\n    \tp+=t*d;\n    \tfloat atmo=max(0.2/abs(dot(p,d))-0.3,0.0);\n    \tfloat l=max(dot(p,sun)+0.25,0.0);\n    \treturn 0.5*earthcol(p)+atmo*l*atmo_col;\n    }\n    vec3 str = vec3(star(d));\n    float light=pow(max(dot(d,sun),0.0),300.0);\n    p-=dot(p,d)*d;\n    float rd=length(p);\n    float atmo=max(0.3/(sqrt(1.0-(2.0-rd)*(2.0-rd)))-0.3,0.0);\n    vec3 atm=atmo*max(dot(normalize(p),sun)+0.2,0.0)*atmo_col;\n    return str+light*vec3(1.0)+clamp(atm,0.0,1.0);\n}\n\n\n\n\n\n\nmat3 setcamera(vec3 d, vec3 n){\n    d=normalize(d),n=normalize(n);\n    vec3 k=-d,j=normalize(n-dot(d,n)*d), i=cross(j,k);\n    float x=atan(j.z,k.z), z=atan(i.y,i.x), y=atan(-i.z,length(i.xy));\n    return mat3(cos(z),sin(z),0,-sin(z),cos(z),0,0,0,1)\n         * mat3(cos(y),0,-sin(y),0,1,0,sin(y),0,cos(y))\n         * mat3(1,0,0,0,cos(x),sin(x),0,-sin(x),cos(x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t=0.05*iTime;\n    vec3 pos = 1.3*vec3(cos(t),0.0,sin(t));\n    vec3 dir = 1.22*vec3(cos(t+0.1),0.0,sin(t+0.1))-pos;\n    \n    mat3 M=setcamera(dir,pos+vec3(0.0,0.05,0.0));\n    \n    float unit=1.0*length(iResolution.xy);\n    vec3 col=vec3(0.0);\n    for (int u=0;u<AA;u++){\n        for (int v=0;v<AA;v++){\n            vec2 f=fragCoord+vec2(u,v)/float(AA)-0.5*iResolution.xy;\n            vec3 d = normalize(M*vec3(f,-unit));\n    \t\tcol+=clamp(calccol(pos,d),0.0,1.0);\n        }\n    }\n    fragColor=vec4(col/float(AA*AA),1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// starry sky: https://www.shadertoy.com/view/4dffRH\nvec3 hash33(vec3 p) {\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nvec4 noise3(in vec3 x) {\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    #if 1\n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    #else\n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    #endif    \n    \n    // gradients\n    vec3 ga = hash33( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash33( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash33( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash33( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash33( p+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash33( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash33( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash33( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\n\n\n\n\n//====================================================================================\n\n\n\n\n\n// clouds: https://www.shadertoy.com/view/4tdSWr\nconst float cloudscale = 1.1;\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash2( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise2( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise2(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\nfloat cloud(vec2 p, float t) {\n\tvec2 uv = p;\n    float time = t * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise2( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv = p;\n\tuv *= cloudscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise2( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = t * speed * 2.0;\n    uv = p;\n\tuv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise2( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = t * speed * 3.0;\n    uv = p;\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise2( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    f = cloudcover + cloudalpha*f*r;\n    \n    return clamp(f + c, 0.0, 1.0);\n    \n}\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3tG3Dc",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x0000000F",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 map(float t) {\n    /*const int N = 20;\n    vec2 path[N];\n    path[0] = vec2(2.4998, 0.0106), \n    path[1] = vec2(2.5038, 2.0531), \n    path[2] = vec2(1.7621, 2.0475), \n    path[3] = vec2(1.7621, 0.8170), \n    path[4] = vec2(1.4807, 0.8133), \n    path[5] = vec2(1.4748, 1.1497), \n    path[6] = vec2(1.3597, 1.1498), \n    path[7] = vec2(1.3599, 1.2760), \n    path[8] = vec2(1.5630, 1.2791), \n    path[9] = vec2(1.5802, 1.5380), \n    path[10] = vec2(1.0455, 1.5369), \n    path[11] = vec2(1.0561, 1.2715), \n    path[12] = vec2(1.2675, 1.2713), \n    path[13] = vec2(1.2702, 1.1536), \n    path[14] = vec2(1.1700, 1.1492), \n    path[15] = vec2(1.1626, 0.8191), \n    path[16] = vec2(0.8519, 0.8170), \n    path[17] = vec2(0.8519, 2.0475), \n    path[18] = vec2(0.0037, 2.0509), \n    path[19] = vec2(0.0104, 0.0215);\n    for (int i=0; i<N; i++) path[i]+=vec2(-1.3,-1.1);*/\n    \n    const int N = 23;\n    vec2 path[N];\n\tpath[0] = vec2(0.5952, -0.0063), \n\tpath[1] = vec2(0.9413, 0.0258), \n\tpath[2] = vec2(1.0070, 0.7192), \n\tpath[3] = vec2(0.3847, 0.6577), \n\tpath[4] = vec2(0.2150, -0.0698), \n\tpath[5] = vec2(0.3247, -0.1110), \n\tpath[6] = vec2(0.1134, 0.7722), \n\tpath[7] = vec2(-0.7288, 0.8364), \n\tpath[8] = vec2(-1.0633, 0.1866), \n\tpath[9] = vec2(-0.5052, -0.0586), \n\tpath[10] = vec2(-0.1050, 0.5325), \n\tpath[11] = vec2(-0.4391, 0.4664), \n\tpath[12] = vec2(-0.4318, -0.0109), \n\tpath[13] = vec2(-0.7769, -0.8480), \n\tpath[14] = vec2(-1.0486, -0.5102), \n\tpath[15] = vec2(-0.7907, -0.0711), \n\tpath[16] = vec2(-0.1821, -0.2703), \n\tpath[17] = vec2(0.4163, -1.0536), \n\tpath[18] = vec2(0.2511, -0.9912), \n\tpath[19] = vec2(0.2841, -0.4992), \n\tpath[20] = vec2(0.5632, -0.1908), \n\tpath[21] = vec2(0.7651, 0.3746), \n\tpath[22] = vec2(0.5008, 0.2608);\n    \n    \n    t*=float(N);\n    int d = int(floor(t));\n    t = fract(t);\n    vec2 A = path[d%N], B = path[(d+1)%N], C = path[(d+2)%N], D = path[(d+3)%N];\n    vec2 C3 = (D-C*3.+B*3.-A)/6., C2 = (A-B*2.+C)*.5, C1 = (C-A)*.5, C0 = (A+B*4.+C)/6.;\n    return ((C3*t + C2)*t + C1)*t + C0;\n}\n\nfloat sdSqSegment( in vec2 p, in vec2 a, in vec2 b ) {\n\tvec2 pa = p - a, ba = b - a;\n\tvec2 q = pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return dot(q,q);\n}\n\nfloat sd(vec2 p) { \t// from iq's https://www.shadertoy.com/view/Xlf3zl\n    float h = 0.005;\n    float t_max = min(1.5*fract(0.15*iTime),1.0);\n    t_max += h;\n\tfloat t = 0.0;\n    vec2  a = map(t), b;\n    float d = dot(p-a,p-a);\n    t += h;\n    while (t < t_max) {\n        b = map(t);\n        d = min( d, sdSqSegment( p, a, b ) );\n\t\tt += clamp( 0.003*length(a-p)/length(a-b), 0.002, 0.01 );\n        a = b;\n\t}\n\td = min(sqrt(d), abs(length(p-vec2(-0.05,0.))-0.15));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 p = 5.0 * (fragCoord-0.5*res) / length(res);\n    float d = sd(p);\n    vec3 col = vec3(clamp(100.0*d-0.1,0.0,1.0));\n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3tcSzn",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x00000011",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define S 5.0\n\nvec3 color(in float d){\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-2.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(600.0*d/S);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(5.0*d/S)));\n\treturn col;\n}\n\nfloat sd(vec2 p){\n    p = abs(p);\n    float d2 = length(p)-1.0;\n    float d4 = sqrt(length(p*p))-1.0;\n    float d6 = pow(length(p*p*p),1./3.)-1.0;\n    float d8 = pow(length(p*p*p*p),0.25)-1.0;\n    float d0 = max(abs(p.x),abs(p.y))-1.0;\n    return mix(d2,d6,cos(iTime)*cos(iTime));\n}\n\n// the usual way for bezier sdf by iq\nfloat SDBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t)*t;\n        res = dot(qos,qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t.x)*t.x;\n        res = dot(qos,qos);\n        qos = d + (c + b*t.y)*t.y;\n        res = min(res,dot(qos,qos));\n        qos = d + (c + b*t.z)*t.z;\n        res = min(res,dot(qos,qos));\n    }\n    return sqrt( res );\n}\n\nfloat sdBezier(vec2 A, vec2 B, vec2 C, vec2 p){\n    float sd = 1e+8;\n    //sd = SDBezier(p, A, B, C);\n    sd = min(sd,max(min(length(p-B), min(length(p-A),length(p-C)))-0.05,0.0));\n    vec2 A2 = A - 2.0*B + C, A1 = B - A; \t// P = A2 t² + 2 A1 t + A\n    float t = -dot(A2,A1)/dot(A2,A2);\n    vec2 V = (A2*t+2.0*A1)*t+A;\n    sd = min(sd,max(length(p-V)-0.05,0.0));\n    return sd;\n}\n\n\n\nvoid mainImage(out vec4 Col, in vec2 Pos) {\n    vec2 p = S*(Pos-0.5*iResolution.xy)/length(iResolution.xy);\n    \n    float d = sdBezier(vec2(0,1), vec2(2.0*sin(2.0*iTime),0), vec2(0,-1), p);\n    vec3 col = color(d);\n    \n    Col = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tttSRH",
    "date": "1580425863",
    "viewed": 74,
    "name": "Fitting Arc using Bézier 2",
    "description": "Cubic version see there: [url]https://www.shadertoy.com/view/wly3WG[/url]\nThese fitting functions are used to convert ellipse arcs in an SVG path into uniform bezier curve, because I don't want to write hundreds of lines of code specifically for ellipses.",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "bezier",
     "circle",
     "arc",
     "fitting",
     "leastsquare"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/*\n\tFitting an unit arc using a quadratic bezier curve\n\tCubic version: https://www.shadertoy.com/view/wly3WG\n\n\tAs one can see, cubic fitting is much better than quadratic fitting.\n\n    Since rendering quadratic is much faster than cubic, fitting the arc/ellipse\n    using multiple quadratic bezier curves is still better. It's not easy to notice \n    the C0 continuety.\n\n*/\n\n#define PI 3.1415926\n#define _13 0.333333333\n#define cbrt(x) ((x)>0.?pow(x,_13):-pow(-(x),_13))\n\nstruct Bezier2{\n    vec2 A, B, C;\n};\n\n\n// ========================= Fitting Code =========================\n\n\n#if 0\n\n// along the tangent\nvoid fitArc(in float theta, out Bezier2 R) {\n    float c = cos(theta), s = sin(theta);\n    float k = theta==0.0 ? 0.0 : (1.0 - c) / s;\n    R.A = vec2(1.0, 0.0), R.B = vec2(1.0, k), R.C = vec2(c, s);\n}\n\n#else\n\n// least square, let the control point be k*(cos(θ/2),sin(θ/2))\nvoid fitArc(in float theta, out Bezier2 R) {\n    // derivative of error: error'=ax³+bx²+cx+d\n    // thanks https://www.integral-calculator.com/ for helping me integrate that disgusting function!\n    float alpha = 0.5 * theta;\n\tfloat s1 = sin(alpha), s2 = s1 * s1, s4 = s2 * s2, s6 = s4 * s2,\n\t\tc1 = cos(alpha), c2 = c1 * c1, c3 = c2 * c1, c4 = c3 * c1, c5 = c4 * c1, c6 = c4 * c2, c7 = c5 * c2;\n    float a = 32.*s4+64.*c2*s2+32.*c4,\n        b = (60.*c1*s4+(120.*c3+60.*c1)*s2+60.*c5+60.*c3) / a,\n        c = (20.*s6+(100.*c2-16.)*s4+(140.*c4+32.*c2-148.)*s2+60.*c6+48.*c4-108.*c2) / a,\n        d = (35.*c1*s6+(105.*c3-5.*c1)*s4+(105.*c5+10.*c3-131.*c1)*s2+35.*c7+15.*c5-111.*c3-91.*c1) / a;\n    // calculate the minima (zero derivative), solve a the cubic function\n\tfloat p = (c - b * b * _13) * _13, q = -0.5 * ((b*b / 13.5 - c * _13) * b + d);\n\ta = q * q + p * p * p;\n\tfloat k = a > 0.0 ? cbrt(q + sqrt(a)) + cbrt(q - sqrt(a)) - b * _13\n\t\t: 2.0 * pow(q*q - a, 0.5 * _13) * cos(atan(sqrt(-a), q) * _13) - b * _13;\n    // apply the solution of the equation to the control points\n    R.A = vec2(1.0, 0.0), R.B = k * vec2(c1, s1), R.C = vec2(c1*c1-s1*s1, 2.0*c1*s1);\n}\n\n#endif\n\n\n\n// ========================= Rendering Code =========================\n\n\n// quadratic bezier distance approximation by tayholliday: https://www.shadertoy.com/view/XsX3zf\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\nvec2 get_distance_vector(vec2 b0, vec2 b1, vec2 b2) {\n  float a=det(b0,b2), b=2.0*det(b1,b0), d=2.0*det(b2,b1);\n  float f=b*d-a*a;\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x);\n  vec2 pp=-f*gf/dot(gf,gf);\n  vec2 d0p=b0-pp;\n  float ap=det(d0p,d20), bp=2.0*det(d10,d0p);\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0);\n  return mix(mix(b0,b1,t),mix(b1,b2,t),t);\n}\nfloat sdBezier2(in Bezier2 R, in vec2 p) {\n  return length(get_distance_vector(R.A-p, R.B-p, R.C-p));\n}\n\nvoid mainImage(out vec4 col, in vec2 P) {\n    vec2 res = iResolution.xy;\n    vec2 p = 6.0*(P-0.5*res)/length(res);\n    float h = 0.2*length(res); \t// hardness of anti-aliasing\n\n    float ang = atan(p.y,p.x);\n    if (ang<0.0) ang += 2.0*PI;\n    float a = sin(0.6*iTime); a=1.8*PI*a*a;\n    int n = int(abs(a)/1.5) + 1;\n    float da = a / float(n);\n    if (iMouse.z>0.0){\n        vec2 d = iMouse.xy-0.5*iResolution.xy;\n        a = atan(d.y,d.x);\n    \tif (a<0.0) a += 2.0*PI;\n        n=1, da=a;\n    }\n\n    // axis\n    vec2 axis = clamp(h*(abs(p)-0.02),0.0,1.0);\n    float bk = min(axis.x,axis.y);\n    vec3 bkg = mix(vec3(0,0,1),vec3(1),bk);\n\n    // circle\n    float circ = clamp(h*(abs(length(p)-1.0)-0.02),0.0,1.0);\n    vec3 c = (ang<a)?vec3(1,0,0):vec3(0.7);\n    c = mix(c,bkg,circ);\n\n    // bezier curve\n    Bezier2 R;\n    fitArc(da, R);\n    if (ang<a){\n        float t = mod(ang,da);\n        vec2 q = length(p)*vec2(cos(t),sin(t));\n    \tfloat d = sdBezier2(R,q);\n    \tc = mix(vec3(0),c,clamp(h*(d-0.01),0.0,1.0));\n    }\n\n    // control points\n    float d = length(p-R.B)-0.04;\n    c = mix(vec3(1),c,clamp(h*d,0.0,1.0));\n    c = mix(vec3(0),c,clamp(h*(abs(d)-0.002),0.0,1.0));\n    d = min(length(p-R.A),length(p-R.C))-0.05;\n    c = mix(vec3(1),c,clamp(h*d,0.0,1.0));\n    c = mix(vec3(0),c,clamp(h*(abs(d)-0.005),0.0,1.0));\n\n    col = vec4(c, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ttcSRN",
    "date": "0",
    "viewed": 0,
    "name": "Sound Test 0x00000003",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 a = 0.1*calcSound(0.01*uv.x+iTime);\n    float w = a.x+a.y;\n    float c = 20.0*abs(w-uv.y+0.5);\n    vec3 col = vec3(smoothstep(0.5,0.0,c));\n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "float hash(float x){\n    return fract(sin(12.9898*x+12.87)*43758.5453)*2.0-1.0;\n}\n\nfloat noise(float x){\n    //return sin(x);\n    //return fract(x);\n    //return fract(x)<0.5?1.0:0.0;\n    //return tan(x);\n    return mix(hash(floor(x)),hash(ceil(x)),fract(x));\n}\n\nfloat fbm(float x){\n    float res = 0.0;\n    float a = 1.0;\n    float e = 1.0;\n    for (int k=0; k<10; k++){\n        res += a * noise(e*(x+hash(float(k))));\n        a *= 0.5, e *= 2.0;\n    }\n    return res;\n}\n\n\n#define freq(n) 440.0*exp2(((n)-49.0)/12.0)\n\n#define sinWave(f,t) sin(6.283185307*(f)*(t))\n#define triWave(f,t) (2.0*abs(2.0*fract(f*t-0.25)-1.0)-1.0)\n#define sqrWave(f,t) (fract((f)*(t))>0.5?-0.5:0.5)\n#define sthWave(f,t) (2.0*fract((f)*(t)-0.5)-1.0)\n\nvec2 calcSound(float time){\n    float k = fbm(100.0*time);\n    //if (fract(time)<0.5) k=0.0;\n    //k = sinWave(freq(mod(floor(10.0*time),72.0)+28.),fract(time));\n    return vec2(k);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec2 mainSound( in int samp,float time) {\n    return calcSound(time);\n}\n",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tltSWr",
    "date": "1580886017",
    "viewed": 249,
    "name": "I heart Fourier",
    "description": "As a beginner to Fourier series, inspired by a picture on my religion teacher's slide. ",
    "likes": 32,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "heart",
     "fourier",
     "love"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 path[18];\nvec2 a[10], b[10];  // 10 = int(18 / 2) + 1\nvoid init() {\n\t// manual point set\n\tpath[0] = vec2(1.0137, 0.3967);\n\tpath[1] = vec2(0.5626, 0.5417);\n\tpath[2] = vec2(0.3414, -0.0639);\n\tpath[3] = vec2(0.1158, 0.6121);\n\tpath[4] = vec2(-0.7459, 0.7070);\n\tpath[5] = vec2(-0.8443, 0.1465);\n\tpath[6] = vec2(-0.3618, 0.1444);\n\tpath[7] = vec2(-0.1585, 0.4285);\n\tpath[8] = vec2(-0.3173, 0.3743);\n\tpath[9] = vec2(-0.4706, -0.2456);\n\tpath[10] = vec2(-0.7936, -0.3968);\n\tpath[11] = vec2(-0.5655, -0.1589);\n\tpath[12] = vec2(0.2119, -0.6991);\n\tpath[13] = vec2(0.2968, -0.9548);\n\tpath[14] = vec2(0.3969, -0.4136);\n\tpath[15] = vec2(0.7119, 0.0779);\n\tpath[16] = vec2(0.6283, 0.2814);\n\tpath[17] = vec2(0.7057, -0.0209);\n\n\t// calculate Fourier coefficients, b[0] is always zero\n\tfloat t, dt;\n\tfor (int k = 0; k < 10; k++) {\n\t\ta[k] = vec2(0.), b[k] = vec2(0.);\n\t\tt = 0.0, dt = 6.283185 * float(k) / 18.;\n\t\tfor (int i = 0; i < 18; i++, t += dt)\n\t\t\ta[k] += path[i] * cos(t), b[k] += path[i] * sin(t);\n\t\ta[k] = a[k] * (2.0 / 18.), b[k] = b[k] * (2.0 / 18.);\n\t}\n\ta[0] = a[0] * 0.5;\n}\n\nvec2 eval(float t) {\n\tvec2 r = a[0];\n    float c0 = cos(t), s0 = sin(t), c = c0, s = s0, c1;\n    for (int k = 1; k < 10; k++) {\n        r += a[k] * c + b[k] * s;\n        c1 = c, c = c * c0 - s * s0, s = c1 * s0 + s * c0;\n    }\n\treturn r;\n}\n\n\n// an improvement of iq's https://www.shadertoy.com/view/Xlf3zl\nfloat sdSqSegment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tvec2 q = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn dot(q, q);\n}\nfloat sd(vec2 p) {\n\tfloat o = sin(0.5*iTime); o = .04 + .005*o*o;  // path offset\n\tfloat o2 = (o + .02)*(o + .02);\n\tfloat t_max = 6.3*min(1.5*fract(0.15*iTime), 1.0);\n\tvec2 a = eval(0.0), b, c;\n\tfloat dt = 0.05, t = dt;\n\tfloat d = 1e8, dd;\n\twhile (t < t_max) {\n\t\tb = eval(t);\n\t\tdd = sdSqSegment(p, a, b);\n\t\tif (dd < o2) {  // more accurate and doesn't reduce much speed\n\t\t\tc = eval(t - 0.5*dt);\n\t\t\tdd = min(sdSqSegment(p, a, c), sdSqSegment(p, c, b));\n\t\t}\n\t\td = min(d, dd);\n\t\tdt = clamp(0.026*length(a - p) / length(a - b), 0.02, 0.1);\n\t\tt += dt;\n\t\ta = b;\n\t}\n\td = min(d, sdSqSegment(p, a, eval(t_max))); \t// add this line to eliminate gaps\n\td = min(sqrt(d), abs(length(p) - 0.15));\n\treturn d - o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tinit();\n\tvec2 p = 5.0 * (fragCoord - 0.5*iResolution.xy) / length(iResolution.xy);\n\tfloat d = sd(p - vec2(-.1, .08));\n\n    // modified from iq's sdf visualizing function\n\tvec3 col = d > 0. ? vec3(1.0, 0.3, 0.5) : vec3(0.3, 1.5, 2.7);\n\tcol *= 1.0 - 0.9*exp(-6.*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.*d - 3.0*iTime);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.02, abs(d)));\n\tfragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WldSD4",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x00000012",
    "description": " smoothed boolean operations of sdf",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 Mouse;\n\nfloat smax(float a, float b, float k){\n    float d = a-b;\n    return abs(d)>k?max(a,b):.5*(.5/k*d*d+a+b+.5*k);\n}\nfloat smin(float a, float b, float k){\n    float d = a-b;\n    return abs(d)>k?min(a,b):.5*(-0.5/k*d*d+a+b-.5*k);\n}\nfloat ssub(float a, float b, float k){\n    float d = a+b;\n    return abs(d)>k?max(a,-b):.5*(.5/k*d*d+a-b+.5*k);\n}\n\nfloat sd(vec2 p){\n    float a = p.y;\n    float b = length(p-Mouse)-1.0;\n    return smin(a,b,0.5);\n}\n\n#define S 10.0\nvoid mainImage(out vec4 Col, in vec2 Pos) {\n    vec2 p = S * (Pos-0.5*iResolution.xy)/length(iResolution.xy);\n    Mouse = S * (iMouse.xy-0.5*iResolution.xy)/length(iResolution.xy);\n    float d = sd(p);\n    d /= S;\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-10.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(600.0*d);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(5.0*d)));\n    Col = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ttcSWM",
    "date": "1581034919",
    "viewed": 10,
    "name": "Web Camera",
    "description": "something I made for myself, since the camera app doesn't work properly.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sf3zn",
       "filepath": "/presets/webcam.png",
       "type": "webcam",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void mainImage(out vec4 c, in vec2 p){\n    c = texture(iChannel0,p/iResolution.xy);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tlcXDM",
    "date": "1581053690",
    "viewed": 42,
    "name": "Unnecessary Calculation",
    "description": "A new discovery made after a curious attempt - every time we calculate the distance to a quadratic bezier curve by solving a cubic equation, we made an unnecessary calculation.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "sdf",
     "bezier",
     "root"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/*\n\tA new discovery made after a curious attempt - every time we \n\tcalculate the distance to a quadratic bezier curve by \n\tsolving a cubic equation, we made an unnecessary calculation.\n\n\tThe usual way to solve cubic equation has 4 cases. Each case \n\tis represented in a different color - orange, purple, blue, \n\tand green. But in this demo, no matter how you choose three \n\tcontrol points, the green won't appear.\n\n\tI get this based on my observation without mathematical prove. \n\tIf you see green appear, please let me know.\n\n*/\n\nvec3 col;  // color as global variable\n\n#define PI 3.14159265\n#define _13 0.33333333\n#define PI_3 1.04719755\nfloat SDBezier2(vec2 A, vec2 B, vec2 C, in vec2 P) {\n\tvec2 C2 = A-2.0*B+C, C1 = 2.0*(B-A), C0 = A-P, E;\n\tfloat t = 0.5/dot(C2,C2),\n\t\ta = dot(C2,C1)*t, b = (2.0*dot(C2,C0)+dot(C1,C1))*t, c = dot(C1,C0)*t;\n\tfloat a2 = 9.0*a*a, p = (-a2*_13+b)*_13, q = 0.11111111*a*a2+0.5*(c-a*b),\n\t\tp3 = p*p*p, delta = q*q+p3;\n\tfloat sd, E2;\n\tif (delta>0.0) {  // one real root, show in orange\n\t\tdelta = sqrt(delta);\n\t\tt = (delta>q?pow(delta-q,_13):-pow(q-delta,_13))\n            -(delta+q>0.0?pow(delta+q,_13):-pow(-delta-q,_13));\n\t\tt = clamp(t-a,0.,1.);\n\t\tE = (C2*t+C1)*t+C0, sd = dot(E,E);\n\t\tcol = vec3(.9,.6,.2);\n\t}\n\telse {  // three real roots\n        t = sqrt(-p), q = _13*acos(q/(p*t)), p = 2.0*t;\n\t\t// the ever-existing real root, show in purple\n\t\tt = clamp(p*cos(q)-a,0.,1.);\n\t\tE = (C2*t+C1)*t+C0, sd = dot(E,E);\n\t\tcol = vec3(.8,.4,.6);\n\t\t// show in blue\n\t\tt = clamp(-p*cos(q-PI_3)-a,0.,1.);\n\t\tE = (C2*t+C1)*t+C0, E2 = dot(E,E);\n\t\tif (E2<sd) sd = E2, col = vec3(.3,.6,.9);\n\t\t// show in green, this color doesn't show up\n        // which means the following lines are unnecessary\n\t\tt = clamp(-p*cos(q+PI_3)-a,0.,1.);\n\t\tE = (C2*t+C1)*t+C0, E2 = dot(E,E);\n\t\tif (E2<sd) sd = E2, col = vec3(.4,.7,.6);\n\t}\n\treturn sqrt(sd);\n}\n\n\nfloat hash(float x){  // [-1,1)\n    return fract(sin(12.9898*x+12.87)*43758.5453)*2.0-1.0;\n}\nfloat noise(float x, float d){\n    return mix(hash(floor(x)+d),hash(ceil(x)+d),fract(x));\n}\nvoid mainImage(out vec4 Col, in vec2 Pos) {\n    float a = noise(iTime,0.5);\n    vec2 A = vec2(sin(a),cos(a))*noise(iTime,0.0);\n    a = noise(iTime,1.5);\n    vec2 B = vec2(sin(a),cos(a))*noise(iTime,1.0);\n    a = noise(iTime,2.5);\n    vec2 C = vec2(sin(a),cos(a))*noise(iTime,2.0);\n\n    vec2 p = 4.0*(Pos-0.5*iResolution.xy)/length(iResolution.xy);\n    float d = SDBezier2(A,B,C,p);\n\tcol *= 1.0-exp(-3.0*abs(d));\n\tcol *= 0.8+0.2*cos(150.0*d);\n\tcol = mix(col,vec3(1.0),1.0-smoothstep(0.0,0.02,abs(1.2*d)));\n    Col = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WtcSR2",
    "date": "1586479391",
    "viewed": 182,
    "name": "Triangled",
    "description": "Tangled + Triangulated. Diving down to Hell.\n\n(stay 1min and watch it change)",
    "likes": 7,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "tunnel",
     "sound",
     "sdf",
     "triangle",
     "hexagon",
     "square"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsX3Rn",
       "filepath": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4df3Rr",
       "filepath": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float smin(float a, float b, float k){\n    float d = a-b;\n    return abs(d)>k?min(a,b):.5*(-.5/k*d*d+a+b-.5*k);\n}\n\n#define _23 0.666666667\n#define rt3 1.732050808\n#define r3_2 0.866025404\n#define _23r3 1.154700538\n#define _43r3 2.309401077\n\n\nvec2 map4(vec2 p){\n    p = abs(mod(p,2.0)-1.0);\n    return vec2(min(p.x,p.y),length(p));\n}\nfloat Map4(vec3 p){\n    vec2 d = map4(p.xy);\n    return smin(length(vec2(d.x,p.z)),d.y,0.2)-0.1;\n}\n\n\nvec2 map3(vec2 p){\n\tp = mod(p+vec2(_23r3,_23),vec2(_43r3,4.));\n\tif (p.y>2.) p.y=4.-p.y;\n\tif (p.x>_23r3) p.x=_43r3-p.x;\n\tif (p.y>rt3*p.x) p=vec2(_23r3,2.)-p;\n\treturn vec2(rt3*p.y<p.x?p.y:.5*(rt3*p.x-p.y),\n\t\tp.x+rt3*p.y<_43r3?length(p):length(p-vec2(_23r3,2.)));\n}\nfloat Map3(vec3 p){\n    vec2 d = map3(p.xy);\n    return smin(length(vec2(d.x,p.z)),d.y,0.2)-0.1;\n}\n\n\nfloat map6g(vec2 p){\n    p = mod(vec2(p.x,.5*p.x+r3_2*p.y),3.);\n    if (p.y>p.x) p=p.yx;\n    if (p.x+p.y>3.) p=vec2(3)-p.yx;\n    return p.y>1.?p.x-p.y:p.x>2.?abs(p.x-p.y-2.):p.y>p.x-1.?abs(p.x-1.):p.y;\n}\nfloat map6v(vec2 p){\n    p = mod(p,vec2(1,rt3)*2.);\n    if (p.x>1.) p.x=2.-p.x;\n    if (p.y>rt3) p.y=2.*rt3-p.y;\n    if (p.y<rt3*p.x) p=vec2(1.,rt3)-p;\n    return length(p-vec2(0,_23r3));\n}\nfloat Map6(vec3 p){\n    return smin(length(vec2(map6g(p.xy),p.z)),map6v(p.xy),0.2)-0.1;\n}\n\n\nfloat map(vec3 p){\n    p.z = mod(p.z,2.0)-1.0;\n    const float o = 2.;\n    float t = iTime;\n    if (t<16.-o) return Map6(p);\n    if (t<16.) return mix(Map4(p),Map6(p),(16.-t)/o);\n    if (t<32.-o) return Map4(p);\n    if (t<32.) return mix(Map3(p),Map4(p),(32.-t)/o);\n    if (t<48.-o) return Map3(p);\n    if (t<48.) return mix(map3(p.xy).x-.1,Map3(p),(48.-t)/o);\n    if (t<60.-o) return map3(p.xy).x-.1;\n    if (t<60.) return mix(map3(p.xy).y,map3(p.xy).x,(60.-t)/o)-.1;\n    return map3(p.xy).y-.1;\n}\n\nvec3 grad(vec3 p){\n    const float e = .001;\n\tfloat a = map(vec3(p.x+e,p.y+e,p.z+e));\n\tfloat b = map(vec3(p.x+e,p.y-e,p.z-e));\n\tfloat c = map(vec3(p.x-e,p.y+e,p.z-e));\n\tfloat d = map(vec3(p.x-e,p.y-e,p.z+e));\n\treturn normalize(vec3(a+b-c-d,a-b+c-d,a-b-c+d));\n}\n\nbool intCirc(vec2 d, vec2 c, float r, inout float t, out vec2 n){\n    if (dot(c,d)<=0.0) return false;\n\tfloat d2 = c.x*d.y-c.y*d.x; if ((d2*=d2)>r*r) return false;\n\td2 = sqrt(dot(c,c)-d2)-sqrt(r*r-d2);\n    if (d2>t) return false; else t=d2;\n\tn = (d*t-c)/r; return true;\n}\n\nvec3 getTexture(sampler2D G, vec3 p, vec3 n){\n    return ((n=abs(n)).x*texture(G,p.yz)+n.y*texture(G,p.xz)+n.z*texture(G,p.xy)).rgb/(n.x+n.y+n.z);\n}\n\nvoid mainImage(out vec4 fcol, in vec2 coord){\n    float t = -2.0*iTime;\n    vec3 p = vec3(0,0,t+1.0);\n    vec2 uv = (coord - 0.5*iResolution.xy) / length(iResolution.xy);\n    vec3 d = normalize(vec3(uv,t)-p);\n    float dk = 1.0/length(d.xy); vec2 d0 = d.xy*dk;\n    \n    vec3 n, k;\n    t = 1e8;\n    float r = .05*max(1.-1e-7*pow(iTime,4.),.0);\n    if (intCirc(d0,vec2(-1.2*r,-0.25),r,t,n.xy)\n       ||intCirc(d0,vec2(1.2*r,-0.25),r,t,n.xy)) {\n        p += (t*=dk)*d;\n    \tk = mix(vec3(0.2),vec3(1.0),max(n.y,0.));\n    \tk *= 2.0*getTexture(iChannel1,2.0*p,n);\n    }\n    else {\n    \tt = 0.0; float dt;\n    \tfor (int i=0;i<64;i++){\n    \t    dt = map(p+t*d);\n    \t    t += dt;\n    \t    if (dt<.01 || t>40.) break;\n    \t    float a = 0.05*dt, c=cos(a),s=sin(a);\n    \t    d.xy = mat2(c,s,-s,c)*d.xy;\n    \t}\n    \tp += d*t;\n    \tn = grad(p);\n    \tk = mix(vec3(0.2),vec3(1.0),max(n.z,0.));\n    \tk *= 3.0*getTexture(iChannel0,p,n);\n    }\n    fcol.xyz = k*exp(-0.2*t*vec3(1.0,0.8,0.6));\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec2 mainSound( in int samp,float t){\n    float t0 = t;\n    float f = t>64.?392.:(t=mod(t,4.))<1.?523.:t<2.?415.:392.;\n    t = 6.283185307*mod(t,4.);\n    return vec2(sin(f*t)*max(cos(8.*t),0.)*min(exp(64.-t0),1.));\n}\n",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wtcXz2",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x00000014",
    "description": "grid436",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define _13 0.333333333\n#define _23 0.666666667\n#define _43 1.333333333\n#define rt3 1.732050808\n#define r3_2 0.866025404\n#define r3_3 0.577350269\n#define r3_4 0.433012702\n#define r3_6 0.288675135\n#define _23r3 1.154700538\n#define _43r3 2.309401077\n\n// map functions: return vec2(grid_distance, vertex_distance)\n\nvec2 map4(vec2 p){\n    p = abs(mod(p,2.0)-1.0);\n    return vec2(min(p.x,p.y),length(p));\n}\n\nfloat G3(vec2 p){\n    p = fract(vec2(r3_4*p.x-.25*p.y+_13,.5*p.y+_13));\n    if (p.x+p.y>1.) p=1.-p;\n    return 2.*min(min(p.x,p.y),1.-p.x-p.y);\n}\n\nfloat V3(vec2 p){\n\tp = mod(p+vec2(_23r3,_23),vec2(_43r3,4.));\n\tif (p.y>2.) p.y=4.-p.y;\n\tif (p.x>_23r3) p.x=_43r3-p.x;\n    if (p.x+rt3*p.y>_43r3) p=vec2(_23r3,2.)-p;\n    return length(p);\n}\n\nvec2 map3(vec2 p){\n    //return vec2(G3(p),V3(p));\n\tp = mod(p+vec2(_23r3,_23),vec2(_43r3,4.));\n\tif (p.y>2.) p.y=4.-p.y;\n\tif (p.x>_23r3) p.x=_43r3-p.x;\n\tif (p.y>rt3*p.x) p=vec2(_23r3,2.)-p;\n\treturn vec2(rt3*p.y<p.x?p.y:.5*(rt3*p.x - p.y),\n\t\tp.x+rt3*p.y<_43r3?length(p):length(p-vec2(_23r3,2.)));\n}\n\nfloat G6(vec2 p){\n    p = mod(vec2(p.x,.5*p.x+r3_2*p.y),3.0);\n    if (p.y>p.x) p=p.yx;\n    if (p.x+p.y>3.) p=vec2(3)-p.yx;\n    return p.y>1.?p.x-p.y:p.x>2.?abs(p.x-p.y-2.):p.y>p.x-1.?abs(p.x-1.):p.y;\n}\n\nfloat V6(vec2 p){\n    p = mod(p,vec2(1,rt3)*2.);\n    if (p.x>1.) p.x=2.-p.x;\n    if (p.y>rt3) p.y=2.*rt3-p.y;\n    if (p.y<rt3*p.x) p=vec2(1.,rt3)-p;\n    return length(p-vec2(0,_23r3));\n}\n\nvec2 map6(vec2 p){\n    return vec2(G6(p),V6(p));\n}\n\n\nfloat map(vec2 p){\n    vec2 d = map6(p);\n    return mix(d.x,d.y,clamp(cos(iTime)+0.5,0.0,1.0));\n}\n\nvec2 grad(vec2 p){\n    const float e = 0.01;\n    float dx = map(vec2(p.x+e,p.y))-map(vec2(p.x-e,p.y));\n    float dy = map(vec2(p.x,p.y+e))-map(vec2(p.x,p.y-e));\n    return vec2(dx,dy)/(2.0*e);\n}\n\n#define S 15.0\nvec3 calcCol(in vec2 pos){\n    vec2 p = S * (pos-0.5*iResolution.xy)/length(iResolution.xy);\n    float d = map(p) / S;\n\tvec3 col = d>0.0?vec3(.8,.7,.6):vec3(.2,.3,.4);\n\tcol *= 1.0 - exp(-20.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(600.0*d);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(5.0*d)));\n    col = clamp(col,0.0,1.0);\n    //return col;\n    float g = 1e0*(0.5*length(grad(p))-0.5);\n    return col + vec3(g,0.0,-g);\n}\n\n// just make it slow so I can find out which way is better\n// the number of evaluations in raymarching is around 8^2\n#define AA 8\nvoid mainImage(out vec4 Col, in vec2 Pos) {\n    Col.xyz = vec3(0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++)\n        Col.xyz += calcCol(Pos+vec2(i,j)/float(AA));\n    Col.xyz /= float(AA*AA);\n    //Col.xyz = mix(vec3(1.0),Col.xyz,0.4);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wlySDy",
    "date": "1583483570",
    "viewed": 51,
    "name": "Float Limit Exceed +=−=",
    "description": "On my machine (test on both CPU and GPU):\niTime < 30: procedural fBM effect\niTime > 30: wider and wider stripes\n",
    "likes": 2,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "bug",
     "floatpoint"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "/*\n    In C:\n    \n    \tfloat sum = 0.0f;\n    \tfor (int i = 1; i <= 10000000; i++) sum += 1.0f / (float)i;\n    \tfor (int i = 1; i <= 10000000; i++) sum -= 1.0f / (float)i;\n    \tprintf(\"%.16f\\n\", sum);\n    \n    Output:\n    \n    \t-1.2963572740554810\n*/\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float x = 0.0;\n    int m = int(fragCoord.x+60.0*iTime);\n    for (int i=1; i<=m; i++) x+=1.0/float(i);\n    for (int i=1; i<=m; i++) x-=1.0/float(i);\n    if (x==0.0) fragColor = vec4(0,0,1,1);\n    else x*=1e5, fragColor = x>0.0?vec4(x,0,x,1):vec4(0,x,x,1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wsfyzB",
    "date": "1585167026",
    "viewed": 135,
    "name": "Exponential Regression",
    "description": "Fitting the number of COVID-19 daily reported cases in four countries using regression. Click and drag to read the value.\n\nAny idea about how can I make the compilation faster?",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "leastsquare",
     "coronavirus",
     "covid"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzr",
       "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// COVID-19 daily reported cases since Mar.1\n// Data source: https://www.worldometers.info/coronavirus/\n#define N 26\nint US[N] = int[N](75,100,124,158,221,319,435,541,704,994,1301,1697,2247,2943,3680,4663,6411,9259,13789,19383,24207,33566,43734,54856,68211,85435);  // US\nint IT[N] = int[N](1701,2036,2502,3089,3858,4636,5883,7375,9172,10149,12462,15113,17660,21157,24747,27980,31506,35713,41035,47021,53578,59138,63927,69176,74386,80589);  // IT\nint ES[N] = int[N](84,120,165,228,282,401,525,674,1231,1695,2277,3146,5232,6391,7988,9942,11826,14769,18077,21571,25496,28768,35136,42058,49515,57786);  // ES\nint DE[N] = int[N](130,165,203,262,545,670,800,1040,1224,1565,1966,2745,3675,4599,5813,7272,9367,12327,15320,19848,22364,24873,29056,32991,37323,43938);  // DE\n//int FR[N] = int[N](130,191,212,285,423,653,949,1209,1412,1784,2281,2876,3661,4499,5423,6633,7730,9134,10995,12612,14459,16018,19856,22304,25233,29155);  // FR\n//int GB[N] = int[N](36,39,51,87,116,164,209,278,321,383,460,590,798,1140,1391,1543,1950,2626,3269,3983,5018,5683,6650,8077,9529,11658);  // UK\n\n\n\n/*================================ Fitting Code ================================*/\n\n// linear and quadratic regression\n#define LinearReg float m=1.0/(s*sx2-sx*sx); a=m*(s*sxy-sx*sy), b=m*(sx2*sy-sx*sxy);\n#define QuadReg float r0=sx2*s-sx*sx,r1=sx3*s-sx*sx2,r2=sx3*sx-sx2*sx2,r21=sx4*sx-sx2*sx3,m=1.0/(sx4*r0-sx3*r1+sx2*r2); a=(sx2y*r0-sxy*r1+sy*r2)*m, b=-(sx2y*r1-sxy*(sx4*s-sx2*sx2)+sy*r21)*m, c=(sx2y*r2-sxy*r21+sy*(sx4*sx2-sx3*sx3))*m;\n\n//#define Z min(0,iFrame)\n#define Z 0\n\n// Method 1: y = exp(ax+b), minimum Σ [ln(y)-(ax+b)]²\nvoid fitLinear(in int[N] Y, out float a, out float b){\n\tfloat s = float(N), sx = .5*s*(s-1.), sx2 = sx*(2.*s-1.)/3.,\n        sxy = 0., sy = 0.;\n\tfor (int i = Z; i < N; i++) {\n\t\tfloat y = log(float(Y[i]));\n\t\tsy += y, sxy += float(i)*y;\n\t}\n\tLinearReg\n}\n\n// Method 2: y = exp(ax+b), minimum Σ y·[ln(y)-(ax+b)]²\nvoid fitLinear_S(in int[N] Y, out float a, out float b){\n\tfloat s = 0., sx = 0., sx2 = 0., sxy = 0., sy = 0.;\n\tfor (int i = Z; i < N; i++) {\n\t\tfloat x = float(i), ey = float(Y[i]), y = log(ey);\n\t\tsx2 += x*x*ey, sx += x*ey, s += ey, sxy += x*y*ey, sy += y*ey;\n\t}\n\tLinearReg\n}\n\n// Method 3: y = exp(ax²+bx+c), minimum Σ [ln(y)-(ax²+bx+c)]²\nvoid fitQuadratic(in int[N] Y, out float a, out float b, out float c){\n\tfloat s=float(N), sx=.5*s*(s-1.), sx2=sx*(2.*s-1.)/3., sx3=sx*sx, sx4=.2*sx2*(s*(s-1.)*3.-1.),\n        sx2y = 0., sxy = 0., sy = 0.;\n\tfor (int i = Z; i < N; i++) {\n\t\tfloat x = float(i), y = log(float(Y[i]));\n\t\tsx2y += x*x*y, sxy += x*y, sy += y;\n\t}\n    QuadReg\n}\n\n// Method 4: y = exp(ax²+bx+c), minimum Σ y·[ln(y)-(ax²+bx+c)]²\nvoid fitQuadratic_S(in int[N] Y, out float a, out float b, out float c){\n\tfloat s = 0., sx = 0., sx2 = 0., sx3 = 0., sx4 = 0., sx2y = 0., sxy = 0., sy = 0.;\n\tfor (int i = Z; i < N; i++) {\n\t\tfloat x = float(i), e = float(Y[i]), y = log(e), x2 = x*x;\n\t\tsx4 += x2*x2*e, sx3 += x2*x*e, sx2 += x2*e, sx += x*e, s += e;\n\t\tsx2y += x2*y*e, sxy += x*y*e, sy += y*e;\n\t}\n    QuadReg\n}\n\n// Method 4 should work best, but I don't think it can\n// be used for prediction because quadratic functions don't converge\n\n\n\n/*================================ Visualizing Code ================================*/\n\n#define res iResolution.xy\n#define Clamp(x) clamp(x,0.,1.)\n#define length2(p) dot(p,p)\n#define S sqrt(res.x*res.y)\n\n#define W 30.\n#define H 100000.\n#define SW (W/res.x)\n#define SH (res.y/H)\n\nvoid drawData(in int[N] K, vec3 bcol, vec2 p, inout vec3 col){\n    float a, b, c;\n    float x = p.x*SW, y, dy, sd;\n    // linear regression for log\n    fitLinear(K, a, b);\n    y = exp(a*x+b)*SH, dy = a*SW*y;\n    sd = abs(y-p.y)/sqrt(dy*dy+1.0);\n    col = mix(col, bcol, 0.02*(1.-Clamp(sd-.010*S)));\n    // weighted linear regression for log\n    fitLinear_S(K, a, b);\n    y = exp(a*x+b)*SH, dy = a*SW*y;\n    sd = abs(y-p.y)/sqrt(dy*dy+1.0);\n    col = mix(col, mix(bcol,vec3(1.2),0.2), 0.2*(1.-Clamp(sd-.006*S)));\n    // quadratic regression for log\n    fitQuadratic(K, a, b, c);\n    y = exp((a*x+b)*x+c)*SH, dy = (2.*a*x+b)*SW*y;\n    sd = abs(y-p.y)/sqrt(dy*dy+1.0);\n    col = mix(col, bcol, 0.04*(1.-Clamp(sd-.008*S)));\n    // weighted quadratic regression for log\n    fitQuadratic_S(K, a, b, c);\n    y = exp((a*x+b)*x+c)*SH, dy = (2.*a*x+b)*SW*y;\n    sd = abs(y-p.y)/sqrt(dy*dy+1.0);\n    col = mix(col, mix(bcol,vec3(1.5),0.2), 0.8*(1.-Clamp(sd-.0045*S)));\n    // data points\n    sd = 1e8;\n    for (int i=0; i<N; i++){\n        vec2 q = vec2(i,K[i])*res/vec2(W,H);\n        sd = min(sd,length2(p-q));\n    }\n    col = mix(bcol, col, Clamp(sqrt(sd)-.008*S));\n}\n\n// distance to fitted curve\nfloat dist(in int[N] K, vec2 p) {\n    float a,b,c; fitQuadratic_S(K,a,b,c);\n    float x=p.x*SW, y=exp((a*x+b)*x+c)*SH, dy=(2.*a*x+b)*SW*y;\n    return y>res.y?res.y:abs(y-p.y)/sqrt(dy*dy+1.0);\n}\n\n#define _(c) T+=u.x<.0||u.x>1.||u.y<0.||u.y>1.?vec4(0):textureGrad(iChannel0,u/16.+fract(vec2(c,15-(c)/16)/16.),dFdx(u/16.),dFdy(u/16.));u.x-=.5;\nfloat text(vec2 p, int d, int n) {\n    vec4 T = vec4(0);\n    vec2 u = p-vec2(0,.5); _(77)_(97)_(114)_(46)_(d/10+48)_(d%10+48);\n    u = p+vec2(0,.5); _(n/10000+48)_(46)_(n/1000%10+48)_(n/100%10+48)_(107)_(32);\n    return T.w==0.?-1.:T.x;\n}\n\n#define pad 0.1\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec2 p = (1.0+2.*pad)*(coord-0.5*res);\n    vec3 col = max(abs(p.x)-.5*res.x,abs(p.y)-.5*res.y)>0. ? vec3(0.9) : vec3(1.0);\n    p+=0.5*res;\n    if (iMouse.z>0.) {\n        // initial and current mouse position\n        vec2 mp = (1.+2.*pad)*iMouse.zw-pad*res;\n        vec2 ms = (1.+2.*pad)*iMouse.xy-pad*res;\n        // find the curve that is closest to the initial mouse position\n        int K[N]; float d, md=1e9;\n        if ((d=dist(US,mp))<md){md=d; K=US;}\n        if ((d=dist(IT,mp))<md){md=d; K=IT;}\n        if ((d=dist(ES,mp))<md){md=d; K=ES;}\n        if ((d=dist(DE,mp))<md){md=d; K=DE;}\n        // visualize that curve\n        drawData(K,vec3(1,.5,0),p,col);  // fitting curve\n        col = mix(vec3(1,0,1),col,Clamp(abs(ms.x-p.x)-0.0005*S));  // vertical line\n        float a,b,c; fitQuadratic_S(K,a,b,c);  // curve params\n        vec2 I; I.x=ms.x, I.y=exp((a*SW*I.x+b)*I.x*SW+c)*SH;  // value point\n        col = mix(vec3(1,0,0),col,Clamp(length(I-p)-0.01*S));  // render value point\n        if (I.x>0.&&I.x<res.x&&I.y>0.&&I.y<res.y){  // render text\n            vec2 T = I-vec2(-5,10);\n            float c = text(25.*(p-I)/S+vec2(-.3,.2), int(W*I.x/res.x)+1, int(I.y/SH));\n            if (c>=0.) col = mix(mix(col,vec3(.8),0.7),vec3(0),c);\n        }\n    }\n    else {\n    \tdrawData(DE,vec3(.84,.0,.0),p,col);\n    \tdrawData(ES,vec3(.78,.37,.0),p,col);\n    \tdrawData(IT,vec3(.0,.55,.25),p,col);\n    \tdrawData(US,vec3(.25,.25,.4),p,col);\n    }\n    color = vec4(col,1.0);\n}\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wsXyRs",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x00000015",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define res iResolution.xy\n\nfloat map(vec2 p){\n    //return sqrt(length(p*p))-1.0;\n    return max(abs(p.x),abs(p.y))-1.0;\n    return length(p)-1.0;\n}\nvec2 gradient(vec2 p){\n    const float e = 0.01;\n    float dx = map(p+vec2(e,0))-map(p-vec2(e,0));\n    float dy = map(p+vec2(0,e))-map(p-vec2(0,e));\n    return normalize(vec2(dx,dy));\n}\n\nvec3 counter(float d){\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-10.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(600.0*d);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(4.*d)));\n    return col;\n}\n\n#define dps 1.0\n#define sz 0.5\n#define ang (6.28*iMouse.x/res.x)\n#define alt tan(1.5*iMouse.y/res.y)\n#define light normalize(vec3(cos(ang),sin(ang),alt))\nfloat innerbevel(float d, vec2 grad){\n    d/=-sz;\n    if (d>0.&&d<1.){\n        vec3 n = normalize(vec3(grad*dps,1.));\n        return dot(light,n);\n    }\n    else return light.z;\n}\n\n#define SC 0.15\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec2 p = (coord-0.5*res)/(length(res)*SC);\n\tfloat d = map(p);\n    //vec2 grad = normalize(vec2(dFdx(d),dFdy(d)));\n    vec2 grad = gradient(p);\n    vec3 col = counter(d*SC);\n    col = vec3(innerbevel(d,grad));\n\tcolor = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tsXczs",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x00000016",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define res iResolution.xy\n\nfloat map(vec2 p){\n    return Map(p);\n    return sd2Segment(vec2(-1,-1),vec2(1,1),p);\n    return sd2Bezier2(vec2(-1,0),vec2(0,1),vec2(1,0),p);\n}\nvec3 counter(float d){\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-10.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(600.0*d);\n\tcol = mix(col, vec3(1.0), 1.0-smoothstep(0.0,0.02,abs(4.*d)));\n    return col;\n}\n\n#define SC 0.15\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec2 p = (coord-0.5*res)/(length(res)*SC);\n\tfloat d = map(p);\n    vec3 col = counter(d*SC);\n\tcolor = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define PI 3.14159265\n#define _13 0.33333333\n#define PI_3 1.04719755\nfloat sd2Bezier2(vec2 A, vec2 B, vec2 C, in vec2 P) {\n\tvec2 C2 = A-2.0*B+C, C1 = 2.0*(B-A), C0 = A-P, E;\n\tfloat t = 0.5/dot(C2,C2),\n\t\ta = dot(C2,C1)*t, b = (2.0*dot(C2,C0)+dot(C1,C1))*t, c = dot(C1,C0)*t;\n\tfloat a2 = 9.0*a*a, p = (-a2*_13+b)*_13, q = (1./9.)*a*a2+0.5*(c-a*b),\n\t\tp3 = p*p*p, delta = q*q+p3;\n\tfloat sd, E2;\n\tif (delta>0.0) {\n\t\tdelta = sqrt(delta);\n\t\tt = (delta>q?pow(delta-q,_13):-pow(q-delta,_13))\n            -(delta+q>0.0?pow(delta+q,_13):-pow(-delta-q,_13));\n\t\tt = clamp(t-a,0.,1.);\n\t\tE = (C2*t+C1)*t+C0, sd = dot(E,E);\n\t}\n\telse {\n        t = sqrt(-p), q = _13*acos(q/(p*t)), p = 2.0*t;\n\t\tt = clamp(p*cos(q)-a,0.,1.);\n\t\tE = (C2*t+C1)*t+C0, sd = dot(E,E);\n\t\tt = clamp(-p*cos(q-PI_3)-a,0.,1.);\n\t\tE = (C2*t+C1)*t+C0, E2 = dot(E,E);\n\t\tif (E2<sd) sd = E2;\n\t}\n\treturn sd;\n}\nfloat sd2Segment(vec2 a, vec2 b, vec2 p) {\n\tvec2 pa = p-a, ba = b-a;\n\tvec2 q = pa - ba*clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n\treturn dot(q,q);\n}\n\n#define M(x,y) _=vec2(x,y);\n#define L(x,y) d=min(d,sd2Segment(_,vec2(x,y),p)),_=vec2(x,y);\n#define Q(x1,y1,x2,y2) d=min(d,sd2Bezier2(_,vec2(x1,y1),vec2(x2,y2),p)),_=vec2(x2,y2);\nfloat Map(vec2 p){\n    vec2 _; float d=1e12;\n    M(-1.75,-0.282) Q(-1.81,-0.282,-1.86,-0.259) Q(-1.91,-0.235,-1.94,-0.192) Q(-1.97,-0.149,-1.97,-0.0926) Q(-1.97,-0.0449,-1.95,-0.00549) Q(-1.93,0.0339,-1.89,0.057) Q(-1.86,0.0805,-1.82,0.0805) Q(-1.78,0.0805,-1.75,0.0593) Q(-1.72,0.0385,-1.71,-0.0237) Q(-1.77,-0.0237,-1.8,-0.0449) Q(-1.82,-0.0657,-1.82,-0.102) Q(-1.82,-0.136,-1.8,-0.155) Q(-1.78,-0.174,-1.75,-0.174) Q(-1.71,-0.174,-1.68,-0.146) Q(-1.65,-0.117,-1.65,-0.0733) Q(-1.65,-0.0335,-1.67,0.00398) Q(-1.7,0.0419,-1.75,0.0987) Q(-1.8,0.16,-1.83,0.206) Q(-1.86,0.253,-1.86,0.31) Q(-1.86,0.367,-1.83,0.412) Q(-1.79,0.457,-1.74,0.482) Q(-1.69,0.507,-1.62,0.507) Q(-1.53,0.507,-1.48,0.465) Q(-1.43,0.423,-1.43,0.351) Q(-1.43,0.304,-1.45,0.272) Q(-1.48,0.24,-1.52,0.24) Q(-1.57,0.24,-1.61,0.295) Q(-1.58,0.317,-1.57,0.335) Q(-1.56,0.353,-1.56,0.373) Q(-1.56,0.396,-1.57,0.408) Q(-1.59,0.421,-1.61,0.421) Q(-1.64,0.421,-1.66,0.399) Q(-1.68,0.378,-1.68,0.343) Q(-1.68,0.31,-1.66,0.28) Q(-1.64,0.249,-1.59,0.198) Q(-1.55,0.156,-1.53,0.124) Q(-1.5,0.093,-1.48,0.0506) Q(-1.46,0.00852,-1.46,-0.0411) Q(-1.46,-0.109,-1.5,-0.165) Q(-1.54,-0.22,-1.6,-0.251) Q(-1.67,-0.282,-1.75,-0.282) \n    M(-1.08,-0.271) Q(-1.15,-0.271,-1.18,-0.233) Q(-1.22,-0.195,-1.22,-0.141) Q(-1.22,-0.119,-1.21,-0.0922) Q(-1.21,-0.0653,-1.2,-0.0407) Q(-1.19,-0.0161,-1.19,-0.00928) Q(-1.18,0.0241,-1.18,0.0559) Q(-1.17,0.0877,-1.17,0.106) Q(-1.17,0.135,-1.19,0.135) Q(-1.2,0.135,-1.22,0.116) Q(-1.23,0.0968,-1.24,0.0616) L(-1.31,-0.265) L(-1.49,-0.265) L(-1.34,0.433) L(-1.16,0.458) L(-1.2,0.257) Q(-1.2,0.264,-1.12,0.264) Q(-1.06,0.264,-1.03,0.231) Q(-0.995,0.198,-0.995,0.134) Q(-0.995,0.104,-1,0.0684) Q(-1.01,0.0328,-1.02,-0.0172) Q(-1.03,-0.0468,-1.04,-0.0744) Q(-1.04,-0.102,-1.04,-0.116) Q(-1.04,-0.128,-1.04,-0.132) Q(-1.03,-0.137,-1.02,-0.137) Q(-1,-0.137,-0.989,-0.121) Q(-0.976,-0.104,-0.955,-0.0513) L(-0.872,-0.0513) Q(-0.919,-0.19,-0.971,-0.231) Q(-1.02,-0.271,-1.08,-0.271) \n    M(-0.825,-0.271) Q(-0.888,-0.271,-0.931,-0.227) Q(-0.974,-0.184,-0.974,-0.0945) Q(-0.974,-0.0195,-0.944,0.0635) Q(-0.914,0.147,-0.852,0.206) Q(-0.791,0.265,-0.704,0.265) Q(-0.658,0.265,-0.632,0.246) Q(-0.606,0.228,-0.606,0.195) L(-0.626,0.188) L(-0.632,0.26) L(-0.451,0.26) L(-0.526,-0.0941) Q(-0.529,-0.107,-0.529,-0.121) Q(-0.529,-0.142,-0.51,-0.142) Q(-0.492,-0.142,-0.477,-0.123) Q(-0.461,-0.102,-0.446,-0.0513) L(-0.362,-0.0513) Q(-0.409,-0.188,-0.468,-0.23) Q(-0.526,-0.271,-0.585,-0.271) Q(-0.634,-0.271,-0.665,-0.243) Q(-0.695,-0.215,-0.692,-0.207) Q(-0.694,-0.216,-0.732,-0.243) Q(-0.771,-0.271,-0.825,-0.271) \n    M(-0.762,-0.137) Q(-0.745,-0.137,-0.727,-0.119) Q(-0.708,-0.101,-0.701,-0.0672) L(-0.655,0.15) Q(-0.655,0.153,-0.659,0.159) Q(-0.664,0.165,-0.674,0.165) Q(-0.702,0.165,-0.73,0.125) Q(-0.757,0.0858,-0.773,0.0252) Q(-0.79,-0.035,-0.79,-0.0809) Q(-0.79,-0.121,-0.782,-0.129) Q(-0.774,-0.137,-0.762,-0.137) \n    M(-0.315,-0.271) Q(-0.378,-0.271,-0.421,-0.227) Q(-0.464,-0.184,-0.464,-0.0945) Q(-0.464,-0.0195,-0.434,0.0635) Q(-0.404,0.147,-0.342,0.206) Q(-0.281,0.265,-0.194,0.265) Q(-0.148,0.265,-0.122,0.246) Q(-0.0957,0.228,-0.0957,0.195) L(-0.116,0.191) L(-0.0851,0.433) L(0.101,0.458) L(-0.0166,-0.0941) Q(-0.02,-0.107,-0.02,-0.121) Q(-0.02,-0.131,-0.0173,-0.134) Q(-0.0143,-0.137,-0.000265,-0.137) Q(0.0175,-0.137,0.0331,-0.118) Q(0.0486,-0.1,0.0634,-0.0513) L(0.147,-0.0513) Q(0.074,-0.265,-0.076,-0.265) Q(-0.123,-0.265,-0.154,-0.239) Q(-0.184,-0.212,-0.181,-0.204) Q(-0.181,-0.214,-0.221,-0.243) Q(-0.261,-0.271,-0.315,-0.271) \n    M(-0.251,-0.137) Q(-0.236,-0.137,-0.218,-0.12) Q(-0.199,-0.103,-0.192,-0.0741) L(-0.192,-0.0691) L(-0.145,0.15) Q(-0.149,0.165,-0.164,0.165) Q(-0.192,0.165,-0.22,0.125) Q(-0.246,0.0858,-0.263,0.0252) Q(-0.28,-0.035,-0.28,-0.0809) Q(-0.28,-0.121,-0.272,-0.129) Q(-0.264,-0.137,-0.251,-0.137) \n    M(0.217,-0.271) Q(0.137,-0.271,0.0914,-0.228) Q(0.0456,-0.185,0.0456,-0.0964) Q(0.0456,-0.0267,0.0728,0.0578) Q(0.101,0.142,0.164,0.206) Q(0.228,0.269,0.327,0.269) Q(0.454,0.269,0.454,0.156) Q(0.454,0.0953,0.42,0.0449) Q(0.386,-0.00549,0.33,-0.0354) Q(0.275,-0.065,0.23,-0.068) Q(0.229,-0.079,0.229,-0.0877) Q(0.229,-0.127,0.24,-0.138) Q(0.251,-0.149,0.279,-0.149) Q(0.325,-0.149,0.359,-0.127) Q(0.393,-0.105,0.442,-0.0513) L(0.519,-0.0513) Q(0.387,-0.271,0.217,-0.271) \n    M(0.243,0.0188) Q(0.248,0.0191,0.276,0.0392) Q(0.304,0.0597,0.321,0.0911) Q(0.339,0.123,0.339,0.157) Q(0.339,0.177,0.335,0.177) Q(0.312,0.177,0.282,0.123) Q(0.253,0.0684,0.243,0.0188) \n    M(0.5,0.26) L(0.681,0.26) L(0.667,0.22) Q(0.665,0.225,0.695,0.243) Q(0.724,0.26,0.761,0.26) Q(0.801,0.26,0.824,0.232) Q(0.848,0.204,0.848,0.167) Q(0.848,0.132,0.824,0.104) Q(0.8,0.0763,0.758,0.0763) Q(0.726,0.0763,0.715,0.0926) Q(0.703,0.109,0.699,0.132) Q(0.696,0.142,0.699,0.145) Q(0.702,0.148,0.702,0.14) Q(0.687,0.14,0.676,0.134) Q(0.665,0.128,0.649,0.113) L(0.569,-0.265) L(0.389,-0.265) L(0.5,0.26) \n    M(0.911,-0.271) Q(0.856,-0.271,0.822,-0.236) Q(0.788,-0.201,0.788,-0.134) Q(0.788,-0.108,0.795,-0.0672) L(0.849,0.181) L(0.817,0.181) L(0.833,0.26) L(0.865,0.26) L(0.894,0.392) L(1.08,0.417) L(1.05,0.26) L(1.1,0.26) L(1.09,0.181) L(1.03,0.181) L(0.97,-0.0941) Q(0.967,-0.107,0.967,-0.121) Q(0.967,-0.131,0.97,-0.134) Q(0.973,-0.137,0.987,-0.137) Q(1.01,-0.137,1.03,-0.118) Q(1.05,-0.0987,1.06,-0.0513) L(1.14,-0.0513) Q(1.1,-0.189,1.03,-0.23) Q(0.972,-0.271,0.911,-0.271) \n    M(1.22,-0.269) Q(1.14,-0.269,1.09,-0.227) Q(1.04,-0.184,1.04,-0.0957) Q(1.04,-0.0263,1.07,0.0578) Q(1.1,0.142,1.16,0.206) Q(1.23,0.269,1.33,0.269) Q(1.47,0.269,1.47,0.0934) L(1.45,0.0934) Q(1.46,0.11,1.46,0.112) Q(1.49,0.112,1.53,0.127) Q(1.57,0.143,1.62,0.182) L(1.64,0.119) Q(1.6,0.0767,1.55,0.0544) Q(1.51,0.0324,1.47,0.0256) Q(1.46,-0.0506,1.43,-0.121) Q(1.39,-0.19,1.34,-0.23) Q(1.28,-0.269,1.22,-0.269) \n    M(1.25,-0.141) Q(1.27,-0.141,1.29,-0.12) Q(1.31,-0.0975,1.32,-0.0544) Q(1.34,-0.0112,1.34,0.0248) Q(1.32,0.0297,1.32,0.0809) Q(1.32,0.134,1.35,0.146) Q(1.35,0.159,1.35,0.164) Q(1.34,0.17,1.33,0.17) Q(1.31,0.17,1.29,0.129) Q(1.26,0.0881,1.24,0.0259) Q(1.23,-0.0362,1.23,-0.0828) Q(1.23,-0.123,1.23,-0.132) Q(1.24,-0.141,1.25,-0.141) \n    M(1.65,-0.507) Q(1.6,-0.507,1.56,-0.472) Q(1.52,-0.437,1.52,-0.383) Q(1.52,-0.333,1.54,-0.301) Q(1.57,-0.27,1.6,-0.253) Q(1.64,-0.236,1.69,-0.221) L(1.69,-0.235) Q(1.67,-0.271,1.6,-0.271) Q(1.54,-0.271,1.51,-0.236) Q(1.47,-0.201,1.47,-0.134) Q(1.47,-0.108,1.48,-0.0672) L(1.55,0.26) L(1.73,0.26) L(1.66,-0.0938) Q(1.65,-0.104,1.65,-0.114) Q(1.65,-0.137,1.66,-0.137) Q(1.68,-0.137,1.69,-0.119) Q(1.71,-0.101,1.72,-0.0665) L(1.79,0.26) L(1.97,0.26) L(1.85,-0.327) Q(1.83,-0.427,1.77,-0.467) Q(1.72,-0.507,1.65,-0.507) \n    M(1.63,-0.381) Q(1.64,-0.381,1.65,-0.368) Q(1.66,-0.356,1.67,-0.321) L(1.67,-0.298) Q(1.66,-0.304,1.63,-0.323) Q(1.61,-0.342,1.61,-0.369) Q(1.61,-0.371,1.62,-0.376) Q(1.62,-0.381,1.63,-0.381)\n    return sqrt(d);\n}\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ws2yz1",
    "date": "1586141443",
    "viewed": 74,
    "name": "COVID, Stop!",
    "description": "Today's Google Doodle: Stay Home. Save Lives: Help Stop Coronavirus.\n\n(of course, you don't your home to have virus.)\n",
    "likes": 1,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "virus",
     "coronavirus",
     "covid19",
     "covid"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Shadertoy version of https://www.desmos.com/calculator/59x14hqpt3\n// I made this because that one is too slow\n\n#define res iResolution.xy\n#define t (1.2*iTime)\n#define PI 3.14159265358979\n\n#define cp(x) clamp(x,0.,1.)\n#define ss(x) (x)*(x)*(x)*((6.*(x)-15.)*(x)+10.)\n\nfloat smin(float a, float b, float k){\n    float d = a-b;\n    return abs(d)>k?min(a,b):.5*(-0.5/k*d*d+a+b-.5*k);\n}\n\n\n// Virus Modeling\n\n#define R 0.74\n#define r 0.25\n#define n 8.\n#define df 0.058\n#define ff 14.4\n#define rc 1.06\nfloat u(vec2 p){ return length(vec2(rc*(p.x+df*cos(ff*p.y)-(R+r)),p.y))-r; }\n\n#define sm 0.156\nfloat V(vec2 p, float td, inout vec3 col){\n    float a = mod(atan(p.y,p.x)-td, 2.*PI/n)-PI/n;\n    vec2 q = length(p)*vec2(cos(a),sin(a));\n    float d = smin(u(q),length(p)-R,sm);\n    if (d<0.) col-=sqrt(dot(p,p)+.1)*vec3(0,1,1);\n    return d;\n}\n\n\n// Virus Crowd\n\n#define P1 vec2(-0.82,-0.35)\n#define v1 -0.5\n#define s1 0.85\n#define m1 0.095\n#define f1 3.\n#define P2 vec2(0.81,0.54)\n#define to 2.56\n#define v2 0.625\n#define s2 0.58\n#define m2 0.044\n#define f2 4.\n\nfloat Vs(vec2 p, inout vec3 col){\n    vec3 c1; float d1 = V((p-P1)/s1+vec2(0,m1*sin(f1*t)),v1*t,c1);\n    vec3 c2; float d2 = V((p-P2)/s2+vec2(0,m2*sin(f2*(t+to))),v2*(t+to),c2);\n    col += c1 + c2;\n    return min(d1,d2);\n}\n\n\n// Liquid\n\n#define wf 6.77\n#define wm 0.14\n#define wv 5.\n#define whf 0.15\nfloat whfs(float x) { return x<0.5?0.:x<1.5?ss(x-0.5):x<2.?1.:1.-ss(x-2.); }\n\nfloat W(float x, float y, inout vec3 col){\n    float wh = 4.*whfs(mod(whf*t,3.))-2.5;\n    float d = y-(wm*exp(sin(wf*x+wv*t))+wh);\n    if (d<0.) col-=(1.-exp(y-wh-3.*wm))*vec3(1,.8,0);\n    return d;\n}\n\n\n// Main\n\nfloat scene(vec2 p, inout vec3 col){\n    float clip = max(abs(p.x)-3.,abs(p.y)-2.);\n    float sd = smin(Vs(p,col),W(p.x,p.y,col),0.1);\n    if (clip>0.) col=vec3(1.);\n    return max(clip,sd);\n}\n\nfloat house(vec2 p){\n    vec2 b = abs(p);\n    float u = max(b.x-3.,b.y-2.);\n    float v = min(p.y+2.,min(3.-b.x,(7.-2.*p.y-b.x)/sqrt(5.)));\n    return min(abs(u),abs(v));\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    col.xyz = vec3(1.0);\n    float S = min(res.x,res.y);\n    vec2 p = 7.0*(coord-0.5*res)/S-vec2(0,-.5);\n    float ds = scene(p,col.xyz);\n    float d = abs(ds)/length(vec2(dFdx(ds),dFdy(ds))) - .001*S;\n    col.xyz *= cp(d)*cp(house(p)*.14*S-.001*S);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3s2yWD",
    "date": "0",
    "viewed": 0,
    "name": "Wireframe 2.5D",
    "description": "Projecting 3D implicit surface to 2D implicit curve.\nBased on a Desmos graph: https://www.desmos.com/calculator/fa7mwvpxb3",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "projection",
     "implicit",
     "matrix"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define res iResolution.xy\n\n#define z0 -0.9\n#define z1 1.2\n#define Dz 8.\n#define x0 -1.1\n#define x1 1.1\n#define Dx 10.\n#define y0 -0.75\n#define y1 0.75\n#define Dy 12.\n\nfloat map(vec3 p){\n    vec3 u = vec3(p.x,1.5*p.y,p.z);\n    float a = dot(u,u)-1.;\n    vec2 v = vec2(p.x,.3354*p.y);\n    float b = dot(v,v);\n    return a*a*a-b*p.z*p.z*p.z;\n    return length(p)-1.0;\n}\n\nfloat imp(vec2 p){\n    float rx = .5*sin(iTime);\n    float rz = iTime;\n    if (iMouse.w>0.){\n        rx=3.*(iMouse.y/res.y-.5);\n        rz=6.283*iMouse.x/res.x;\n    }\n    mat2 I = mat2(1./cos(rz),tan(rx)*tan(rz),0,1./cos(rx));\n    mat2 J = mat2(-1./sin(rz),-tan(rx)/tan(rz),0,1./cos(rx));\n    mat2 K = mat2(-sin(rz),cos(rz),-cos(rz)/sin(rx),-sin(rz)/sin(rx));\n    vec2 A1 = vec2(-sin(rz),-cos(rz)*sin(rx));\n    vec2 A2 = vec2(cos(rz),-sin(rz)*sin(rx));\n    vec2 A3 = vec2(0,cos(rx));\n    float r = 1e8;\n    vec3 c;\n    for (float n=0.;n<Dx;n++){\n        c.x = x0+n/Dx*(x1-x0);\n        c.yz = I*(p-c.x*A1);\n        r=min(r,Dx*abs(map(c)));\n    }\n    for (float n=0.;n<Dy;n++){\n        c.y = y0+n/Dy*(y1-y0);\n        c.xz = J*(p-c.y*A2);\n        r=min(r,Dy*abs(map(c)));\n    }\n    for (float n=0.;n<Dz;n++){\n        c.z = z0+n/Dz*(z1-z0);\n        c.xy = K*(p-c.z*A3);\n        r=min(r,Dz*abs(map(c)));\n    }\n    return r;\n}\n\nvec2 grad(vec2 p){\n    const float e = .0001;\n    float dx = imp(p+vec2(e,0))-imp(p-vec2(e,0));\n    float dy = imp(p+vec2(0,e))-imp(p-vec2(0,e));\n    return vec2(dx,dy)*(.5/e);\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    float s = .2*sqrt(res.x*res.y);\n    vec2 p = (coord-0.5*res)/s;\n    float v = imp(p);\n    //float d = v/length(vec2(dFdx(v),dFdy(v)));\n    float d = s*v/length(grad(p));\n    float c = abs(d)-.01*s;\n    color = vec4(c,c,c,1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ws2yzG",
    "date": "1586887130",
    "viewed": 2,
    "name": "﻿Cross-Platform Test",
    "description": "This shader is used to test shaders on different hardware and operating system.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "nan"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define mainImage(c,p) \\\n\tc.xy = 4.*p-iResolution.xy; \\\n\tc = sin(dot(c,c)-abs(c.x)*c.y+iTime+vec4(3,2,0,0))",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3dBcR3",
    "date": "1587029897",
    "viewed": 64,
    "name": "sdLine Continuity",
    "description": "Use a power higher than 2 to increase the continuity of line segment primitive for modeling",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "sdf",
     "smooth",
     "g2"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Time measured with Shadertoy unofficial plugin by Patu\n\n// 1.00ms\nfloat sdLine(vec3 p, vec3 a, vec3 b){\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*h);\n}\n\n// 1.15ms\nfloat sdLine4(vec3 p, vec3 a, vec3 b){\n    vec3 pa = p-a, ba = b-a;\n    float h = dot(pa,ba)/dot(ba,ba);\n    pa -= ba*h;\n    h = max(abs(h-.5)-.5,0.);\n    return sqrt(length(vec2(dot(pa,pa),h*h*dot(ba,ba))));\n}\n\n// 1.25ms\nfloat sdLine3(vec3 p, vec3 a, vec3 b){\n    vec3 pa = p-a, ba = b-a;\n    float h = dot(pa,ba)/dot(ba,ba);\n    float u = length(pa-ba*h), v = max(abs(h-.5)-.5,0.)*length(ba);\n    return pow(u*u*u+v*v*v,1./3.);\n}\n\n// 1.5ms-1.6ms\nfloat sdLineN(vec3 p, vec3 a, vec3 b, float n){\n    vec3 pa = p-a, ba = b-a;\n    float h = dot(pa,ba)/dot(ba,ba);\n    float u = length(pa-ba*h), v = max(abs(h-.5)-.5,0.)*length(ba);\n    return pow(pow(u,n)+pow(v,n),1./n);\n}\n// n=2:    G1\n// 2<n<3:  G2 with divergent 3rd derivative, looks like G1\n// n=3:    G2, looks like G2\n// 3<n<4:  G3 with divergent 4th derivative\n// n≥4:    G3+\n\n\n\nvec3 a, b;\nfloat map(vec3 p){\n    return sdLineN(p,a,b,3.-cos(iTime))-1.0;\n}\nvec3 grad(vec3 p){\n    const float e = .001;\n\tfloat a = map(p+vec3(e,e,e));\n\tfloat b = map(p+vec3(e,-e,-e));\n\tfloat c = map(p+vec3(-e,e,-e));\n\tfloat d = map(p+vec3(-e,-e,e));\n\treturn normalize(vec3(a+b-c-d,a-b+c-d,a-b-c+d));\n}\n\n\n#define res iResolution.xy\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec3 p = vec3(0,0,10.);\n    float sc = 1./length(res);\n    vec3 d = normalize(vec3(10.*(coord-.5*res)*sc,0.)-p);\n    \n    if (iMouse.z>0.){\n        vec2 uv = 3.*(iMouse.xy-.5*res)*sc;\n        a = 1.2*normalize(vec3(uv,cos(2.*length(uv)))), b=-a;\n    }\n    else{\n        //float c = cos(iTime), s = sin(iTime);\n        float c = 1., s = 0.;\n        a = vec3(1.2*c,.4*c,-s), b=-a;\n    }\n    \n    // the usual raymarching code\n    col = vec4(0,0,0,1);\n    float t=0., dt;\n    for (int i=0;i<64;i++){\n        dt = map(p+t*d);\n        t += dt;\n        if (dt<.001) break;\n        if (t>100.) return;\n    }\n    col.xyz=vec3(.9*max(dot(grad(p+t*d),vec3(.55)),0.)+.1);\n}\n\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3dXfDr",
    "date": "1588004495",
    "viewed": 92,
    "name": "Implicit Star",
    "description": "A modification of my first shader https://www.shadertoy.com/view/WtjSD3. Make the code faster and look less naive.",
    "likes": 7,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "star",
     "implicit"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// the equation of the star shape:\n// 4(x²+2y²+z²-1)²-(5x⁴z-10x²z³+z⁵)-1=0\n// or: 4(x²+2y²+z²-1)²-Im((x+zi)⁵)-1=0\n\nfloat func(in vec3 p){\n    vec3 u = p*p;\n    float d = u.x+2.0*u.y+u.z-1.0;\n    if (d>3.0) return d;  // clipping needed because its degree is odd\n    return 4.0*d*d-p.z*(5.*u.x*u.x-10.*u.x*u.z+u.z*u.z)-1.0;\n}\n\nvec3 calcGrad(vec3 p){\n    const float e = .0001;\n\tfloat a = func(p+vec3(e,e,e));\n\tfloat b = func(p+vec3(e,-e,-e));\n\tfloat c = func(p+vec3(-e,e,-e));\n\tfloat d = func(p+vec3(-e,-e,e));\n\treturn vec3(a+b-c-d,a-b+c-d,a-b-c+d)*(.25/e);\n}\n\n\nconst vec3 light = normalize(vec3(-0.3, 0.1, 1));\n\nvec3 castRay(vec3 p, vec3 d) {\n\tfloat t = 1e-3, dt;\n\tif (func(p) < 0.0) return vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < 1024; i++) {\n\t\tdt = func(p + t * d);\n        dt /= length(calcGrad(p + t * d));\n\t\tt += 0.5*dt;\n        if (dt < 1e-2) {\n\t\t\tp += t * d;\n    \t\tvec3 n = normalize(calcGrad(p));\n    \t\tif (dot(n, d) > 0.0) n = -n;\n    \t\tfloat dif = clamp(dot(n, light), 0.0, 1.0);\n    \t\treturn (0.7*dif+0.2*pow(max(dot(d, light),0.0),4.0)+0.4)*vec3(1.0,0.6,0.1);\n        }\n\t\tif (t > 20.0) break;\n\t}\n    vec3 col = sin(30.0*d.x)+sin(30.0*d.y)+sin(30.0*d.z)>0.0 ?\n        vec3(1.0,0.8,0.6) : vec3(0.9,0.6,0.8);\n\tt = max(dot(d,light), 0.0);\n\treturn (0.3+0.7*t)*col;\n}\n\n#define AA 2\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float h = 1.5*cos(0.4*iTime)+1.0;\n    float r = sqrt(20.0-h*h)+0.2*(cos(iTime)+1.0);\n    vec3 pos = vec3(r*cos(iTime), r*sin(iTime), h);\n    float Unit = 0.5*length(iResolution);\n\n    vec3 w = normalize(pos);\n    vec3 u=normalize(vec3(-w.y,w.x,0));\n    vec3 v=cross(w,u);\n    mat3 M=-mat3(u,v,w);\n\n    vec3 col;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d=M*vec3(0.5*iResolution.xy-(fragCoord.xy+vec2(i,j)/float(AA)),Unit);\n        col += castRay(pos,normalize(d));\n    }\n    col/=float(AA*AA);\n\n    col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wdsfzj",
    "date": "1588824320",
    "viewed": 4,
    "name": "Untitled 0x00000017",
    "description": "school project",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "archer"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define AA 2\n\n#define eps 1e-5\n\n\nconst vec3 light = normalize(vec3(0.3, -0.2, 1));\n\nvec3 calcGrad(vec3 p){\n    const float e = .001;\n\tfloat a = map(p+vec3(e,e,e));\n\tfloat b = map(p+vec3(e,-e,-e));\n\tfloat c = map(p+vec3(-e,e,-e));\n\tfloat d = map(p+vec3(-e,-e,e));\n\treturn normalize(vec3(a+b-c-d,a-b+c-d,a-b-c+d));\n}\n\nvec3 castRay(vec3 p, vec3 d) {\n    float t = 0.0, dt;\n\tfor (int i = 0; i < 256; i++) {\n\t\tdt = map(p + t * d);\n\t\tt += dt;\n        if (dt<-eps) return vec3(1,0,0);\n\t\tif (dt<eps) break;\n\t\tif (t>20.0) return vec3(0.0);\n\t}\n\tp = p + t * d;\n    vec3 n = calcGrad(p);\n    d-=2.0*dot(d,n)*n;\n\tvec3 bkg = vec3(0.2, 0.15, 0.1);\n\tvec3 dif = vec3(0.7, 0.65, 0.6) * max(dot(n, light), 0.0);\n\tvec3 spc = vec3(0.2) * pow(max(dot(d, light), 0.0), 5.0);\n    return bkg+dif+spc;\n}\n\n#define SC 2.0\n#define Center vec3(0,0,0.8)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n#if 0\n    vec2 p = iMouse.w>0.?iMouse.xy:-iMouse.zw;\n    float t = p.x/iResolution.x*4.0*PI;\n    float a = PI*(p.y/iResolution.y-0.3);\n#else\n    float t = 0.6*sin(0.2*iTime)+0.05, a = 0.2;\n#endif\n    vec3 pos = 8.*SC*vec3(cos(a)*cos(t),cos(a)*sin(t), sin(a));\n\n    vec3 w = normalize(pos);\n    vec3 u=normalize(vec3(-w.y,w.x,0));\n    vec3 v=cross(w,u);\n    mat3 M=-mat3(u,v,w);\n\n    vec3 col;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d=M*vec3(0.5*iResolution.xy-(fragCoord.xy+vec2(i,j)/float(AA)),SC*length(iResolution.xy));\n        col += castRay(pos+Center,normalize(d));\n    }\n    col/=float(AA*AA);\n\n    //col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    fragColor = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define PI 3.14159265358979\n\n// all sdf functions copy-pasted from iq\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdEllipsoid( vec3 p, vec3 r ) {\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\nmat3 axisAngle(vec3 a, float t) {  // actually returns its inverse/transpose\n\ta = normalize(a); float ct = cos(t), st = sin(t);\n\treturn mat3(\n\t\tct + a.x*a.x*(1.-ct), a.x*a.y*(1.-ct) - a.z*st, a.x*a.z*(1.-ct) + a.y*st,\n\t\ta.y*a.x*(1.-ct) + a.z*st, ct + a.y*a.y*(1.-ct), a.y*a.z*(1.-ct) - a.x*st,\n\t\ta.z*a.x*(1.-ct) - a.y*st, a.z*a.y*(1.-ct) + a.x*st, ct + a.z*a.z*(1.-ct)\n\t);\n}\n\n\n//=========================================================================================\n\n\nfloat mapBase(vec3 p){\n    float d = length(p.xy)-1.0;\n    return max(d,abs(p.z+0.1)-0.1);\n}\n\nfloat mapArch(vec3 p){\n    //vec3 q = axisAngle(vec3(0,-1,0),0.15)*axisAngle(vec3(1,0,0),0.2)*(p-vec3(0,0,0.97));\n    vec3 q=mat3(0.988771,0,-0.149438,-0.0296888,0.980067,-0.196438,0.146459,0.198669,0.969061)*(p-vec3(0,0,0.97));\n    float c = sdEllipsoid(q,vec3(0.3,1.0,1.0-0.1*p.z));\n    q = p-vec3(0,-16,-0.4);\n\tfloat pz2 = (p.z-1.)*(p.z-1.);\n    c = smax(c,sdEllipsoid(q,vec3(2.0,15.8,16.0)),smax(0.05*(1.0-pz2),0.0,0.01));\n    float h = sdCapsule(p,vec3(0.05,-0.3,0.97),vec3(0.2+exp(0.15*p.y)-1.0,0.35,0.9),0.25+0.08*p.y-pz2);\n    float s = length(p-vec3(0.27,0.35,1.0))-0.25;\n    float v = sdCylinder(p,vec3(0.35,0.3,0.9),vec3(0.55,0.3,0.9),0.55*(p.y-0.1)+0.2*(p.x-0.3));\n    h=smin(h,v,0.1);\n    return smin(c,h,0.1);\n}\n\nfloat mapArm(vec3 p){\n    //vec3 q = axisAngle(vec3(0,0,1),-0.3)*axisAngle(vec3(0,-1,0),0.1)*axisAngle(vec3(1,0,0),0.1)*(p-vec3(0.43,-0.37,1.0));\n    vec3 q = mat3(0.950564,0.294044,-0.0998334,-0.303565,0.947618,-0.0993347,0.0653952,0.12473,0.990033)*(p-vec3(0.43,-0.37,1.0));\n    return sdEllipsoid(q,vec3(0.05,0.11,0.25));\n}\n\nfloat mapBody(vec3 p){\n    float b = length(p.xy-vec2(-0.1,0.4-0.1*p.z))-0.21+0.01*p.z;\n    b = smax(b,abs(p.z-0.5)-0.5,0.05);\n    float c = sdEllipsoid(p-vec3(-0.1,0.35,0.9),vec3(0.35,0.4,0.35));\n    c = smin(b,c,0.2);\n    float u = length(p.xy-vec2(-0.1,0.47))-max(0.23-p.x*p.x,0.);\n    u = smax(u,abs(p.z-0.1*p.y-1.35)-0.35,max(0.1*(2.0-p.z),0.));\n    c = smin(u,c,0.2);\n    return c;\n}\n\nfloat map(vec3 p) {\n    float sb = max(min(length(p.xy),min(length(p.xz),length(p.yz))),length(p)-3.0)-0.01;\n    sb = min(sb, min(length(p-vec3(3,0,0)),length(p-vec3(0,3,0)))-0.1);\n    sb = min(sb, mapBase(p));\n    //sb=1e12;\n    float sd = smin(mapArch(p),mapBody(p),0.2);\n    sd=min(sd,mapArm(p));\n    return 0.5*min(sb,sd);\n}\n\n\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wsfBRX",
    "date": "1588824572",
    "viewed": 34,
    "name": "ASM2O CPT",
    "description": "School project appropriating The Archer by Henry Moore. The animation is not as good as expected.\nA realtime software renderer written in C++ uses bounding boxes to accelerate raymarching, but this one doesn't.",
    "likes": 2,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "ring",
     "loop",
     "hand",
     "archer"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define Time (iTime-1.0)\n\nconst vec3 light_pos = 5.0*vec3(0.7,-2.0,1.8);\n\n#define eps 0.001\n\nvec3 castRay(vec3 p, vec3 d) {\n    float t = 0.0, dt, mt=1e12;\n\tfor (int i = min(iFrame,0); i < 256; i++) {\n\t\tdt = map(p + t * d, Time);\n\t\tt += dt;\n        if (dt<-eps) return vec3(1,0,0);\n\t\tif (dt<eps) break;\n\t\tif (t>20.0) return vec3(0.0);\n\t}\n\tp = p + t * d;\n    vec3 n = calcGrad(p, Time);\n    d-=2.0*dot(d,n)*n;\n\tvec3 light = normalize(light_pos-p);\n\tvec3 dif = vec3(0.7, 0.65, 0.6) * max(dot(n, light), 0.0);\n\tvec3 spc = vec3(0.2) * pow(max(dot(d, light), 0.0), 5.0);\n  #if 1\n    t=0.1, d=light;\n\tfor (int i = min(iFrame,0); i < 64; i++) {\n\t\tdt = map(p + t * d, Time);\n\t\tt += dt;\n        mt=min(mt,0.5+5.0*dt/t);\n        if (t>10.0) {dif*=clamp(mt,0.0,1.0);break;}\n        if (dt<0.01) {dif*=0.5;break;}\n\t}\n  #endif\n    float m = exp(-0.1*dot(p.xy,p.xy));\n    m*=1.0-exp(-2.0*iTime);\n    m*=1.0-exp(2.0*(iTime-39.));\n    return m*(dif+spc);\n}\n\n\n#define AA 1\n#define SC 2.0\n\nfloat sstep(float x) {\n    x=clamp(x,0.,1.);\n    return x*x*(3.-2.*x);\n}\n\n#define res iResolution.xy\nvec3 Ctr = vec3(0,0.5,0.2);\n\nvec3 CamP, ScrO, ScrA, ScrB;\nvoid setCamera(float rz, float rx, float dist, float unit){\n    float cx=cos(rx), sx=sin(rx), cz=cos(rz), sz=sin(rz);\n    vec3 u=vec3(-sz,cz,0.), v=vec3(-cz*sx,-sz*sx,cx), w=vec3(cz*cx,sz*cx,sx);\n    u*=0.5*res.x/unit, v*=0.5*res.y/unit, w*=dist;\n    CamP=Ctr+w;\n    ScrO=Ctr-(u+v), ScrA=u*2.0,ScrB=v*2.0;\n}\n\nvoid mainImage( out vec4 color, in vec2 coord ){\n#if 0\n    vec2 p = iMouse.w>0.?iMouse.xy:-iMouse.zw;\n    float t = 2.0*PI*(p.x/res.x-0.5);\n    float a = PI*(p.y/res.y-0.5);\n#else\n    float t = 0.3, a=0.2, c;\n    if (iTime>6.0) c=sstep(2.0*(iTime-6.)),t=mix(t,-0.1,c),a=mix(a,-0.6,c),Ctr=mix(Ctr,vec3(0,0.5,0.4),c);\n    if (iTime>19.0) c=sstep(0.8*(iTime-19.)),a=mix(a,-0.4,c),Ctr=mix(Ctr,vec3(0,0.5,0.6),c);\n    if (iTime>26.0) c=sstep(2.0*(iTime-26.)),t=mix(t,0.2,c),a=mix(a,0.3,c),Ctr=mix(Ctr,vec3(0,0.2,0.6),c);\n    if (iTime>30.0) c=sstep(2.0*(iTime-30.)),t=mix(t,-0.2,c),a=mix(a,-0.2,c),Ctr=mix(Ctr,vec3(0,0.2,0.2),c);\n    if (iTime>36.0) c=sstep(2.0*(iTime-36.)),t=mix(t,0.1,c),a=mix(a,-0.7,c),Ctr=mix(Ctr,vec3(0,0.2,-0.3),c);\n#endif\n    float CamSC = length(res);\n    setCamera(-1.5+t,0.8+a,6000./CamSC,0.2*CamSC);\n    \n    vec3 col=vec3(0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec2 uv = (coord+vec2(i,j)/float(AA))/res;\n        vec3 d = normalize(ScrO+uv.x*ScrA+uv.y*ScrB - CamP);\n        col += castRay(CamP,d);\n    }\n    col/=float(AA*AA);\n\n    //col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    color = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define PI 3.14159265358979\n\n// all sdf functions copy-pasted from iq ;)\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdEllipsoid( vec3 p, vec3 r ) {\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nmat3 axisAngle(vec3 a, float t) {  // actually returns its inverse/transpose\n\ta = normalize(a); float ct = cos(t), st = sin(t);\n\treturn mat3(\n\t\tct + a.x*a.x*(1.-ct), a.x*a.y*(1.-ct) - a.z*st, a.x*a.z*(1.-ct) + a.y*st,\n\t\ta.y*a.x*(1.-ct) + a.z*st, ct + a.y*a.y*(1.-ct), a.y*a.z*(1.-ct) - a.x*st,\n\t\ta.z*a.x*(1.-ct) - a.y*st, a.z*a.y*(1.-ct) + a.x*st, ct + a.z*a.z*(1.-ct)\n\t);\n}\n\n\n// ===================================== Animate =====================================\n\nvec3 animatePath(float t){\n    t*=4.0;\n    float d = 0.57*t;\n    float rx=1.0-exp(-0.4*t), ry=1.0-exp(-0.2*t), h=1.0-exp(-3.*t);\n    vec3 q = vec3(cos(t+d),sin(1.3*t+d),sin(2.*t));\n    q*=vec3(rx,ry,h)*vec3(0.2,0.2,0.2);\n    return q;\n}\n\n// ===================================== Archer =====================================\n\n// unlisted initial modeling: https://www.shadertoy.com/view/Wdsfzj\n\nvec3 MapC = vec3(0.0,0.5,0.6);\n\nfloat mapArch(vec3 p){\n    //vec3 q = axisAngle(vec3(0,-1,0),0.15)*axisAngle(vec3(1,0,0),0.2)*(p-vec3(0,0,0.97));\n    vec3 q=mat3(0.988771,0,-0.149438,-0.0296888,0.980067,-0.196438,0.146459,0.198669,0.969061)*(p-vec3(0,0,0.97));\n    float c = sdEllipsoid(q,vec3(0.3,1.0,1.0-0.1*p.z));\n    q = p-vec3(0,-16,-0.4);\n\tfloat pz2 = (p.z-1.)*(p.z-1.);\n    c = smax(c,sdEllipsoid(q,vec3(2.0,15.8,16.0)),smax(0.05*(1.0-pz2),0.0,0.01));\n    float h = sdCapsule(p,vec3(0.05,-0.3,0.97),vec3(0.2+exp(0.15*p.y)-1.0,0.35,0.9),0.25+0.08*p.y-pz2);\n    float s = length(p-vec3(0.27,0.35,1.0))-0.25;\n    float v = sdCylinder(p,vec3(0.35,0.3,0.9),vec3(0.55,0.3,0.9),0.55*(p.y-0.1)+0.2*(p.x-0.3));\n    h=smin(h,v,0.1);\n    return smin(c,h,0.1);\n}\nfloat mapArm(vec3 p){\n    //vec3 q = axisAngle(vec3(0,0,1),-0.3)*axisAngle(vec3(0,-1,0),0.1)*axisAngle(vec3(1,0,0),0.1)*(p-vec3(0.43,-0.37,1.0));\n    vec3 q = mat3(0.950564,0.294044,-0.0998334,-0.303565,0.947618,-0.0993347,0.0653952,0.12473,0.990033)*(p-vec3(0.43,-0.37,1.0));\n    return sdEllipsoid(q,vec3(0.05,0.11,0.25));\n}\nfloat mapBody(vec3 p){\n    float b = length(p.xy-vec2(-0.1,0.4-0.1*p.z))-0.21+0.01*p.z;\n    b = smax(b,abs(p.z-0.5)-0.5,0.05);\n    float c = sdEllipsoid(p-vec3(-0.1,0.35,0.9),vec3(0.35,0.4,0.35));\n    c = smin(b,c,0.2);\n    float u = length(p.xy-vec2(-0.1,0.47))-max(0.23-p.x*p.x,0.);\n    u = smax(u,abs(p.z-0.1*p.y-1.35)-0.35,max(0.1*(2.0-p.z),0.));\n    c = smin(u,c,0.2);\n    return c;\n}\nfloat archerTotal(vec3 p, float t) {\n\tfloat a = mapArch(p);\n\tfloat b = mapBody(p);\n\tfloat sd = smin(a, b, 0.2);\n\tfloat am = mapArm(p);\n\tsd = smin(sd, am, 0.05);\n\treturn mix(sd, length(p-vec3(0.0,0.0,0.8))-0.8, t);\n}\n\nvec3 archerPath(float t){\n    t-=4.7; if (t<0.) return vec3(0,0,1e12);\n    t=max(t-0.3,0.);\n    float h = 0.2+exp(-t*t)/t;\n    vec3 p= animatePath(t-0.1)+vec3(0.0,0.5,h);\n    float m=sin(5.*t); m=m*m;\n    p.z=mix(p.z,m,clamp(0.5*(t-13.),0.,1.))+0.07;\n    p+=max(pow(12.*(t-16.9),3.),0.)*vec3(0,-1,1.5);\n    return p;\n}\nmat3 archerOrientation(float t){\n    t-=0.1;\n    float rx=clamp(t-5.0,0.0,0.2);\n    rx+=.7*(0.5-1./(t-3.))*sin(2.*t);\n    rx+=max(30.*(t-21.9),0.);\n    vec3 i=normalize(vec3(0,-1,0.3-rx)), j=normalize(vec3(1,0,0)), k=cross(i,j);\n    return transpose(mat3(i,j,k));\n}\n\nfloat archMeta(float t){\n    return clamp(2.0*(8.5-t),0.,1.);\n}\n\nfloat mapArcher(vec3 p, float t){\n    const float SC = 0.6;\n    mat3 R=archerOrientation(t)*(1./SC);\n    p=R*(p-archerPath(t));\n    return SC*archerTotal(p,archMeta(t));\n}\n\n\n// ===================================== Hand =====================================\n\nvec3 handPath(float t){\n    t-=4.7;\n    if (t<0.) return vec3(0,0,t*t*t);\n    t=max(t-0.3,0.);\n    vec3 p= animatePath(t);\n    p*=max(1.-exp(3.*(t-15.)),0.);\n    p+=max(pow(8.*(t-16.9),3.),0.)*vec3(0,-1,0.8);\n    if (t>18.0) p=vec3(0,0,0.5*pow(21.5-t,3.));\n    return p;\n}\nmat3 handOrientation(vec3 p, float t){\n    float rx=clamp(t-5.0,0.0,0.2);\n    rx+=.5*(0.5-1./(t-3.))*sin(2.*t);\n    rx*=max(1.-exp(5.*(t-20.5)),0.);\n    rx+=max(20.*(t-21.9),0.);\n    if (t>23.0) rx=0.1*sin(t);\n    vec3 i=normalize(vec3(1,0,0)), j=normalize(vec3(0,1,rx)), k=cross(i,j);\n    return (mat3(i,j,k));\n}\n\nfloat mapHand(vec3 p, float t){\n    mat3 M = handOrientation(p,t);\n    vec3 A0 = M*vec3(-0.2,-0.5,0.08);\n    vec3 A1 = M*vec3(-0.5,-0.18,-0.01);\n    vec3 A2 = M*vec3(-0.68,0.15,0.03);\n    vec3 A3 = M*vec3(-0.98,0.3,0.03);\n    vec3 B1 = M*vec3(-0.26,0.31,-0.05);\n    vec3 B2 = M*vec3(-0.36,0.65,-0.14);\n    vec3 B3 = M*vec3(-0.42,0.86,-0.15);\n    vec3 B4 = M*vec3(-0.50,1.12,-0.08);\n    vec3 C1 = M*vec3(-0.04,0.28,-0.08);\n    vec3 C2 = M*vec3(0,0.74,-0.23);\n    vec3 C3 = M*vec3(0,1,-0.16);\n    vec3 C4 = M*vec3(0,1.25,-0.08);\n    vec3 D1 = M*vec3(0.17,0.2,-0.08);\n    vec3 D2 = M*vec3(0.3,0.65,-0.17);\n    vec3 D3 = M*vec3(0.34,0.84,-0.12);\n    vec3 D4 = M*vec3(0.41,1.09,0);\n    vec3 E0 = M*vec3(0.23,-0.5,0.1);\n    vec3 E1 = M*vec3(0.39,0.10,-0.06);\n    vec3 E2 = M*vec3(0.53,0.36,-0.09);\n    vec3 E3 = M*vec3(0.62,0.51,-0.04);\n    vec3 E4 = M*vec3(0.68,0.75,0.09);\n    float r = 0.1;\n    \n    float d = 1e12;\n    p-=handPath(t);\n    #define CS(a,b) d=smin(d,sdCapsule(p,a,b,r),0.05)\n\tCS(A0,A1); CS(A1,A2); CS(A2,A3);\n\tCS(B1,B2); CS(B2,B3); CS(B3,B4);\n\tCS(C1,C2); CS(C2,C3); CS(C3,C4);\n\tCS(D1,D2); CS(D2,D3); CS(D3,D4);\n\tCS(E0,E1); CS(E1,E2); CS(E2,E3); CS(E3,E4);\n    #undef CS\n    return d;\n\n}\n\n\n// ===================================== Ring =====================================\n\nconst float Ground_Z = -1.0;\n\n#define ringR 0.15\n#define ringr 0.04\n\nvec3 ringPath(float t){\n    float t0=t;\n    const vec3 g = vec3(0,0,-9.8);\n    vec3 p=vec3(0.8,1.2,2.0), v=vec3(-0.5,-0.2,0.0);\n    float mt=0.0;\n    for (int i=min(int(t),0);i<10;i++){\n        mt=(-sqrt(v.z*v.z-2.0*g.z*(p.z-Ground_Z-ringR-ringr))-v.z)/g.z;\n        if (mt>t){\n            return p+t*(v+0.5*g*t);\n        }\n        t-=mt, p=p+mt*(v+0.5*g*mt);\n        v=0.5*(v+g*mt); v.z=-v.z;\n        p+=1e-4*v;\n    }\n    t=t0-2.5;\n    if (t<0.) return p;\n    if (t<.5) return p+0.5*t*t*g;\n    if (t0<23.) return handPath(t0)+handOrientation(vec3(0.0),t0)*vec3(0.3,0.6,-0.17);\n    p=vec3(0.5,0.7,5.0), v=vec3(0,0,-1), mt=0.0,t=t0-29.0;\n    if (t<0.) return vec3(0,0,1e12);\n    for (int i=min(int(t),0);i<10;i++){\n        mt=(-sqrt(v.z*v.z-2.0*g.z*(p.z-Ground_Z-ringR-ringr))-v.z)/g.z;\n        if (mt>t){\n            return p+t*(v+0.5*g*t);\n        }\n        t-=mt, p=p+mt*(v+0.5*g*mt);\n        v=0.5*(v+g*mt); v.z=-v.z;\n        p+=1e-4*v;\n    }\n    if (t0<33.5) return p;\n    return vec3(p.xy,max(p.z-0.5*(t0-33.5),Ground_Z+ringr));\n}\nmat3 ringOrientation(float t){\n    if (t<3.0) return mat3(1.0);\n    vec3 i=normalize(vec3(1.0,-0.3,0.0)),k=vec3(0,0,1),j=cross(k,i);\n    if (t<23.) transpose(handOrientation(vec3(0.0),t)*mat3(i,j,k));\n    t-=33.5;\n    if (t<0.) return mat3(1.0);\n    float a=clamp(5.*t,0.,.5*PI);\n    return mat3(1,0,0,0,cos(a),sin(a),0,-sin(a),cos(a));\n}\n\nfloat mapRing(vec3 p, float t){\n    p = ringOrientation(t) * (p - ringPath(t));\n    return sdTorus(p,vec2(ringR,ringr));\n}\n\nfloat ringsm(float t){\n    if (t<2.5) return 0.0;\n    if (t<3.0) return t-2.5;\n    if (t>25.0) return 0.0;\n    return 0.1;\n}\n\n\n// ===================================== Together =====================================\n\n\nfloat map(vec3 p, float t){\n    float a=1e12,h=1e12,r=1e12,g=1e12;\n    a = 0.5*mapArcher(p,t);\n    h = mapHand(p,t);\n    r = mapRing(p,t);\n    g = p.z-Ground_Z;\n    if (t<0.) return g;\n    return min(a,min(smin(h,g,0.1),smin(r,g,ringsm(t))));\n}\n\n\nvec3 calcGrad(vec3 p, float t){\n    const float e = .001;\n#if 0\n\tfloat a = map(p+vec3(e,e,e),t);\n\tfloat b = map(p+vec3(e,-e,-e),t);\n\tfloat c = map(p+vec3(-e,e,-e),t);\n\tfloat d = map(p+vec3(-e,-e,e),t);\n\treturn normalize(vec3(a+b-c-d,a-b+c-d,a-b-c+d));\n#else\n    vec3 n = vec3(0.0);\n    for(int i=min(int(t),0); i<4; i++){\n        vec3 h = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += h*map(p+h*e,t);\n    }\n    return normalize(n);\n#endif\n}\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WdlfWB",
    "date": "0",
    "viewed": 0,
    "name": "ASM2O CPT (redux)",
    "description": "School project appropriating The Archer by Henry Moore. The animation isn't as good as expected.\nTo meet the deadline, the original shader didn't pay much attention to performance. So I made a faster one there.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "ring",
     "loop",
     "hand",
     "archer"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Original shader: https://shadertoy.com/view/wsfBRX\n// More readable but compiles VERY SLOW\n\n\n#define PI 3.14159265358979\n#define ZERO min(iFrame,0)\n\n// all sdf functions copy-pasted from iq ;)\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdEllipsoid( vec3 p, vec3 r ) {\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ===================================== Animate =====================================\n\nvec3 animatePath(float t){\n    t*=4.0;\n    float d = 0.57*t;\n    float rx=1.0-exp(-0.4*t), ry=1.0-exp(-0.2*t), h=1.0-exp(-3.*t);\n    vec3 q = vec3(cos(t+d),sin(1.3*t+d),sin(2.*t));\n    q*=vec3(rx,ry,h)*vec3(0.2);\n    return q;\n}\n\n// ===================================== Archer =====================================\n\n// unlisted initial modeling: https://www.shadertoy.com/view/Wdsfzj\n\nfloat archerTotal(vec3 p, float t) {\n\tfloat sd;\n    // archer\n    {\n    \tvec3 q=mat3(0.988771,0,-0.149438,-0.0296888,0.980067,-0.196438,0.146459,0.198669,0.969061)*(p-vec3(0,0,0.97));\n    \tfloat c = sdEllipsoid(q,vec3(0.3,1.0,1.0-0.1*p.z));\n    \tq = p-vec3(0,-16,-0.4);\n\t\tfloat pz2 = (p.z-1.)*(p.z-1.);\n    \tc = smax(c,sdEllipsoid(q,vec3(2.0,15.8,16.0)),smax(0.05*(1.0-pz2),0.0,0.01));\n    \tfloat h = sdCapsule(p,vec3(0.05,-0.3,0.97),vec3(0.2+exp(0.15*p.y)-1.0,0.35,0.9),0.25+0.08*p.y-pz2);\n    \tfloat s = length(p-vec3(0.27,0.35,1.0))-0.25;\n    \tfloat v = sdCylinder(p,vec3(0.35,0.3,0.9),vec3(0.55,0.3,0.9),0.55*(p.y-0.1)+0.2*(p.x-0.3));\n    \th=smin(h,v,0.1);\n    \tsd=smin(c,h,0.1);\n    }\n    // body\n    {\n    \tfloat v = length(p.xy-vec2(-0.1,0.4-0.1*p.z))-0.21+0.01*p.z;\n    \tv = smax(v,abs(p.z-0.5)-0.5,0.05);\n    \tfloat b = sdEllipsoid(p-vec3(-0.1,0.35,0.9),vec3(0.35,0.4,0.35));\n    \tb = smin(v,b,0.2);\n    \tfloat u = length(p.xy-vec2(-0.1,0.47))-max(0.23-p.x*p.x,0.);\n    \tu = smax(u,abs(p.z-0.1*p.y-1.35)-0.35,max(0.1*(2.0-p.z),0.));\n\t\tsd = smin(sd, smin(u,b,0.2), 0.2);\n    }\n    // arm (floating ellipsoid)\n    {\n        vec3 q = mat3(0.950564,0.294044,-0.0998334,-0.303565,0.947618,-0.0993347,0.0653952,0.12473,0.990033)*(p-vec3(0.43,-0.37,1.0));\n        sd = smin(sd, sdEllipsoid(q,vec3(0.05,0.11,0.25)), 0.05);\n    }\n\treturn mix(sd, length(p-vec3(0.0,0.0,0.8))-0.8, t);\n}\n\nvec3 archerPath(float t){\n    t-=4.7; if (t<0.) return vec3(0,0,1e12);\n    t=max(t-0.3,0.);\n    float h = 0.2+exp(-t*t)/t;\n    vec3 p= animatePath(t-0.1)+vec3(0.0,0.5,h);\n    float m=sin(5.*t); m=m*m;\n    p.z=mix(p.z,m,clamp(0.5*(t-13.),0.,1.))+0.07;\n    p+=max(pow(12.*(t-16.9),3.),0.)*vec3(0,-1,1.5);\n    return p;\n}\nvec3 archerPathRes;\n\nmat3 archerOrientation(float t){\n    t-=0.1;\n    float rx=clamp(t-5.0,0.0,0.2);\n    rx+=.7*(0.5-1./(t-3.))*sin(2.*t);\n    rx+=max(30.*(t-21.9),0.);\n    vec3 i=normalize(vec3(0,-1,0.3-rx)), j=normalize(vec3(1,0,0)), k=cross(i,j);\n    return transpose(mat3(i,j,k));\n}\nmat3 archerOrientationRes;\n\nfloat mapArcher(vec3 p, float t){\n    const float SC = 0.6;\n    mat3 R=archerOrientationRes*(1./SC);\n    p=R*(p-archerPathRes);\n    return SC*archerTotal(p,clamp(2.0*(8.5-t),0.,1.));\n}\n\n\n// ===================================== Hand =====================================\n\nvec3 handPath(float t){\n    t-=4.7;\n    if (t<0.) return vec3(0,0,t*t*t);\n    t=max(t-0.3,0.);\n    vec3 p= animatePath(t);\n    p*=max(1.-exp(3.*(t-15.)),0.);\n    p+=max(pow(8.*(t-16.9),3.),0.)*vec3(0,-1,0.8);\n    if (t>18.0) p=vec3(0,0,0.5*pow(21.5-t,3.));\n    return p;\n}\nvec3 handPathRes;\n\nmat3 handOrientation(float t){\n    float rx=clamp(t-5.0,0.0,0.2);\n    rx+=.5*(0.5-1./(t-3.))*sin(2.*t);\n    rx*=max(1.-exp(5.*(t-20.5)),0.);\n    rx+=max(20.*(t-21.9),0.);\n    if (t>23.0) rx=0.1*sin(t);\n    vec3 i=normalize(vec3(1,0,0)), j=normalize(vec3(0,1,rx)), k=cross(i,j);\n    return mat3(i,j,k);\n}\nmat3 handOrientationRes;\n\nfloat mapHand(vec3 p, float t){\n    vec3 A0 = vec3(-0.2,-0.5,0.08);\n    vec3 A1 = vec3(-0.5,-0.18,-0.01);\n    vec3 A2 = vec3(-0.68,0.15,0.03);\n    vec3 A3 = vec3(-0.98,0.3,0.03);\n    vec3 B1 = vec3(-0.26,0.31,-0.05);\n    vec3 B2 = vec3(-0.36,0.65,-0.14);\n    vec3 B3 = vec3(-0.42,0.86,-0.15);\n    vec3 B4 = vec3(-0.50,1.12,-0.08);\n    vec3 C1 = vec3(-0.04,0.28,-0.08);\n    vec3 C2 = vec3(0,0.74,-0.23);\n    vec3 C3 = vec3(0,1,-0.16);\n    vec3 C4 = vec3(0,1.25,-0.08);\n    vec3 D1 = vec3(0.17,0.2,-0.08);\n    vec3 D2 = vec3(0.3,0.65,-0.17);\n    vec3 D3 = vec3(0.34,0.84,-0.12);\n    vec3 D4 = vec3(0.41,1.09,0);\n    vec3 E0 = vec3(0.23,-0.5,0.1);\n    vec3 E1 = vec3(0.39,0.10,-0.06);\n    vec3 E2 = vec3(0.53,0.36,-0.09);\n    vec3 E3 = vec3(0.62,0.51,-0.04);\n    vec3 E4 = vec3(0.68,0.75,0.09);\n    \n    float d = 1e12;\n    p=transpose(handOrientationRes)*(p-handPathRes);\n    \n  #define CS(a,b) d=smin(d,sdCapsule(p,a,b,0.1),0.05)\n\tCS(A0,A1); CS(A1,A2); CS(A2,A3);\n\tCS(B1,B2); CS(B2,B3); CS(B3,B4);\n\tCS(C1,C2); CS(C2,C3); CS(C3,C4);\n\tCS(D1,D2); CS(D2,D3); CS(D3,D4);\n\tCS(E0,E1); CS(E1,E2); CS(E2,E3); CS(E3,E4);\n  #undef CS\n    \n    return d;\n\n}\n\n\n// ===================================== Ring =====================================\n\nconst float Ground_Z = -1.0;\n\n#define ringR 0.15\n#define ringr 0.04\n\nvec3 ringPath(float t){\n    float t0=t;\n    const vec3 g = vec3(0,0,-9.8);\n    vec3 p=vec3(0.8,1.2,2.0), v=vec3(-0.5,-0.2,0.0);\n    float mt=0.0;\n    for (int i=ZERO;i<10;i++){\n        mt=(-sqrt(v.z*v.z-2.0*g.z*(p.z-Ground_Z-ringR-ringr))-v.z)/g.z;\n        if (mt>t) return p+t*(v+0.5*g*t);\n        t-=mt, p=p+mt*(v+0.5*g*mt);\n        v=0.5*(v+g*mt); v.z=-v.z;\n        p+=1e-4*v;\n    }\n    t=t0-2.5;\n    if (t<0.) return p;\n    if (t<.5) return p+0.5*t*t*g;\n    if (t0<23.) return handPathRes+handOrientationRes*vec3(0.3,0.6,-0.17);\n    p=vec3(0.5,0.7,5.0), v=vec3(0,0,-1), mt=0.0,t=t0-29.0;\n    if (t<0.) return vec3(0,0,1e12);\n    for (int i=ZERO;i<10;i++){\n        mt=(-sqrt(v.z*v.z-2.0*g.z*(p.z-Ground_Z-ringR-ringr))-v.z)/g.z;\n        if (mt>t) return p+t*(v+0.5*g*t);\n        t-=mt, p=p+mt*(v+0.5*g*mt);\n        v=0.5*(v+g*mt); v.z=-v.z;\n        p+=1e-4*v;\n    }\n    if (t0<33.5) return p;\n    return vec3(p.xy,max(p.z-0.5*(t0-33.5),Ground_Z+ringr));\n}\nvec3 ringPathRes;\n\nmat3 ringOrientation(float t){\n    if (t<3.0) return mat3(1.0);\n    vec3 i=normalize(vec3(1.0,-0.3,0.0)),k=vec3(0,0,1),j=cross(k,i);\n    if (t<23.) transpose(handOrientationRes*mat3(i,j,k));\n    t-=33.5;\n    if (t<0.) return mat3(1.0);\n    float a=clamp(5.*t,0.,.5*PI);\n    return mat3(1,0,0,0,cos(a),sin(a),0,-sin(a),cos(a));\n}\nmat3 ringOrientationRes;\n\nfloat mapRing(vec3 p, float t){\n    p = ringOrientationRes * (p - ringPathRes);\n    return sdTorus(p,vec2(ringR,ringr));\n}\n\n\n// ===================================== Together =====================================\n\n\n// initialize global variables there to prevent long compilation time\n// this reduces compile time from 9.4s to 1.7s on my machine\n// and increases the performance by around 1.5x\nvoid init(float t){\n    handOrientationRes = handOrientation(t);\n    handPathRes = handPath(t);\n    archerOrientationRes = archerOrientation(t);\n    archerPathRes = archerPath(t);\n    ringPathRes = ringPath(t);\n    ringOrientationRes = ringOrientation(t);\n}\n\nfloat map(vec3 p, float t){\n    float a=1e12,h=1e12,r=1e12,g=1e12;\n    a = 0.5*mapArcher(p,t);\n    h = mapHand(p,t);\n    r = mapRing(p,t);\n    g = p.z-Ground_Z;\n    return t<0.?g:min(a,min(smin(h,g,0.1),smin(r,g,t<2.5?.0:t<3.?t-2.5:t>25.?0.:.1)));\n}\n\n\nvec3 calcGrad(vec3 p, float t){\n    vec3 n = vec3(0.0);\n    for(int i=ZERO; i<4; i++){\n        vec3 h = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += h*map(p+h*.001,t);\n    }\n    return normalize(n);\n}\n\n\n\n// ===================================== Raymarch =====================================\n\n\n#define Time (iTime-1.0)\n\n\nconst vec3 light_pos = 5.0*vec3(0.7,-2.0,1.8);\n\n#define eps 0.001\n\nvec3 castRay(vec3 p, vec3 d) {\n    float t = 0.0, dt, mt=1e12;\n\tfor (int i = min(iFrame,0); i < 256; i++) {\n\t\tdt = map(p + t * d, Time);\n\t\tt += dt;\n        if (dt<-eps) return vec3(1,0,0);\n\t\tif (dt<eps) break;\n\t\tif (t>20.0) return vec3(0.0);\n\t}\n\tp = p + t * d;\n    vec3 n = calcGrad(p, Time);\n    d-=2.0*dot(d,n)*n;\n\tvec3 light = normalize(light_pos-p);\n\tvec3 dif = vec3(0.7, 0.65, 0.6) * max(dot(n, light), 0.0);\n\tvec3 spc = vec3(0.2) * pow(max(dot(d, light), 0.0), 5.0);\n  #if 1\n    t=0.1, d=light;\n\tfor (int i = min(iFrame,0); i < 64; i++) {\n\t\tdt = map(p + t * d, Time);\n\t\tt += dt;\n        mt=min(mt,0.5+5.0*dt/t);\n        if (t>10.0) {dif*=clamp(mt,0.0,1.0);break;}\n        if (dt<0.01) {dif*=0.5;break;}\n\t}\n  #endif\n    float m = exp(-0.1*dot(p.xy,p.xy));\n    m*=1.0-exp(-2.0*iTime);\n    m*=1.0-exp(2.0*(iTime-39.));\n    return m*(dif+spc);\n}\n\n\n#define AA 1\n#define SC 2.0\n\nfloat sstep(float x) {\n    x=clamp(x,0.,1.);\n    return x*x*(3.-2.*x);\n}\n\n#define res iResolution.xy\nvec3 Ctr = vec3(0,0.5,0.2);\n\nvec3 CamP, ScrO, ScrA, ScrB;\nvoid setCamera(float rz, float rx, float dist, float unit){\n    float cx=cos(rx), sx=sin(rx), cz=cos(rz), sz=sin(rz);\n    vec3 u=vec3(-sz,cz,0.), v=vec3(-cz*sx,-sz*sx,cx), w=vec3(cz*cx,sz*cx,sx);\n    u*=0.5*res.x/unit, v*=0.5*res.y/unit, w*=dist;\n    CamP=Ctr+w;\n    ScrO=Ctr-(u+v), ScrA=u*2.0,ScrB=v*2.0;\n}\n\nvoid mainImage( out vec4 color, in vec2 coord ){\n    init(Time);\n#if 0\n    vec2 p = iMouse.w>0.?iMouse.xy:-iMouse.zw;\n    float t = 2.0*PI*(p.x/res.x-0.5);\n    float a = PI*(p.y/res.y-0.5);\n#else\n    float t = 0.3, a=0.2, c;\n    if (iTime>6.0) c=sstep(2.0*(iTime-6.)),t=mix(t,-0.1,c),a=mix(a,-0.6,c),Ctr=mix(Ctr,vec3(0,0.5,0.4),c);\n    if (iTime>19.0) c=sstep(0.8*(iTime-19.)),a=mix(a,-0.4,c),Ctr=mix(Ctr,vec3(0,0.5,0.6),c);\n    if (iTime>26.0) c=sstep(2.0*(iTime-26.)),t=mix(t,0.2,c),a=mix(a,0.3,c),Ctr=mix(Ctr,vec3(0,0.2,0.6),c);\n    if (iTime>30.0) c=sstep(2.0*(iTime-30.)),t=mix(t,-0.2,c),a=mix(a,-0.2,c),Ctr=mix(Ctr,vec3(0,0.2,0.2),c);\n    if (iTime>36.0) c=sstep(2.0*(iTime-36.)),t=mix(t,0.1,c),a=mix(a,-0.7,c),Ctr=mix(Ctr,vec3(0,0.2,-0.3),c);\n#endif\n    float CamSC = length(res);\n    setCamera(-1.5+t,0.8+a,6000./CamSC,0.2*CamSC);\n    \n    vec3 col=vec3(0.0);\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec2 uv = (coord+vec2(i,j)/float(AA))/res;\n        vec3 d = normalize(ScrO+uv.x*ScrA+uv.y*ScrB - CamP);\n        col += castRay(CamP,d);\n    }\n    col/=float(AA*AA);\n\n    //col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    color = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tdlBD2",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x00000018",
    "description": "(make the rendering GeoGebra-liked)\n(make it 60fps without reducing the quality)",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "shading",
     "rasterization",
     "interpolation",
     "parametric"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265358979\n#define res iResolution.xy\nfloat rz, rx, dist, Unit;  // yaw, pitch, camera distance, scale to screen\nmat4 Tr;  // transformation matrix\nvec3 CamP;  // camera position\n\n// transformation matrix and operations\nmat4 Mat4(vec3 i, vec3 j, vec3 k, vec3 t, vec3 p, float s){\n    // row 1, row 2, row 3, translation, perspective, scaling\n    return mat4(i.x,j.x,k.x,p.x,i.y,j.y,k.y,p.y,i.z,j.z,k.z,p.z,t.x,t.y,t.z,s);\n}\nvoid calcMat(){\n    // for simplicy, may can be accelerated a lot\n    const vec3 veci=vec3(1,0,0), vecj=vec3(0,1,0), veck=vec3(0,0,1), vec0=vec3(0);\n    float cx=cos(rx), sx=sin(rx), cz=cos(rz), sz=sin(rz);\n    mat4 R = Mat4(vec3(-sz,cz,0),vec3(-cz*sx,-sz*sx,cx),vec3(-cz*cx,-sz*cx,-sx),vec0,vec0,1.);  // rotation\n    mat4 P = Mat4(veci,vecj,veck,vec0,vec3(0,0,1./dist),1.);  // perspective\n    mat4 S = Mat4(veci,vecj,veck,vec0,vec0,1./Unit);  // scaling\n    mat4 T = Mat4(veci,vecj,veck,vec3(.5*res,0),vec0,1.);  // screen translation\n    Tr = T*S*P*R;\n}\nvoid calcCam() {\n    float cx=cos(rx), sx=sin(rx), cz=cos(rz), sz=sin(rz);\n\tCamP = vec3(cz*cx,sz*cx,sx)*dist;\n}\nvec3 transform(vec3 p){\n    vec4 q = Tr*vec4(p,1.0);\n    return q.xyz/q.w;\n}\n\n// initialize global variables\nvoid init(){\n    if (iMouse.w>0.) rz=4.*PI*(iMouse.x/res.x),rx=PI*(iMouse.y/res.y-.5);\n    else rz=-0.4*PI+iTime, rx=0.15*PI;\n    float sc = sqrt(res.x*res.y);\n    dist=3000.0/sc, Unit=.4*sc;\n    calcMat();\n    calcCam();\n}\n\n\n// parametric equation and normal\nvec3 Map(float u, float v){\n    float k = 1.-v/(2.*PI);\n    float c = cos(u)+1.1;\n    return vec3(0,0,.5*(1.-k))-.4*k*vec3(c*cos(3.*v),c*sin(3.*v),sin(u));\n}\nvec3 nMap(float u, float v){\n    // seems like the same perfermance\n  #if 1\n    float k = 2.*PI-v;\n    float c3v = cos(3.*v), s3v = sin(3.*v), su = sin(u), cu = cos(u);\n    float c = cu+1.1;\n    vec3 du = vec3(c3v*su,s3v*su,-cu);\n    vec3 dv = vec3((3.*k*s3v+c3v)*c,(-3.*k*c3v+s3v)*c,1.25+su);\n    return normalize(cross(du,dv));\n  #else\n    const float e = 0.01;\n    vec3 du = Map(u+e,v)-Map(u-e,v);\n    vec3 dv = Map(u,v+e)-Map(u,v-e);\n    return normalize(cross(du,dv));\n  #endif\n}\n\n\nvec3 calcCol(vec3 p, vec3 n){\n    const vec3 light_pos = vec3(0.7,-2.0,1.8);\n    //vec3 light = normalize(light_pos-p);\n    vec3 light = normalize(light_pos);\n    vec3 d = reflect(normalize(p-CamP),n);\n\tvec3 bkg = vec3(0.2, 0.15, 0.1);\n\tvec3 dif = vec3(0.7, 0.65, 0.6) * max(dot(n, light), 0.0);\n\tvec3 spc = vec3(0.2) * pow(max(dot(d, light), 0.0), 5.0);\n    return bkg+dif+spc;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h =dot(pa,ba)/dot(ba,ba);\n    return length( pa - ba*clamp(h,0.,1.) );\n}\nvec2 solve(vec2 a, vec2 b, vec2 p){\n    //return inverse(mat2(a,b))*p;\n    float m = 1./(a.x*b.y-b.x*a.y);\n    //float u = m*(p.x*b.y-b.x*p.y); if (u<0.||u>1.) return vec2(-1);\n    //float v = m*(a.x*p.y-p.x*a.y); return (v<0.||u+v>1.) ? vec2(-1) : vec2(u,v);\n    return m*vec2(p.x*b.y-b.x*p.y,a.x*p.y-p.x*a.y);\n}\nvec3 rasterize(vec2 P){\n    const int Nu = 10, Nv = 30;\n    const float du=(2.*PI)/float(Nu), dv=(2.*PI)/float(Nv);\n    vec3 col = vec3(1.0);\n    float u,v, z,mz=1e12;\n    int i,j,ZERO=min(iFrame,0);\n    for (i=ZERO,u=0.;i<Nu;i++,u+=du){\n        for (j=ZERO,v=0.;j<Nv;j++,v+=dv){\n            vec3 p00=Map(u,v);\n            vec3 p10=Map(u+du,v);\n            vec3 p01=Map(u,v+dv);\n            vec3 p11=Map(u+du,v+dv);\n            vec3 P00=transform(p00),P10=transform(p10),P01=transform(p01),P11=transform(p11);\n            vec3 d1=P10-P00, d2=P01-P00;\n            vec2 uv = solve(d1.xy,d2.xy,P-P00.xy);\n            if (uv.x>0.&&uv.y>0.&&uv.x+uv.y<1.){\n                if ((z=P00.z+dot(vec2(d1.z,d2.z),uv))<mz) {\n                    mz=z;\n                    vec3 c00=calcCol(p00,nMap(u,v));\n                    vec3 c10=calcCol(p10,nMap(u+du,v))-c00;\n                    vec3 c01=calcCol(p01,nMap(u,v+dv))-c00;\n                    col=c00+uv.x*c10+uv.y*c01;\n                }\n            }\n            d1=P10-P11, d2=P01-P11;\n            uv = solve(d1.xy,d2.xy,P-P11.xy);\n            if (uv.x>0.&&uv.y>0.&&uv.x+uv.y<1.){\n                if ((z=P11.z+dot(vec2(d1.z,d2.z),uv))<mz) {\n                    mz=z;\n                    vec3 c11=calcCol(p11,nMap(u+du,v+dv));\n                    vec3 c10=calcCol(p10,nMap(u+du,v))-c11;\n                    vec3 c01=calcCol(p01,nMap(u,v+dv))-c11;\n                    col=c11+uv.x*c10+uv.y*c01;\n                }\n            }\n        }\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    init();\n    vec3 col = rasterize(coord);\n    color = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wdSfRz",
    "date": "0",
    "viewed": 0,
    "name": "Mandelbrot++++",
    "description": "Had a similar idea before seeing iq's shader but iq's one does help me a lot.\nTry to do something with float that makes double cry.\n\nWARNING: Pause when it gets extremely slow or your browser may crash!!!\n",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "mandelbrot",
     "complex",
     "iteration"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// No matter what it would get,\n// this shader just keeps zooming in uniform speed.\n\n// Not sure if the center of the image is inside the M-set\n// Different machines zooms into different positions\n\n\nvec2 mul(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\nvec2 sqr(vec2 a){\n    return vec2(a.x*a.x-a.y*a.y,2.*a.x*a.y);\n}\n\n\n// replace by a neater one\nvec3 Color(float n){\n    n = mix(4.*pow((log(n+1.)+1.),2.),n,exp(-n*n/20000.));\n    float m = 5.*sin(.1*(n-6.))+n;\n    return vec3(\n        pow(sin((m-8.)/20.),6.),\n        pow(sin((m+1.)/20.),4.),\n        (.8*pow(sin((m+2.)/20.),2.)+.2)*(1.-pow(abs(sin((m-14.)/20.)),12.))\n    );\n}\n\n#define res iResolution.xy\nvoid mainImage(out vec4 color, in vec2 coord) {\n#if 1\n    // double: -0.743643904987575, 0.1318259145542959\n    vec2 p=vec2(-0.743643,0.131825);\n    vec2 dp=vec2(-0.930854e-06,0.913355e-06);\n    vec2 ddp=vec2(-0.63e-12,0.58e-12);\n    const float me = 5e-11;\n#elif 1\n    // double: -1.4110466652141036, -0.001053122049672891\n    vec2 p=vec2(-1.411046,-0.001053);\n    vec2 dp=vec2(-0.662618e-06,0.009992e-06);\n    vec2 ddp=vec2(-0.2e-12,0.9e-12);\n    const float me = 1e-8;\n    // this one is visually cool but actually makes double cry\n#endif\n    float m = exp(2.-.5*iTime)/sqrt(res.x*res.y);\n    int MAX_ITER = int(clamp(sqrt(.05/m),2000.,6000.));\n    \n    vec3 col=vec3(0);\n    \n    vec2 z = vec2(0.0);\n    vec2 dz = vec2(0.0);\n    vec2 ddz = vec2(0.0);\n    vec2 c = p, dc, ddc;\n    if (m>me){\n        dc = (coord-0.5*res)*m+dp;\n        ddc = ddp;\n    }else{\n        dc = dp;\n        ddc = (coord-0.5*res)*m+ddp;\n    }\n    for (int i=0;i<MAX_ITER;i++){\n        vec2 dd=2.*mul(z,ddz);\n        ddz = mul(2.*dz+ddz,ddz)+dd+ddc;\n        dz = mul(2.*z+dz,dz)+dc;\n        z = sqr(z)+c;\n        //float h = dot(dz+ddz,dz+ddz);\n        float h = dot(z+dz+ddz,z+dz+ddz);\n        if (h>256.){\n            col = Color(float(i)-log2(0.5*log2(h))+4.0);\n            //col = Color(float(i)+4.0);\n            break;\n        }\n    }\n    \n    color=vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WsjfzG",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x00000019",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// raymarching distance field: \n// solve for f(ro+rd*d)=0, keep adding d by f(p)/f'(p);\n\n// raymarching parametric curve:\n// solve for f([ro,t0]+[rd,1]*[d,dt])=0, keep adding [d,dt] by ?\n\n#define res iResolution.xy\nfloat sd2Segment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    pa-=ba*clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return dot(pa,pa);\n}\n\n// as global variables\nvec2 ro, rd;\n\n// parametric equation\nvec2 paramEqu(float t){\n    t *= 2.0*3.1415926;\n    return vec2(cos(t),0.2*sin(t)+0.5*sin(2.*t));\n}\n\n// find minimum d>0 so F(d,t)=0\nvec2 F(float d, float t) {\n\treturn ro + rd * d - paramEqu(t);\n}\n\nvoid mainImage(out vec4 fragcol, in vec2 fragpos) {\n    float h = sqrt(res.x*res.y)/5.0;\n    vec2 xy = (fragpos-.5*res)/h;\n    vec3 col = vec3(1.0);\n    \n    // draw path\n    vec2 p0 = paramEqu(0.);\n    float md = dot(p0,p0);\n    for (float t=0.01;t<=1.0;t+=0.01){\n        vec2 p = paramEqu(t);\n        md = min(md,sd2Segment(xy,p0,p));\n        p0=p;\n    }\n    col=mix(vec3(0.0),col,clamp(h*sqrt(md)-2.,0.,1.));\n    \n    // ray\n    ro = (abs(iMouse.zw)-.5*res)/h;\n    rd = normalize((iMouse.xy-.5*res)/h-ro);\n    if (!isnan(rd.x)) col=mix(vec3(0.8),col,clamp(h*sqrt(sd2Segment(xy,ro,ro+rd))-1.,0.,1.));\n    \n    // search for minimum t\n\tfloat d=1000.0, t=0.0;\n    const int SEARCH_N = 20;\n    for (int i=0;i<SEARCH_N;i++){\n        float t1 = float(i)/float(SEARCH_N);\n        float d1 = length(paramEqu(t1)-ro);\n        if (d1<d) d=d1, t=t1;\n    }\n    col=mix(vec3(1,0,0),col,clamp(h*length(xy-paramEqu(t))-3.,0.,1.));\n    \n    // raymarch\n    float md_path = length(xy-ro);\n    float md_param = length(xy-paramEqu(t));\n    \n    d = 0.0;\n    for (int i = 0; i < 64; i++) {\n        const float eps = 0.01;\n        vec2 f = F(d, t);\n        vec2 dfdd = (F(d+eps,t)-F(d-eps,t))/(2.0*eps);\n        vec2 dfdt = (F(d,t+eps)-F(d,t-eps))/(2.0*eps);\n        mat2 jacobian = mat2(dfdd, dfdt);\n        vec2 df = inverse(jacobian)*f;\n        float k = min(0.4, 0.5/abs(df.x));\n        float dd = (-k*df.x);\n        float dt = -k*df.y;\n        d += dd, t += dt;\n        if (abs(dd)<1e-3 || d>10.) break;\n\n        // rendering\n        md_path = min(md_path,length(xy-(ro+rd*d)));\n        md_param = min(md_param,length(xy-paramEqu(t)));\n        //if (!(length(dX)>1e-8)||isnan(0.*X.x*X.y)) break;\n\t}\n    col=mix(vec3(0,0,1),col,clamp(h*md_path-3.,0.,1.));\n    col=mix(vec3(1,0,1),col,clamp(h*md_param-3.,0.,1.));\n    if (abs(d)<10.) col=mix(vec3(1,1,0),col,clamp(h*length(xy-(ro+rd*d))-3.,0.,1.));\n    \n    fragcol = vec4(col,1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wtfyWj",
    "date": "1593051545",
    "viewed": 89,
    "name": "Ellipse Distance Comparison",
    "description": "Comparing two ellipse distance methods found on the internet.\n\nmouseable",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "sdf",
     "ellipse",
     "compare"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Comparing two ellipse distance methods found on the internet\n// The solution that solves a quartic equation is in Common\n// The iteration method works ~1.2 times faster than the analytical one\n// Step length may need to be reduced when using the iteration method in raymarching\n\n\n\n// This iteration method is introduced in\n// https://wet-robots.ghost.io/simple-method-for-distance-to-ellipse/\n\n// Line 23: the asin() is removed to increase performance\n\nfloat sdEllipse_iter(vec2 p, vec2 ab){\n    p = abs(p);\n    float t = 0.785398;\n    vec2 xy;\n    for (int i=0;i<3;i++){\n        vec2 cs = vec2(cos(t),sin(t));\n        xy = ab*cs;\n        vec2 e = (ab.x*ab.x-ab.y*ab.y)*vec2(1,-1)*cs*cs*cs/ab;\n        vec2 r = xy-e, q = p-e;\n        //float rm = length(r), qm = length(q);\n        //float dc = rm*asin((r.x*q.y-r.y*q.x)/(rm*qm));\n        float dc = (r.x*q.y-r.y*q.x)/length(q);\n        float dt = dc/sqrt(dot(ab,ab)-dot(xy,xy));\n        t += dt;\n        t = min(1.570796,max(0.,t));\n    }\n    vec2 q = p/ab;\n    return sign(dot(q,q)-1.)*length(p-xy);\n}\n\n\n\n\n#define res iResolution.xy\n#define AA 16\n\nvoid mainImage(out vec4 Col, in vec2 Pos) {\n    vec2 ab = vec2(1.+.8*cos(iTime),1.);\n    float SC = 7./res.x;\n    float T = iMouse.z>0.?SC*(iMouse.x-.5*res.x):1e8;\n    vec2 p0 = SC*(Pos-.5*res);\n    \n    // use AA to waste time to compare performance\n    float d = 0.;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec2 p = p0+SC*vec2(i,j)/float(AA);\n        if (p.x<T) d += sdEllipse_iter(p,ab);\n        else d += sdEllipse(p,ab);\n    }\n    d /= float(AA*AA);\n    \n    // color\n    vec3 col = vec3(.8)-sign(d)*vec3(.1,.4,.2);\n    col *= (.2*cos(60.*d)+.8)*(1.-exp(-5.*abs(d)));\n    col = mix(col,vec3(1,1,0),clamp(2.-60.*abs(d),0.,1.));\n    col = mix(col,vec3(1),clamp(2.-60.*abs(p0.x-T),0.,1.));\n    Col = vec4(col,1.0);\n}\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Ellipse distance function copy-pasted from iq\n// https://www.iquilezles.org/www/articles/ellipsedist/ellipsedist.htm\n\n\nfloat sdEllipse( in vec2 z, in vec2 ab )\n{\n    vec2 p = abs( z ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l; float m2 = m*m;\n    float n = ab.y*p.y/l; float n2 = n*n;\n    float c = (m2 + n2 - 1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 closestPoint = vec2( ab.x*co, ab.y*si );\n\t\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3tfcDf",
    "date": "0",
    "viewed": 0,
    "name": "Ellipse Distance Lagrangian",
    "description": "Find the exact distance to an ellipse using the Lagrange multiplier. The smallest root of the quartic is guaranteed the closest root.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "sdf",
     "ellipse",
     "compare"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\n// https://www.shadertoy.com/view/3lj3DW\nfloat sdEllipse_n(vec2 p0, vec2 ab){\n    vec2 r2=ab*ab;\n    vec2 p2=p0*p0;\n    float m = r2.x+r2.y;\n    float n = r2.x*r2.y;\n    float k3 = -.5*m;\n    float k2 = (m*m+2.*n-dot(r2,p2))/6.;\n    float k1 = .5*n*(p2.x+p2.y-m);\n    float k0 = n*(n-(p2.x*r2.y+p2.y*r2.x));\n    \n    // Solve[(k-a^2)^2(k-b^2)^2-a^2x0^2(k-b^2)^2-b^2y0^2(k-a^2)^2==0,k]\n    float t;\n\tfloat c2 = k2 - k3 * k3;\n\tfloat c1 = k1 + k3 * (2.0*k3*k3 - 3.0*k2);\n\tfloat c0 = (k0 + k3 * (k3*(c2 + k2)*3.0 - 4.0*k1)) / 3.;\n    \n\tfloat q = c2 * c2 + c0;\n\tfloat r = c2 * c2*c2 - 3.0*c0*c2 + c1 * c1;\n\tfloat h = r * r - q * q*q;\n\n\tif (h < 0.) {\n        return sqrt(h);\n\t\tfloat sQ = sqrt(q);\n\t\tfloat w = sQ * cos(acos(-r / (sQ*q)) / 3.0);\n\n\t\tfloat d2 = -w - c2;\n\t\tfloat d1 = sqrt(d2);\n\t\tfloat h1 = sqrt(w - 2.0*c2 + c1 / d1);\n\t\tfloat h2 = sqrt(w - 2.0*c2 - c1 / d1);\n\n\t\tfloat t0 = -d1 - h1 - k3;\n\t\tfloat t1 = -d1 + h1 - k3;\n\t\tfloat t2 = d1 - h2 - k3;\n\t\tfloat t3 = d1 + h2 - k3;\n\t\tt = min(min(t0,t1),min(t2,t3));\n        t = min(min(t0,t1),t2);\n\t}\n\telse {\n\t\th = sqrt(h);\n        float s=r+h; s=sign(s)*pow(abs(s),1./3.);\n        float u=r-h; u=sign(u)*pow(abs(u),1./3.);\n\t\tfloat x = s + u + 4.0*c2;\n\t\tfloat y = s - u;\n\t\tfloat ks = x*x + y*y*3.0;\n\t\tfloat k = sqrt(ks);\n\t\tt = -.5*y*sqrt(6./(k+x))-2.*c1*(k+x)/(ks+x*k)-k3;\n\t}\n    vec2 p = r2*p0/(r2-vec2(t));\n    return -sign(t)*length(p0-p);\n}\n\n\n\n\n#define res iResolution.xy\n#define AA 16\n\nvoid mainImage(out vec4 Col, in vec2 Pos) {\n    vec2 ab = vec2(1.+.8*cos(iTime),1.);\n    float SC = 7./res.x;\n    float T = iMouse.z>0.?SC*(iMouse.x-.5*res.x):1e8;\n    vec2 p0 = SC*(Pos-.5*res);\n    \n    // use AA to waste time to compare performance\n    float d = 0.;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec2 p = p0+SC*vec2(i,j)/float(AA);\n        if (p.x<T) d += sdEllipse_n(p,ab);\n        else d += sdEllipse(p,ab);\n    }\n    d /= float(AA*AA);\n    if (!(d>0.||d<0.)) {Col=vec4(0,0,1,1);return;}\n    \n    // color\n    vec3 col = d>0.?vec3(1,.7,.6):vec3(.5,.8,1);\n    col *= (.5+.5*clamp(.8-cos(80.*d),0.,1.))*(1.-exp(-5.*abs(d)));\n    col = mix(col,vec3(1),clamp(2.-60.*abs(d),0.,1.));\n    col = mix(col,vec3(1,1,0),clamp(3.-80.*abs(p0.x-T),0.,1.));\n    Col = vec4(col,1.0);\n}\n\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Ellipse distance function copy-pasted from iq\n// https://www.iquilezles.org/www/articles/ellipsedist/ellipsedist.htm\n\n\nfloat sdEllipse( in vec2 z, in vec2 ab )\n{\n    vec2 p = abs( z ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l; float m2 = m*m;\n    float n = ab.y*p.y/l; float n2 = n*n;\n    float c = (m2 + n2 - 1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 closestPoint = vec2( ab.x*co, ab.y*si );\n\t\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3lfyDl",
    "date": "1593380579",
    "viewed": 218,
    "name": "Numerical Gradient Comparison",
    "description": "Comparing 3d numerical differentiation methods.\n\nSeems like the tetrahedron method doesn't work much better than the naive method ~.~",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "gradient",
     "compare",
     "differen"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Comparing numerical gradient methods\n\n// I just discovered that sampling gradient on a 2d simplex \n// has an error of 1/h O(h²), so I want to know if that applies to 3d.\n\n// Left to right: reference, naive method, central difference, tetrahedron method\n\n// In the three graphs on the right:\n// Red indicates the difference in the direction of gradient;\n// Blue indicates the difference in the magnitude of gradient;\n// A brighter color represents a higher error.\n\n// In the reference graph: rgb -> xyz\n\n// Mouse control:\n// Left/Right: view rotation\n// Up/Down: numerical differentiation step\n\n// The 4-sample tetrahedron method doesn't seem to be much better\n// than the 3-sample naive method.\n\n// Using Taylor expansion, one gets: [+ 1/h O(h³)]\n\n// Naive method:        (∂F/∂x,∂F/∂y,∂F/∂z) + h/2 (∂²F/∂x²,∂²F/∂y²,∂²F/∂z²)\n// Central difference:  (∂F/∂x,∂F/∂y,∂F/∂z)\n// Tetrahedron method:  (∂F/∂x,∂F/∂y,∂F/∂z) + h (∂²F/∂y∂z,∂²F/∂x∂z,∂²F/∂x∂y)\n\n// You can uncomment the commented lines in fun() and map()\n// to see how these methods applied to a sphere and a hyperboloid.\n\n// However, you may need to change these:\n#define saturation 1.0\n#define raymch_step_sc 0.8\n\n// ======================================================================= end of story\n\n\n\n// the funny shape: F(x,y,z)=(x²+2y²+z²)³-(9x²+y²)z³-0.5\nfloat fun(in vec3 p) {\n    //return dot(p,p)-1.; // sphere\n    //return p.x*p.y+p.x*p.z+p.y*p.z+1.; // hyperboloid\n    float e = p.x*p.x+2.*p.y*p.y+p.z*p.z;\n\treturn e*e*e-(9.*p.x*p.x+p.y*p.y)*p.z*p.z*p.z-.5;\n}\n\n// return value and analytical gradient at once\nvec4 map(in vec3 p) {\n    //return vec4(2.*p,dot(p,p)-1.); // sphere\n    //return vec4(p.y+p.z,p.x+p.z,p.x+p.y,p.x*p.y+p.x*p.z+p.y*p.z+1.); // hyperboloid\n    vec3 p2 = p*p;\n    float e = p2.x+2.*p2.y+p2.z, f = 9.*p2.x+p2.y;\n    return vec4(\n        e*e*vec3(6,12,6)*p - p2.z*vec3(18.*p.x*p.z,2.*p.y*p.z,3.*f),\n        e*e*e - p2.z*p.z*f - .5);\n}\n\n\n\n// numerical differentiation step\nfloat h = 0.1;\n\n// numerical gradient method id\nint method = 0;\n\n// naive method\nvec3 grad_naive(in vec3 p){\n    float v = fun(p);\n    return (1./h)*vec3(\n        fun(p+vec3(h,0,0))-v,\n        fun(p+vec3(0,h,0))-v,\n        fun(p+vec3(0,0,h))-v);\n}\n// central difference\nvec3 grad_central(in vec3 p){\n    return (.5/h)*vec3(\n        fun(p+vec3(h,0,0))-fun(p-vec3(h,0,0)),\n        fun(p+vec3(0,h,0))-fun(p-vec3(0,h,0)),\n        fun(p+vec3(0,0,h))-fun(p-vec3(0,0,h)));\n}\n// tetrahedron method\nvec3 grad_tetrahedron(in vec3 p){\n\tfloat a = fun(p+vec3(h,h,h));\n\tfloat b = fun(p+vec3(h,-h,-h));\n\tfloat c = fun(p+vec3(-h,h,-h));\n\tfloat d = fun(p+vec3(-h,-h,h));\n\treturn (.25/h)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n\n\n// raymarching\n\nvec3 light = vec3(.3,.1,1);\nvec3 render(vec3 p, vec3 d) {\n\tfloat t = 3., dt;\n\tfor (int i = 0; i < 1024; i++) {\n        vec4 mp = map(p+t*d);\n\t\tdt = abs(mp.w) / length(mp.xyz);\n\t\tt += raymch_step_sc*dt;\n        if (dt<.001) {\n\t\t\tp += t*d;\n            vec3 grad = mp.xyz;\n            float m0 = length(grad);\n    \t\tvec3 n0 = normalize(grad);\n            vec3 col = vec3(.2*clamp(dot(n0,light),0.,1.)+.2);\n            if (method==0) return col+(n0+vec3(.5))*vec3(.4,.2,.4);\n            \n            if (method==1) grad=grad_naive(p);\n            if (method==2) grad=grad_central(p);\n            if (method==3) grad=grad_tetrahedron(p);\n            float m = length(grad);\n            vec3 n = normalize(grad);\n            \n            float ed = 10.*(1.-dot(n0,n));\n            float el = (m-m0)*(m-m0)/sqrt(m0*m0+1.);\n    \t\treturn col+vec3(ed,0,el)*saturation;\n        }\n\t\tif (t>20.) break;\n\t}\n    return vec3(.5*clamp(dot(d,light),0.,1.));\n}\n\n#define AA 2\n#define res iResolution.xy\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec3 col = vec3(0.0);\n    vec2 gd = coord.xy;\n    method = int(4.*gd.x/res.x);\n    gd.x = mod(gd.x,.25*res.x);\n    \n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec2 uv=(12./res.x)*((gd+vec2(i,j)/float(AA))-vec2(.125,.5)*res.xy);\n        vec3 pos = vec3(0,-10,0.);\n        vec3 dir = vec3(uv.x,0,uv.y)-pos;\n        float a = .3*sin(iTime);\n        mat3 R = mat3(1,0,0,0,cos(a),-sin(a),0,sin(a),cos(a));\n        if (iMouse.z>0.){\n            uv = iMouse.xy/res.xy;\n            a = 6.283*(uv.x-.5);\n            R = mat3(cos(a),-sin(a),0,sin(a),cos(a),0,0,0,1) * R;\n            a = 2.*(uv.y-.5);\n            h = 0.1+0.1*a;\n        }\n        light = R*vec3(.3,.1,1);\n        pos = R*pos, dir = R*dir;\n        col += render(pos,normalize(dir));\n    }\n    \n    color = vec4(col/float(AA*AA),1.0);\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ttByWR",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x0000001A",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec2 path[18];\nvec2 a[10], b[10];  // 10 = int(18 / 2) + 1\nvoid init() {\n\t// manual point set\n\tpath[0] = vec2(1.0137, 0.3967);\n\tpath[1] = vec2(0.5626, 0.5417);\n\tpath[2] = vec2(0.3414, -0.0639);\n\tpath[3] = vec2(0.1158, 0.6121);\n\tpath[4] = vec2(-0.7459, 0.7070);\n\tpath[5] = vec2(-0.8443, 0.1465);\n\tpath[6] = vec2(-0.3618, 0.1444);\n\tpath[7] = vec2(-0.1585, 0.4285);\n\tpath[8] = vec2(-0.3173, 0.3743);\n\tpath[9] = vec2(-0.4706, -0.2456);\n\tpath[10] = vec2(-0.7936, -0.3968);\n\tpath[11] = vec2(-0.5655, -0.1589);\n\tpath[12] = vec2(0.2119, -0.6991);\n\tpath[13] = vec2(0.2968, -0.9548);\n\tpath[14] = vec2(0.3969, -0.4136);\n\tpath[15] = vec2(0.7119, 0.0779);\n\tpath[16] = vec2(0.6283, 0.2814);\n\tpath[17] = vec2(0.7057, -0.0209);\n\n\t// calculate Fourier coefficients, b[0] is always zero\n\tfloat t, dt;\n\tfor (int k = 0; k < 10; k++) {\n\t\ta[k] = vec2(0.), b[k] = vec2(0.);\n\t\tt = 0.0, dt = 6.283185 * float(k) / 18.;\n\t\tfor (int i = 0; i < 18; i++, t += dt)\n\t\t\ta[k] += path[i] * cos(t), b[k] += path[i] * sin(t);\n\t\ta[k] = a[k] * (2.0 / 18.), b[k] = b[k] * (2.0 / 18.);\n\t}\n\ta[0] = a[0] * 0.5;\n}\n\nvec2 eval(float t) {\n\tvec2 r = a[0];\n    float c0 = cos(t), s0 = sin(t), c = c0, s = s0, c1;\n    for (int k = 1; k < 10; k++) {\n        r += a[k] * c + b[k] * s;\n        c1 = c, c = c * c0 - s * s0, s = c1 * s0 + s * c0;\n    }\n\treturn r;\n}\n\n\nfloat sdSqSegment(in vec2 p, in vec2 a, in vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tvec2 q = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn dot(q, q);\n}\nfloat sdt(vec2 p, float t){\n    vec2 q = eval(t)-p;\n    return dot(q,q);\n}\nfloat quadIntp(float t0, float tc, float t1, float d0, float dc, float d1){\n    float t02=t0*t0,t12=t1*t1,tc2=tc*tc;\n    return .5*(d0*(tc2-t12)-dc*(t02-t12)+d1*(t02-tc2))/(d0*(tc-t1)-dc*(t0-t1)+d1*(t0-tc));\n}\nfloat sd(vec2 p) {\n\tfloat o = sin(0.5*iTime); o = .04 + .005*o*o;\n\tfloat o2 = (o + .02)*(o + .02);\n\tconst float t_max = 6.283;\n    \n    // \n    int N = int(5.*t_max);\n    float dt = t_max/float(N);\n\tfloat d0 = sdt(p,0.), d1, t0=0., t1;\n\tfloat d = 1e8;\n    bool vertex=false; int mi=-1;\n\tfor (int i=1;i<=N;i++) {\n        t1=float(i)*dt;\n\t\td1 = sdt(p,t1);\n        float tc=.5*(t0+t1), dc=sdt(p,tc);\n        float tm=quadIntp(t0,tc,t1,d0,dc,d1);\n        //if (tm>t0&&tm<t1)\n        {\n            float ds=sdt(p,tm);\n            d=min(d,ds);\n            float ts=tm<tc?quadIntp(t0,tm,tc,d0,ds,dc):quadIntp(tc,tm,t1,dc,ds,d1);\n            //if (ts>t0&&ts<t1)\n                d=min(d,sdt(p,ts));\n        }\n        \n        d=min(d,d1);\n\t\td0=d1, t0=t1;\n\t}\n    \n    return sqrt(d)-o;\n\td = min(sqrt(d), abs(length(p) - 0.15));\n\treturn d - o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tinit();\n\tvec2 p = 5.0 * (fragCoord - 0.5*iResolution.xy) / length(iResolution.xy);\n\tfloat d = sd(p - vec2(-.1, .08));\n\n    // modified from iq's sdf visualizing function\n\tvec3 col = d > 0. ? vec3(1.0, 0.3, 0.5) : vec3(0.3, 1.5, 2.7);\n\tcol *= 1.0 - 0.9*exp(-6.*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.*d - 3.0*iTime);\n\tcol = mix(col, vec3(1.0), 1.0 - smoothstep(0.0, 0.02, abs(d)));\n\tfragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3dyyDz",
    "date": "0",
    "viewed": 0,
    "name": "Sound Test 0x00000004",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 a = 0.1*calcSound(0.01*uv.x+iTime);\n    float w = a.x+a.y;\n    float c = 20.0*abs(w-uv.y+0.5);\n    vec3 col = vec3(smoothstep(0.5,0.0,c));\n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\n// waveforms\n#define sinWave(f,t) sin(6.283185307*(f)*(t))\n#define triWave(f,t) (2.0*abs(2.0*fract(f*t-0.25)-1.0)-1.0)\n#define sqrWave(f,t) (fract((f)*(t))>0.5?-1.:1.)\n#define sthWave(f,t) (2.0*fract((f)*(t)-0.5)-1.0)\n\n// convert the nth key on a standard piano to wave frequency\n// middle C: n=40, f=262Hz\n#define freq(n) 440.0*exp2(((n)-49.0)/12.0)\n\n\n\n// 262Hz sine wave\nvec2 sine_wave(float t){\n    return vec2(sinWave(262.,t));\n}\n// 262Hz square wave with the same amplitude\nvec2 square_wave(float t){\n    return vec2(sqrWave(262.,t));\n}\n\n\n// sound with increasing frequency\n// no amplitude change but the loudness increases\nvec2 increase_freq(float t){\n    float f = 100.*exp(0.1*t);\n    float k = sinWave(f, t);\n    return vec2(k);\n}\nvec2 increase_freq_scale(float t){\n    float note = 40.+round(12./3.14 * acos(cos(t)));\n    float f = freq(note);\n    float k = sinWave(f,t);\n    return vec2(k);\n}\nvec2 increase_freq_keeploudness(float t){\n    float f = 100.*exp(0.1*t);\n    float m = 262./f;\n    float k = m*m*sinWave(f,t);\n    return vec2(k);\n}\n\n// 262Hz wave with decreasing amplitude\nvec2 damping(float t){\n    float amp = exp(-t);\n    float k = amp*sinWave(262., t);\n    return vec2(k);\n}\n\n\n// interference between two waves with similar frequencies\nvec2 beat(float t){\n    float k1 = sinWave(260., t);\n    float k2 = sinWave(270., t);\n    //return vec2(k1,k2);\n    return 0.5*vec2(k1+k2);\n}\n// closer frequency\nvec2 beat2(float t){\n    float k1 = sinWave(260., t);\n    float k2 = sinWave(261., t);\n    return 0.5*vec2(k1+k2);\n}\n// further frequency\nvec2 beat3(float t){\n    float k1 = sinWave(260., t);\n    float k2 = sinWave(1040., t);\n    return 0.5*vec2(k1+k2);\n}\n// increasing difference in frequencies\nvec2 beat4(float t){\n    float k1 = sinWave(freq(40.), t);\n    float k2 = sinWave(freq(40.+floor(.5*t)), t);\n    return 0.5*vec2(k1+k2);\n}\n\n\nvec2 calcSound(float time){\n    return increase_freq_keeploudness(time);\n}\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// see Common tab\n\nvec2 mainSound( in int samp,float time) {\n    return calcSound(time);\n}\n\n",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tsyyDw",
    "date": "0",
    "viewed": 0,
    "name": "Sound Test 0x00000005",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 a = 0.1*calcSound(0.01*uv.x+iTime);\n    float w = a.x+a.y;\n    float c = 20.0*abs(w-uv.y+0.5);\n    vec3 col = vec3(smoothstep(0.5,0.0,c));\n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\n// waveforms\n#define sinWave(f,t) sin(6.283185307*(f)*(t))\n#define sqrWave(f,t) (fract((f)*(t))>0.5?-.5:.5)\n#define triWave(f,t) (2.0*abs(2.0*fract(f*t-0.25)-1.0)-1.0)\n#define sthWave(f,t) (2.0*fract((f)*(t)-0.5)-1.0)\n\n// convert the nth key on a standard piano to wave frequency\n// middle C: n=40, f=262Hz\n#define freq(n) 440.0*exp2((float(n)-49.0)/12.0)\n\n\nvec2 instrument1(float f, float t, float dt){\n    float k = sinWave(f,t)+.6*sinWave(2.*f,t);\n    float u = smoothstep(0.,1.,10.*t+.5)*smoothstep(1.,0.,10.*(t-dt)+.5);\n    return vec2(k*u*exp(-t)/(.001*f));\n}\n\nvec2 instrument2(float f, float t, float dt){\n    float k = 2.*(pow(abs(sinWave(.5*f,t)),20.)+pow(abs(sinWave(.5*f,t-.3/f)),10.))-1.;\n    float u = smoothstep(0.,1.,10.*t+.5)*smoothstep(1.,0.,10.*(t-dt)+.5);\n    return vec2(k*u*exp(-t)/(.001*f));\n}\n\nvec2 instrument3(float f, float t, float dt) {\n    float k = 0.0;\n    for (float h=1.; h<6.; h++) k += sinWave(h*f,t)/pow(h,0.8);\n    k = 0.2*k + 0.2*k*k*k;\n    float u = smoothstep(0.,1.,10.*t+.5)*smoothstep(1.,0.,10.*(t-dt)+.5);\n    return vec2(k*u*exp(-t)/(.001*f));\n}\n\n#define instrument instrument3\n\nvec2 sheet1(float t){\n    vec2 amp = vec2(0.);\n    t = mod(t,12.);\n    if (t>6.) t = 12.-t;\n    for (int i=0;i<36;i++){\n        float f = freq(28+i);\n        amp += instrument(f, t-float(i)/6., 1./6.);\n    }\n    return amp;\n}\n\nvec2 sheet2(float t){\n    vec2 amp = vec2(0.);\n    t = mod(t,16./6.);\n    for (int i=0;i<16;i++){\n        int n = i<8?i:i-8;\n        n = i<8?(n==0?0:n==4?12:(n&1)==1?5:8):(n==0?0:n==4?12:(n&1)==1?3:7);\n        float f = freq(41+n);\n        amp += instrument(f, t-float(i)/6., 1./6.);\n        n = i<8?i/4:(i-8)/4;\n        n = i<8?(n==0?0:5):(n==0?0:3);\n        f = freq(29+n);\n        amp += 0.1*instrument(f, t-float(i/4)*4./6., 1./6.);\n    }\n    return amp;\n}\n\n\nvec2 calcSound(float time){\n    //return instrument2(262.,time,100.);\n    return 0.1*sheet2(time);\n}\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// see Common tab\n\nvec2 mainSound( in int samp,float time) {\n    return calcSound(time);\n}\n\n",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wdGcDV",
    "date": "1603765395",
    "viewed": 6,
    "name": "Sound Test 0x00000006",
    "description": "physics isu",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "demo"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Explore the relations between the sound frequency and the perceived loudness\n\n// See Common tab for details\n\n\n// visualization\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float w = 0.1*calcSound(0.01*uv.x+iTime);\n    float c = 20.0*abs(w-uv.y+0.5);\n    vec3 col = vec3(smoothstep(0.5,0.0,c));\n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// May have problems with some web browsers / hardwares\n// Rewind (reset time) if the waveform looks weird after a while\n\n\n// The frequency is calculated as:\n// f = 100Hz*e^(0.1*time)\n\n\n// Set `ps` to:\n\n// 0: amplitude independent to the frequency (constant amplitude)\n// 1: amplitude inversely propotional to the frequency\n// 2: amplitude inversely propotional to the square of the frequency\n// n: amplitude inversely propotional to the nth power of the frequency\n\n// The amplitude should be the same for all ps at f=262Hz (t≈10s)\n\n#define ps 1\n\n\n\nfloat calcSound(float t){\n    float freq = 100.*exp(0.1*t); // frequency\n    float amp = pow(262./freq,float(ps));  // amplitude\n    float pos = amp*sin(6.283185*freq*t);  // vibration position\n    return pos;\n}\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// see Common tab\n\nvec2 mainSound( in int samp,float time) {\n    return vec2(calcSound(time));\n}\n\n",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wltcWH",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x0000001B",
    "description": "temp",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "temp"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"spilled\" by flockaroo. https://shadertoy.com/view/MsGSRd\n// 2020-12-26 20:23:04\n\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0,uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv,float delta)\n{\n    vec2 d=vec2(delta,0);\n    return vec2(\n        getVal(uv+d.xy)-getVal(uv-d.xy),\n        getVal(uv+d.yx)-getVal(uv-d.yx)\n    )/delta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv,1.0/iResolution.y),150.0);\n    //n *= n;\n    n=normalize(n);\n    fragColor=vec4(n,1);\n    vec3 light = normalize(vec3(1,1,2));\n    float diff=clamp(dot(n,light),0.5,1.0);\n    float spec=clamp(dot(reflect(light,n),vec3(0,0,-1)),0.0,1.0);\n    spec=pow(spec,36.0)*2.5;\n    //spec=0.0;\n\tfragColor = texture(iChannel0,uv)*vec4(diff)+vec4(spec);\n\tfragColor = texture(iChannel0,uv);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGRr",
       "filepath": "/presets/tex00.jpg",
       "type": "keyboard",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 5\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n#define keyTex iChannel3\n#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(\n            texture(iChannel0,fract((pos+p)/Res.xy)).xy - vec2(0.5),\n            p.yx*vec2(1,-1));\n        p = m*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = m*p;\n        }\n        b*=2.0;\n    }\n    \n    fragColor=texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n    vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n    fragColor.xy += (0.01*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "sdf3DB",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x0000001C",
    "description": "Finally implemented a proper SPH fluid\nif you have the plugin:\nuse acceleration 4x",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "fluid",
     "particles"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Super SPH \" by michael0884. https://shadertoy.com/view/tdXBRf\n// 2021-03-22 23:47:25\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n    fragColor = texel(ch2, pi);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n#define R iResolution.xy\n#define PI 3.14159265\n\n#define dt 3.\n#define loop(i,x) for(int i = min(0, iFrame); i < x; i++)\n\n//rendering scale\n#define SC 1.\n\n#define smoothR 2.5\n#define density 0.036\n\n//sim stuff\nstruct obj\n{\n    int id; //ID\n    vec2 X; //position\n    vec2 V; //velocity\n    float Pressure; //pressure\n    float Rho; //neighbor density\n    float SScale; //smooth scale\n    float Div; //average distance to neighbors\n    vec4 Y; //additional data\n};\n    \nfloat Force(float d)\n{\n    return 0.2*exp(-0.05*d)-2.*exp(-0.5*d);\n}\n\n//40% of the buffer used for particles\n#define P 0.5\n#define SN ivec2(4, 2)\n\nivec2 N; //buffer size\nivec2 sN; //buffer single element size\nint TN; //buffer length\n\nivec2 i2xy(ivec3 sid)\n{\n    return sN*ivec2(sid.x%N.x, sid.x/N.x) + sid.yz;\n}\n\nivec3 xy2i(ivec2 p)\n{\n    ivec2 pi = p/sN;\n    return ivec3(pi.x + pi.y*N.x, p.x%sN.x, p.y%sN.y);\n}\n\nivec2 cross_distribution(int i)\n{\n    return (1<<(i/4)) * ivec2( ((i&2)/2)^1, (i&2)/2 ) * ( 2*(i%2) - 1 );\n}\n\nfloat sqr(float x)\n{\nreturn x*x + 1e-2;\n}\n\n//hash funcs\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}",
     "name": "Common",
     "description": "",
     "type": "common"
    },
    {
     "inputs": [
      {
       "id": "4dfGRn",
       "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dXGR8",
       "channel": 0
      }
     ],
     "code": "//L1 particle buffer - simulation\n//L2 directional neighbor graph 4x - sort\n\nint ID;\nobj O; //this object\n\n//sort arrays\nvec4 lnk0, lnk1;\nvec4 d0, d1;\n\n//L3\nvec4 EA[SN.x]; //element array\n\nvoid insertion_sort(float t, int id);\nobj getObj(int id); vec4 saveObj(int i);\nbool iscoincidenceEA(int id);\nvoid sort0(int idtemp, int D); void sort1(int idtemp, int D);\n\nfloat SKernel(float d, float h)\n{\n    return exp(-(d/h));\n}\n\nfloat Kernel(float d, float h)\n{\n    return exp(-sqr(d/h))/(PI*sqr(h));\n}\n\nfloat KernelGrad(float d, float h)\n{\n    return 2.*d*Kernel(d,h)/sqr(h);\n}\n\nvec2 borderF(vec2 p)\n{\n    \n    float d = min(min(p.x,p.y),min(R.x-p.x,1e10));\n    return exp(-max(d,0.)*max(d,0.))*((d==p.x)?vec2(1,0):(\n    \t\t(d==p.y)?vec2(0,1):(\n            (d==R.x-p.x)?vec2(-1,0):vec2(0,-1))));\n}\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    //4 pix per layer, 3 layers\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    int S = 3; //log2(sN.x)\n    \n    ivec2 p = ivec2(floor(pos));\n    if(any(greaterThan(p, sN*N-1))) discard;\n   \n    ivec3 sid = xy2i(p); ID = sid.x;\n    O = getObj(ID);\n    d0 = vec4(1e6); d1 = vec4(1e6);\n    lnk0 = vec4(-1); lnk1 = vec4(-1);\n    \n    switch(sid.z)\n    {\n    case 0: //particle\n        if(sid.z >= 3) discard;\n        float sk = 0.;\n        \n        //scale /=sk;\n        vec2 F =1e-3*vec2(0.,-1.);//-0.001*(O.X - R*0.5)/(pow(length(O.X - R*0.5),1.)+1.); \n        vec2 Fp = vec2(0);\n        float avgP = 0.;\n     \n         float scale = 0.21/density; //radius of smoothing\n        float Div = 0.;\n        float Rho = Kernel(0., scale);\n           vec2 avgV = vec2(O.V)*Rho;\n        vec3 avgCol = vec3(O.Y.xyz);\n        float Gsum = 1.;\n        float curscale = 1e10;\n        float avgSc = 0.;\n        \n        loop(j,4)\n        {\n            vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n            loop(i,4)\n            {\n                if(nb[i] < 0. || nb[i] > float(TN)) continue;\n                obj nbO = getObj(int(nb[i]));\n                \n               \n                float d = distance(O.X, nbO.X);\n                vec2 dv = (nbO.V - O.V); //delta velocity\n                vec2 dx = (nbO.X - O.X); //delta position \n                vec2 ndir = dx/(d+0.001); //neighbor direction\n                //SPH smoothing kernel\n                float K = Kernel(d, scale);\n                float dK = KernelGrad(d, scale);\n               \n                //Gkernel\n                float G = 1./(d*d+0.01);\n                float dotv = dot(ndir, dv); //divergence\n                vec2 pressure = -(nbO.Pressure/sqr(nbO.Rho) + \n                                    O.Pressure/sqr(O.Rho))*ndir*K;//pressure gradient\n                curscale = min(curscale, d);\n                Gsum += 1.;\n                Div += dotv*K; // local divergence\n                Rho += K;\n                avgCol += nbO.Y.xyz;\n                avgP += nbO.Pressure*K;\n                avgV += nbO.V*K;\n                vec2 viscosity = 1.4*(3. + 3.*length(dv))*ndir*dotv*K;\n                F += pressure + viscosity;\n                Fp -= ndir*SKernel(d,scale);\n            }\n        }\n        \n         //border conditions\n        vec2 bdf = borderF(O.X);\n        F += 0.5*bdf*abs(dot(bdf, O.V));\n       // Fp += 0.*bdf*dot(bdf, O.V);\n        \n        if(R.x - O.X.x < 2.) O.V.x = -abs(O.V.x);\n        if(O.X.x < 2.) O.V.x = abs(O.V.x);\n        //if(R.y - O.X.y < 2.) O.V.y = -abs(O.V.y);\n        if(O.X.y < 2.) O.V.y = abs(O.V.y);\n        \n        \n        if(iMouse.z > 0.) \n        {\n            float d = distance(iMouse.xy, O.X);\n            O.Y.xyz +=(0.5+0.5*sin(vec3(1,2,3)*iTime))/(0.2*d*d+2.);\n            F += 0.01*(iMouse.xy - iMouse.zw)/(0.2*d*d+2.);\n        }\n        \n        O.Rho = Rho;\n        O.Div = Div; //average distance\n        O.SScale = avgSc/Gsum; //average average distance\n        \n        float r = 7.;\n        float D = 1.;\n        float waterP = 0.035*density*(pow(abs(O.Rho/density), r) - D);\n        float gasP = 0.03*O.Rho;\n        O.Pressure = min(waterP,0.04);\n        if(iFrame > 20) O.Pressure += 0.*(avgP/O.Rho - O.Pressure);\n        \n        \n        O.V += F*dt;\n        O.V -= O.V*(0.5*tanh(8.*(length(O.V)-1.5))+0.5);\n        O.X += (O.V)*dt + 0.*Fp; //advect\n        \n        \n        \n        \n        \n        //color diffusion\n        \n        O.Y.xyz = 0.995*mix(avgCol/Gsum, O.Y.xyz,0.995)\n        + 0.01*(exp(-0.1*distance(O.X,R*0.3))*(0.5*sin(vec3(1,2,3)*iTime)+0.5)\n             + exp(-0.1*distance(O.X,R*0.7))*(0.5*sin(vec3(2,3,1)*iTime))+0.5);\n        \n        \n        \n        if(iFrame<10)\n        {\n            O.X = R*vec2(i2xy(ivec3(ID,0,0)))/vec2(N*sN);\n            O.X += 0.*sin(10.*O.X.x/R.x)*sin(10.*O.X.y/R.y);\n\t\t\tO.V = 0.*(hash22(3.14159*pos) - 0.5);\n            O.Y = texture(ch1,O.X/R);\n            O.Pressure = 0.;\n            O.Div = 0.;\n            O.Rho = 5.;\n            O.SScale = 1.;\n        }\n\n        Q = saveObj(sid.y);\n        return;\n        \n    case 1: //dir graph\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = texel(ch0, i2xy(ivec3(ID, sid.y, 1)));\n        \n        //random sorts\n        loop(i,8) sort0(int(float(TN)*hash13(vec3(iFrame, ID, i))), sid.y);\n        \n        loop(i,4)\n        {\n            sort0(int(nb0[i]), sid.y);  //sort this\n            //use a sudorandom direction of the neighbor\n            vec4 nb1 = texel(ch0, i2xy(ivec3(nb0[i], (iFrame+ID)%4, 1)));\n            loop(j,2)\n            {\n                sort0(int(nb1[j]), sid.y);  \n            }\n        }\n        \n        \n        \n        Q = lnk0;\n        return;\n    }\n     \n}\n\nvec4 saveObj(int i)\n{\n    switch(i)\n    {\n    case 0:  \n        return vec4(O.X, O.V);\n    case 1:\n        return vec4(O.Pressure, O.Rho, O.SScale, O.Div);\n    case 2:\n        return O.Y;\n    case 3:\n        return vec4(0.);\n    }\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xy; o.V = a.zw;\n    \n    a = texel(ch0, i2xy(ivec3(id, 1, 0))); \n    o.Pressure = a.x;\n    o.Rho = a.y;\n    o.SScale = a.z;\n    o.Div = a.w;\n    \n    o.Y = texel(ch0, i2xy(ivec3(id, 2, 0)));\n    \n    o.id = id;\n    return o;\n}\n\nvoid insertion_sort(float t, int id)\n{\n\tif(d0.x > t)\n    {\n        d0 = vec4(t, d0.xyz);\n        lnk0 = vec4(id, lnk0.xyz);\n    }else if(d0.y > t && d0.x < t)\n    {\n        d0.yzw = vec3(t, d0.yz);\n        lnk0.yzw = vec3(id, lnk0.yz);\n    }else if(d0.z > t&& d0.y < t)\n    {\n        d0.zw = vec2(t, d0.z);\n        lnk0.zw = vec2(id, lnk0.z);\n    }else if(d0.w > t && d0.z < t)\n    {\n        d0.w = t;\n        lnk0.w = float(id);\n    }\n}\n\nbool iscoincidence(int id)\n{\n    return (id < 0) || \n      \t\t(id == ID) ||\n           any(equal(lnk0,vec4(id)));\n}\n\nvoid sort0(int idtemp, int D) //sort closest objects in sN.x directions\n{\n    if(iscoincidence(idtemp)) return; //particle already sorted\n    \n    vec2 nbX = texel(ch0, i2xy(ivec3(idtemp, 0, 0))).xy; \n   \n    vec2 dx = nbX - O.X;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n    \n    if(dir != D) return; //not in this sector\n    \n    float t = length(dx);\n   \n    insertion_sort(t, idtemp);\n}",
     "name": "Buffer A",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "XsXGR8",
       "channel": 0
      }
     ],
     "code": "//voronoi particle tracking + graph augmented\n\nvec2 sc(vec2 p)\n{\n    return SC*(p - 0.5*R) + 0.5*R;\n}\n\nfloat d;\nint id;\nvec2 p;\n\nfloat particleDistance(int i)\n{\n    return distance(p, sc(texel(ch0, i2xy(ivec3(i, 0, 0))).xy));\n}\n\nvoid sort(int utemp)\n{\n    if(utemp < 0) return; \n   \tfloat dtemp = particleDistance(utemp);\n    if(dtemp < d) //sorting\n    {\n        d = dtemp;\n        id = utemp;\n    }\n}\n\n\nvoid mainImage( out vec4 Q, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    d = 1e10;\n    id = 1;\n    p = pos;\n    ivec2 pi = ivec2(floor(pos));\n    \n    sort(1+0*int(texel(ch1, pi).x));\n    \n   int ID = id;\n    loop(j,8)\n    {\n        \n        int nbid = int(texel(ch1, pi+cross_distribution(j)).x);\n        sort(nbid);\n    }\n    \n    loop(j,4)\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        loop(i,4)\n    \t{ \n            sort(int(nb[i]));  //sort this\n        }\n    }\n    \n    loop(i,5) //random sort\n    {\n        sort(int(float(TN)*hash13(vec3(iFrame, pi.x, pi.y*i))));\n    }\n    \n   \tQ = vec4(id, d, 0, 0);\n}",
     "name": "Buffer B",
     "description": "",
     "type": "buffer"
    },
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XsXGR8",
       "filepath": "/media/previz/buffer01.png",
       "type": "buffer",
       "channel": 1,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sXGR8",
       "filepath": "/media/previz/buffer02.png",
       "type": "buffer",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4sXGR8",
       "channel": 0
      }
     ],
     "code": "vec2 sc(vec2 p)\n{\n    return SC*(p - 0.5*R) + 0.5*R;\n}\n\n// iq's smooth HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nobj getObj(int id)\n{\n    obj o;\n    \n    vec4 a = texel(ch0, i2xy(ivec3(id, 0, 0))); \n    o.X = a.xy; o.V = a.zw;\n    \n    a = texel(ch0, i2xy(ivec3(id, 1, 0))); \n    o.Pressure = a.x;\n    o.Rho = a.y;\n    o.SScale = a.z;\n    o.Div = a.w;\n    \n    o.Y = texel(ch0, i2xy(ivec3(id, 2, 0)));\n    \n    o.id = id;\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    sN = SN; \n    N = ivec2(R*P/vec2(sN));\n    TN = N.x*N.y;\n    ivec2 pi = ivec2(floor(pos));\n    \n    int ID = int(texel(ch1, pi).x); \n    obj O = getObj(ID);\n    float d =distance(pos, sc(O.X));\n    float d1 = exp(-sqr(d/1.)) +  0.*exp(-0.1*d);\n    float d2 = 10.*O.Y.x;\n   \n    /*loop(j,4)\n    {\n        vec4 nb = texel(ch0, i2xy(ivec3(ID, j, 1)));\n        loop(i,4)\n    \t{\n            if(nb[i] < 0.) continue;\n            vec2 nbX = texel(ch0, i2xy(ivec3(nb[i], 0, 0))).xy; \n        \td1 += exp(-0.5*distance(pos, sc(nbX)));\n    \t}\n    }*/\n    d1*=1.;\n    // Output to screen\n \tvec3 pcol = texel(ch2, pi).xyz;\n    vec3 ncol = 0.*sin(vec3(1,2,3)*d2*0.3)*d1 + hsv2rgb(vec3(atan(O.V.x,O.V.y)/PI, 2.*length(O.V),20.*length(O.V)))*d1;\n    fragColor = vec4(mix(pcol,ncol,0.5),1.0);\n}",
     "name": "Buffer C",
     "description": "",
     "type": "buffer"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "sdsSDr",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x0000001D",
    "description": "raytracing test",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "raytracing",
     "specular"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// https://harry7557558.github.io/Graphics/UI/webgl_test/webgl_test_02.html\n\n#define ZERO min(int(iTime),0)\n\nconst vec3 light = normalize(vec3(0, 0, 1));\n\nbool intersect_sphere(vec3 ce, float r, in vec3 ro, in vec3 rd, out float t, out vec3 n) {\n    vec3 p = ro-ce;\n    float b = dot(p,rd), c = dot(p,p)-r*r;\n    float delta = b*b-c; if (delta<=0.0) return false;\n    delta = sqrt(delta);\n    t = -b-delta; if (t<=0.0) t = -b+delta;\n    if (t<=0.0) return false;\n    n = (p+rd*t)/r; return true;\n}\n\nbool intersect_rod(vec3 pa, vec3 pb, float r, in vec3 ro, in vec3 rd, out float t, out vec3 n) {\n    vec3 ab = pb-pa, p = ro-pa;\n    float ab2 = dot(ab, ab), abrd = dot(ab, rd), abp = dot(ab, p);\n    float a = ab2 - abrd*abrd;\n    float b = ab2*dot(p,rd) - abp*abrd;\n    float c = ab2*dot(p,p) - abp*abp - r*r*ab2;\n    float delta = b*b-a*c; if (delta<=0.0) return false;\n    delta = sqrt(delta);\n    t = (-b-delta)/a;\n    if (t>0.0) {\n        float h = abp+t*abrd;\n        if (h>0.0 && h< ab2) {\n            n = (p+rd*t-ab*h/ab2)/r;\n            return true;\n        }\n    }\n    t = (-b+delta)/a;\n    if (t>0.0) {\n        float h = abp+t*abrd;\n        if (h>0.0 && h< ab2) {\n            n = (p+rd*t-ab*h/ab2)/r;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 traceRay(vec3 ro, vec3 rd) {\n    \n    const float R = 0.2, r = 0.1;\n    const float rt3_2 = 0.8660254037844386;\n\n    vec3 t_col = vec3(1.0), f_col;\n\n    for (int i = ZERO; i < 8; i++) {\n        ro += 1e-3*rd;\n        float min_t = 1e+12, t;\n        vec3 min_n = vec3(0.0), n;\n\n        // intersect with the plane\n        t = -(ro.z+(rt3_2+R))/rd.z;\n        if (t > 0.0) {\n            min_t = t;\n            f_col = vec3(0.5, 0.8, 1.0);\n            vec2 p = ro.xy+rd.xy*t;\n            if (mod(floor(p.x)+floor(p.y),2.0)==0.0) f_col*=0.99;\n            min_n = vec3(0, 0, 1);\n        }\n\n        // intersect with balls\n        if (intersect_sphere(vec3(0, 0, 0), R, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = vec3(1.0);\n        }\n        if (intersect_sphere(vec3(1, 0, 0), R, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = vec3(1.0);\n        }\n        if (intersect_sphere(vec3(0, 1, 0), R, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = vec3(1.0);\n        }\n        if (intersect_sphere(vec3(0.5, -0.5, rt3_2), R, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = vec3(1.0);\n        }\n        if (intersect_sphere(vec3(0.5, 0.5, rt3_2), R, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = vec3(1.0);\n        }\n        if (intersect_sphere(vec3(-0.5, 0.5, rt3_2), R, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = vec3(1.0);\n        }\n        if (intersect_sphere(vec3(0.5, 0.5, -rt3_2), R, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = vec3(1.0);\n        }\n\n        // intersect with rods\n        const vec3 rod_col = vec3(1.0, 0.7, 0.75);\n        if (intersect_rod(vec3(-1, 0, 0), vec3(1, 0, 0), r, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = rod_col;\n        }\n        if (intersect_rod(vec3(0, -1, 0), vec3(0, 1, 0), r, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = rod_col;\n        }\n        if (intersect_rod(vec3(-0.5, -0.5, -rt3_2), vec3(0.5, 0.5, rt3_2), r, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = rod_col;\n        }\n        if (intersect_rod(vec3(-0.5, 0.5, -rt3_2), vec3(0.5, -0.5, rt3_2), r, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = rod_col;\n        }\n        if (intersect_rod(vec3(0.5, -0.5, -rt3_2), vec3(-0.5, 0.5, rt3_2), r, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = rod_col;\n        }\n        if (intersect_rod(vec3(-0.5, -0.5, rt3_2), vec3(0.5, 0.5, -rt3_2), r, ro, rd, t, n) && t < min_t) {\n            min_t = t, min_n = n, f_col = rod_col;\n        }\n\n        if (min_n==vec3(0.0)) break;\n\n        rd = normalize(rd), min_n = normalize(min_n);  // prevent error accumulation\n\n        ro = ro + rd*min_t;\n        rd = rd - 2.0*dot(rd, min_n)*min_n;\n        t_col *= f_col;\n    }\n\n    t_col *= max(dot(rd, light), 0.0);\n    return t_col;\n}\n\n#define AA 2\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 iRotate = vec2(0.1,-2.0);\n    float iDist = 8.0;\n    \n    iRotate.x = iMouse.z>0.?1.57*(iMouse.y/iResolution.y):0.1;\n    iRotate.y = iMouse.z>0.?-iMouse.x/iResolution.x*4.0*3.14:0.5*iTime-2.0;\n\n    float rx = iRotate.x, rz = iRotate.y;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u=vec3(-sin(rz),cos(rz),0);\n    vec3 v=cross(w,u);\n\n    vec3 ro = iDist*w;\n\n    vec3 col = vec3(0.0);\n    for (int i=ZERO;i<AA;i++) {\n        for (int j=ZERO;j<AA;j++) {\n            vec2 aVertexPosition = 2.0 * (fragCoord.xy + vec2(i,j)/float(AA)) / iResolution.xy - vec2(1.0);\n            vec3 rd = normalize(mat3(u,v,-w)*vec3(aVertexPosition*iResolution.xy,2.0*length(iResolution)));\n            col += clamp(traceRay(ro, normalize(rd)), 0.0, 1.0);\n        }\n    }\n    col /= float(AA*AA);\n\n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "sdlSDH",
    "date": "0",
    "viewed": 0,
    "name": "Untitled 0x0000001E",
    "description": ".",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "snowflake"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsX3zn",
       "filepath": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define PI 3.14159265368979\n#define ZERO min(iFrame,0)\n\nfloat sqr(vec2 x) {return dot(x,x);}\nfloat det(vec2 a, vec2 b) {return a.x*b.y-a.y*b.x;}\n\nfloat sd_segment(vec2 p, vec2 a, vec2 b) {\n\tvec2 pa = p - a, ba = b - a;\n\tfloat h = dot(pa, ba) / dot(ba, ba);\n\treturn length(pa - ba * clamp(h, 0.0, 1.0));\n}\nfloat sd_wedge(vec2 p, vec2 a, vec2 c, vec2 b) {\n\tp -= c, a -= c, b -= c;\n\tfloat da = sqr(p - a * max(dot(p, a) / dot(a, a), 0.0));\n\tfloat db = sqr(p - b * max(dot(p, b) / dot(b, b), 0.0));\n\tfloat sign = det(a, b) > 0.0 ? max(det(b, p), det(p, a)) : max(det(a, p), det(p, b));\n\treturn sqrt(min(da, db)) * (sign > 0.0 ? 1.0 : -1.0);\n}\n\nfloat hexagon(vec2 p, float r) {\n\treturn dot(vec2(0.866025404, 0.5), p) - 0.866025404*r;\n}\nfloat extrude_pyramid(vec3 p, float sdf2d, float inv_slope) {\n\treturn (sdf2d + abs(p.z)*inv_slope) / sqrt(inv_slope*inv_slope + 1.0);\n}\n\nfloat map(vec3 p0) {\n\tfloat a = abs(mod(3.0*atan(p0.y, p0.x) + 0.5*PI, PI) - 0.5*PI) / 3.0;\n\tvec3 p = vec3(length(p0.xy)*vec2(cos(a), sin(a)), p0.z);\n\ta = abs(mod(3.0*atan(p0.x, p0.y) + 0.5*PI, PI) - 0.5*PI) / 3.0;;\n\tvec3 q = vec3(length(p0.xy)*vec2(sin(a), cos(a)), p0.z);\n\n\tfloat d = 1e+12;\n\n\td = min(d, extrude_pyramid(p,\n\t\thexagon(p.xy, 0.15),\n\t\t10.0));\n\td = min(d, extrude_pyramid(p,\n\t\thexagon(p.xy, 0.1),\n\t\t2.0));\n\td = min(d, extrude_pyramid(p,\n\t\tmax(sd_wedge(p.xy, vec2(0.0, 0.0), vec2(0.0, 0.01), vec2(2.0, 0.0)), p.x - 1.25),\n\t\t1.0));\n\td = min(d, extrude_pyramid(p,\n\t\tsd_wedge(p.xy, vec2(0.2, 0.0), vec2(0.3, 0.1), vec2(0.25, 0.0)),\n\t\t3.0));\n\td = min(d, extrude_pyramid(p,\n\t\tsd_wedge(p.xy, vec2(0.3, 0.0), vec2(0.4, 0.1), vec2(0.35, 0.0)),\n\t\t3.0));\n\td = min(d, extrude_pyramid(p,\n\t\tlength(p.xy - vec2(0.45, 0.0)) - 0.04,\n\t\t2.0));\n\td = min(d, extrude_pyramid(p,\n\t\tsd_wedge(p.xy, vec2(0.48, 0.0), vec2(0.56, 0.13), vec2(0.55, 0.0)),\n\t\t3.0));\n\td = min(d, extrude_pyramid(p,\n\t\tsd_wedge(p.xy, vec2(0.5, 0.0), vec2(0.8, 0.12), vec2(1.0, 0.0)),\n\t\t5.0));\n\td = min(d, extrude_pyramid(p,\n\t\tsd_wedge(p.xy, vec2(0.9, 0.0), vec2(1.1, 0.1), vec2(1.0, 0.0)),\n\t\t3.0));\n\td = min(d, extrude_pyramid(p,\n\t\tsd_wedge(p.xy, vec2(1.1, 0.0), vec2(1.2, 0.05), vec2(1.15, 0.0)),\n\t\t3.0));\n\td = min(d, extrude_pyramid(q,\n\t\tsd_wedge(q.xy, vec2(0.0, 0.0), vec2(0.01, 0.0), vec2(0.0, 0.5)),\n\t\t1.0));\n\td = min(d, length(q - vec3(0.0, 0.18, 0.0)) - 0.02);\n\td = min(d, length(q - vec3(0.0, 0.24, 0.0)) - 0.02);\n\td = min(d, extrude_pyramid(q,\n\t\tsd_wedge(q.xy, vec2(0.0, 0.2), vec2(0.05, 0.7), vec2(0.0, 0.65)),\n\t\t3.0));\n\td = min(d, extrude_pyramid(q,\n\t\tsd_wedge(q.xy, vec2(0.0, 0.65), vec2(0.03, 0.65), vec2(0.0, 0.75)),\n\t\t3.0));\n\n\treturn d;\n}\n\n\nvec3 get_background(vec3 rd) {\n    vec3 col = (0.4+0.1*sin(iTime)+0.1*sin(0.5*iTime))\n        * vec3(0.5 + 1.0*dot(rd,vec3(0.5,0.5,-0.5))\n        + 0.6*sin(5.*rd.x)*sin(5.*rd.y)*sin(5.*rd.z)\n        + 0.3*cos(10.*rd.x)*cos(10.*rd.y)*cos(10.*rd.z)\n        + 0.2*cos(20.*rd.x)*cos(20.*rd.y)*cos(20.*rd.z)\n        + 0.05*sin(45.*rd.x)*cos(44.*rd.y)*sin(46.*rd.z));\n    //col = vec3(texture(iChannel0, rd));\n    col = vec3(1.0)-exp(-col);\n    return clamp(col * vec3(0.2,0.2,1.0), 0.0, 1.0);\n}\n\nvec3 calcCol(vec3 ro, vec3 rd) {\n    vec3 tot_col = vec3(0.0);\n    \n    float t = 0.0, d;\n    for (int i=0;i< 256;i++) {\n        d = map(ro+rd*t);\n        t += d;\n        if (d< 1e-4) break;\n        if (d>5.0) return get_background(rd);\n    }\n    const float eps = 0.001;\n    ro += rd*t;\n    //vec3 n = normalize(vec3(map(ro+vec3(eps,0,0)),map(ro+vec3(0,eps,0)),map(ro+vec3(0,0,eps)))-vec3(map(ro)));\n    vec3 n = vec3(0, 0, 1);\n    \n    vec3 refr = refract(rd, n, 1.0/1.5), refl = reflect(rd, n);\n    tot_col += 0.2*get_background(refl);\n    \n    rd = refr;\n    t = 1e-3;\n    for (int i=0;i< 64;i++) {\n        d = abs(map(ro+rd*t));\n        t += d;\n        if (d< 1e-4) break;\n        if (d>5.0) return get_background(rd);\n    }\n    tot_col += 0.8 * vec3(0.8,0.4,0.6) * exp(20.0*t);\n    tot_col += 0.8 * get_background(rd);\n    \n    return tot_col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float iDist = 6.0;\n    \n    float rx = iMouse.z>0.?1.57+1.0*(2.0*iMouse.y/iResolution.y-1.0):1.3+0.8*sin(0.1*iTime);\n    float rz = iMouse.z>0.?-iMouse.x/iResolution.x*4.0*3.14:0.2*iTime-2.0;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u=vec3(-sin(rz),cos(rz),0);\n    vec3 v=cross(w,u);\n\n    vec3 ro = iDist*w;\n\n    vec2 uv = 2.0 * gl_FragCoord.xy / iResolution.xy - vec2(1.0);\n    vec3 rd = normalize(mat3(u,v,-w)*vec3(uv*iResolution.xy,4.0*min(iResolution.x,iResolution.y)));\n    vec3 col = calcCol(ro+(iDist-2.0)*rd, rd);\n\n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "NsSSRK",
    "date": "1620523568",
    "viewed": 112,
    "name": "Mathematica Color Schemes",
    "description": "Apply least square fitting to Wolfram language color schemes.\nhttps://harry7557558.github.io/Graphics/UI/color_functions/",
    "likes": 15,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "color",
     "palette",
     "cosine",
     "polynomial",
     "leastsquare"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Wolfram Language Color Schemes (least square fitting)\n\n// Apply least square fitting to color images downloaded from\n// https://reference.wolfram.com/language/guide/ColorSchemes.html\n\n// Each color scheme is fitted to three functions:\n\n// `poly`: Polynomial functions of varying degree;\n// `trig`: Functions in the form color(x)=c₀+c₁⋅x+a₀⋅cos(π⋅x-u₀)+∑ₖ[aₖ⋅cos(2kπ⋅x-uₖ)];\n// `cosine`: Functions in the form color(t)=a+b*t+c*cos(d*t+e), inspired by iq's cosine color palette article;\n\n// Coefficients for `cosine` are computed numerically and may not be optimal. \n\n// For a better visual and a comparison of the three color functions,\n// go to https://harry7557558.github.io/Graphics/UI/color_functions/\n\n// Disclaimer: I’m not related to Wolfram in anyway. Wolfram reserves the rights of these color schemes.\n\n\n#define clp(x) clamp(x,0.,1.)\n\n\n/* ====================== polynomial color functions ====================== */\n\nvec3 AlpineColors_poly(float t) {\n  float r = ((-.4622*t+1.3045)*t-.1249)*t+.2923;\n  float g = ((.704*t-.5534)*t+.5138)*t+.36;\n  float b = ((((9.8887*t-27.3837)*t+26.4292)*t-9.1505)*t+.6797)*t+.471;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 LakeColors_poly(float t) {\n  float r = ((.1712*t-.4642)*t+.9553)*t+.2824;\n  float g = ((((2.6778*t-5.9178)*t+4.0214)*t-1.598)*t+1.6854)*t+.0398;\n  float b = (((((14.3331*t-49.92)*t+67.0375)*t-42.1675)*t+10.8375)*t+.1711)*t+.5435;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 ArmyColors_poly(float t) {\n  float r = (((1.541*t-2.8123)*t+1.7038)*t-.1004)*t+.4553;\n  float g = ((((-8.3474*t+20.6422)*t-16.9988)*t+5.4954)*t-.6404)*t+.6088;\n  float b = ((.3088*t+.1844)*t-.3162)*t+.4933;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 MintColors_poly(float t) {\n  float r = ((-.0409*t-.517)*t+1.0114)*t+.4574;\n  float g = ((-.0395*t-.3079)*t-.0154)*t+.9762;\n  float b = ((-.024*t-.5145)*t+.6901)*t+.6322;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 AtlanticColors_poly(float t) {\n  float r = ((((-11.4841*t+27.744)*t-24.019)*t+8.1684)*t-.1046)*t+.1426;\n  float g = ((((-9.5585*t+25.2482)*t-24.7983)*t+9.4515)*t-.0451)*t+.1733;\n  float b = ((((-9.0879*t+23.8016)*t-23.6116)*t+9.3791)*t-.0636)*t+.1775;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 NeonColors_poly(float t) {\n  float r = ((-.4831*t+.398)*t+.1537)*t+.7183;\n  float g = ((((((-80.4505*t+303.5468)*t-444.5506)*t+314.1646)*t-108.1716)*t+17.3104)*t-2.5901)*t+.9486;\n  float b = (((((24.2125*t-76.6195)*t+88.8459)*t-45.0026)*t+9.9107)*t-.8773)*t+.3127;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 AuroraColors_poly(float t) {\n  float r = ((((-7.4062*t+25.1392)*t-29.1402)*t+13.7546)*t-1.7482)*t+.2757;\n  float g = ((((12.7806*t-29.1753)*t+18.4877)*t-1.6536)*t-.4259)*t+.2602;\n  float b = (((-8.7225*t+17.4175)*t-10.1037)*t+2.1106)*t+.2407;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 PearlColors_poly(float t) {\n  float r = (((-4.2707*t+10.5404)*t-7.1502)*t+.9435)*t+.8928;\n  float g = (((-4.241*t+10.443)*t-7.6471)*t+1.4393)*t+.819;\n  float b = (((-6.5327*t+14.1208)*t-9.0414)*t+1.6647)*t+.7584;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 AvocadoColors_poly(float t) {\n  float r = (((((-7.603*t+27.8647)*t-38.8095)*t+23.7046)*t-4.3474)*t+.1928)*t+.0001;\n  float g = ((1.0364*t-2.339)*t+2.3265)*t-.0308;\n  float b = ((.439*t-.6321)*t+.4378)*t-.0082;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 PlumColors_poly(float t) {\n  float r = ((3.1899*t-4.9201)*t+2.6995)*t-.028;\n  float g = ((.8032*t-.4051)*t+.5155)*t-.0051;\n  float b = ((-1.9967*t+2.234)*t+.1727)*t+.0033;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BeachColors_poly(float t) {\n  float r = (((4.5546*t-6.3043)*t+1.9279)*t+.0068)*t+.8567;\n  float g = (((3.9403*t-5.4029)*t+1.1958)*t+.8023)*t+.4998;\n  float b = (((-4.6235*t+7.5264)*t-2.6001)*t+.4239)*t+.2536;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 RoseColors_poly(float t) {\n  float r = (((((-18.7367*t+56.7665)*t-60.4967)*t+25.4334)*t-3.811)*t+1.3969)*t+.1422;\n  float g = (((4.0569*t-8.7696)*t+4.8136)*t-.2871)*t+.3237;\n  float b = (((2.7654*t-5.7281)*t+2.6502)*t+.3314)*t+.0943;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 CandyColors_poly(float t) {\n  float r = ((((-7.2842*t+20.8882)*t-19.6045)*t+5.368)*t+.8857)*t+.4102;\n  float g = (((1.4925*t-4.3903)*t+4.1011)*t-.5424)*t+.2222;\n  float b = ((-2.0219*t+2.8582)*t-.3195)*t+.3518;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SolarColors_poly(float t) {\n  float r = ((.8836*t-2.29)*t+1.9664)*t+.4404;\n  float g = ((-1.156*t+1.8728)*t+.0831)*t+.0119;\n  float b = ((-.2057*t+.4673)*t-.1539)*t+.0182;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 CMYKColors_poly(float t) {\n  float r = ((((-4.8649*t+9.2096)*t-7.9046)*t+1.9496)*t+1.4165)*t+.2853;\n  float g = (((((-40.8861*t+155.9216)*t-230.654)*t+156.3065)*t-45.0102)*t+3.7689)*t+.6424;\n  float b = ((((((79.6656*t-315.6966)*t+481.3127)*t-367.3093)*t+152.3533)*t-33.5365)*t+2.4095)*t+.8792;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SouthwestColors_poly(float t) {\n  float r = ((((14.5617*t-38.0584)*t+34.3532)*t-14.0528)*t+3.1836)*t+.3685;\n  float g = (((5.873*t-14.1384)*t+9.8657)*t-1.3364)*t+.3333;\n  float b = (((((((((3855.1752*t-19742.7225)*t+43005.4825)*t-51939.1506)*t+37939.9752)*t-17096.6302)*t+4625.0787)*t-699.2215)*t+55.0072)*t-2.3372)*t+.2202;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 DeepSeaColors_poly(float t) {\n  float r = ((((((((1484.4535*t-6712.0408)*t+12619.2166)*t-12762.107)*t+7492.1673)*t-2561.4098)*t+483.8659)*t-45.8569)*t+2.3549)*t+.1463;\n  float g = ((-1.3995*t+2.6468)*t-.3472)*t+.0198;\n  float b = ((-.2288*t-.4006)*t+1.33)*t+.2902;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 StarryNightColors_poly(float t) {\n  float r = ((((5.8757*t-15.2389)*t+12.2391)*t-2.9186)*t+.9267)*t+.0804;\n  float g = ((-1.387*t+1.1807)*t+.8431)*t+.1497;\n  float b = (((2.0554*t-4.8787)*t+2.3401)*t+.6334)*t+.2099;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 FallColors_poly(float t) {\n  float r = (((-2.9878*t+4.7649)*t-1.8759)*t+.7914)*t+.2511;\n  float g = (((-4.9973*t+9.9317)*t-5.2002)*t+.6679)*t+.3795;\n  float b = ((-.3848*t+1.014)*t-.7716)*t+.3977;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SunsetColors_poly(float t) {\n  float r = ((((((60.5337*t-222.1156)*t+313.9693)*t-208.3997)*t+61.5231)*t-6.9928)*t+2.5009)*t-.0135;\n  float g = (((-2.1469*t+3.2043)*t-.9061)*t+.8346)*t-.0015;\n  float b = (((((((((-1575.933*t+6907.4057)*t-12010.6555)*t+9877.5126)*t-2684.9895)*t-1738.6497)*t+1736.5118)*t-585.9981)*t+76.1077)*t-.325)*t+.0156;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 FruitPunchColors_poly(float t) {\n  float r = (((-3.1084*t+7.2032)*t-4.6225)*t+.4984)*t+.9888;\n  float g = (((3.2033*t-4.4476)*t+.3453)*t+.7848)*t+.4941;\n  float b = (((-5.6639*t+7.5443)*t-1.4725)*t+.0901)*t-.0007;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 ThermometerColors_poly(float t) {\n  float r = (((3.7541*t-9.0102)*t+4.8597)*t+.7785)*t+.1534;\n  float g = (((5.7373*t-10.5725)*t+2.5724)*t+2.2452)*t+.0972;\n  float b = ((1.6341*t-3.8711)*t+1.6136)*t+.7706;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 IslandColors_poly(float t) {\n  float r = (((7.0516*t-18.0738)*t+14.4758)*t-3.5973)*t+.803;\n  float g = ((.651*t-2.3608)*t+2.1193)*t+.3681;\n  float b = ((((7.1244*t-18.7807)*t+19.1946)*t-11.8685)*t+4.4668)*t+.1735;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 WatermelonColors_poly(float t) {\n  float r = (((-2.9967*t+4.7848)*t-2.6446)*t+1.6353)*t+.0849;\n  float g = (((-1.9825*t+2.0046)*t-1.9518)*t+2.1672)*t+.0845;\n  float b = (((((9.6424*t-27.1756)*t+24.2143)*t-8.874)*t+1.7496)*t+.6718)*t+.0965;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BrassTones_poly(float t) {\n  float r = (((((((((8254.3755*t-42237.4083)*t+91660.1592)*t-109657.3302)*t+78683.5823)*t-34519.7874)*t+9061.5885)*t-1347.7158)*t+104.1595)*t-1.6052)*t+.1594;\n  float g = (((((((((7467.1378*t-38207.4039)*t+82905.7547)*t-99160.0645)*t+71113.857)*t-31163.8787)*t+8161.6983)*t-1208.668)*t+93.1469)*t-1.583)*t+.1697;\n  float b = (((((((-294.0439*t+1246.9052)*t-2154.1561)*t+1939.0224)*t-961.1081)*t+251.9592)*t-30.8084)*t+2.2443)*t+.025;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 GreenPinkTones_poly(float t) {\n  float r = (((((((((-2786.4735*t+12726.1106)*t-23973.9553)*t+24017.6332)*t-13822.5137)*t+4718.1078)*t-1041.7945)*t+179.9293)*t-17.496)*t+.6787)*t-.006;\n  float g = (((((((((-4390.7484*t+23124.539)*t-51437.424)*t+62740.0835)*t-45585.3544)*t+20053.9833)*t-5174.35)*t+710.4699)*t-45.749)*t+4.3777)*t+.2192;\n  float b = (((((((((-4021.1895*t+18779.8371)*t-36413.2455)*t+37839.9821)*t-22723.0856)*t+7985.6114)*t-1645.1673)*t+211.7558)*t-15.0997)*t+.7993)*t+.0151;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BrownCyanTones_poly(float t) {\n  float r = (((1.9912*t-3.0126)*t-.9066)*t+1.9475)*t+.3309;\n  float g = ((-1.0091*t-.3211)*t+1.7824)*t+.1941;\n  float b = ((-1.3287*t+.2569)*t+1.7658)*t+.0681;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 PigeonTones_poly(float t) {\n  float r = (((-4.6787*t+8.8447)*t-4.6992)*t+1.3584)*t+.1695;\n  float g = (((-3.156*t+6.4877)*t-3.9736)*t+1.4986)*t+.1483;\n  float b = ((((-5.3868*t+9.5111)*t-3.7018)*t-.6554)*t+1.0081)*t+.2085;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 CherryTones_poly(float t) {\n  float r = (((-1.4874*t+4.9772)*t-5.9293)*t+3.2596)*t+.1844;\n  float g = ((-.6178*t+2.0723)*t-.6687)*t+.2196;\n  float b = ((-.7126*t+2.19)*t-.6942)*t+.2208;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 RedBlueTones_poly(float t) {\n  float r = (((5.2848*t-9.6961)*t+3.0966)*t+.986)*t+.4624;\n  float g = ((((-5.2847*t+18.277)*t-23.1662)*t+10.2756)*t+.0291)*t+.1729;\n  float b = ((-2.2853*t+1.9941)*t+.5997)*t+.2141;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 CoffeeTones_poly(float t) {\n  float r = ((.473*t-1.0207)*t+1.1343)*t+.4066;\n  float g = (((-2.5563*t+5.866)*t-4.1417)*t+1.5245)*t+.3067;\n  float b = (((((13.0069*t-41.4835)*t+46.8638)*t-19.8454)*t+1.5664)*t+.6428)*t+.2686;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 RustTones_poly(float t) {\n  float r = (((((-26.6965*t+79.8695)*t-86.7466)*t+40.6223)*t-8.2386)*t+2.203)*t-.0214;\n  float g = (((1.7118*t-3.4326)*t+1.7217)*t+.4718)*t+.0082;\n  float b = ((.0053*t+.1568)*t-.319)*t+.1963;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 FuchsiaTones_poly(float t) {\n  float r = ((-.468*t+.0665)*t+1.2729)*t+.0948;\n  float g = (((-2.9641*t+4.8192)*t-1.8424)*t+.8082)*t+.0911;\n  float b = ((-.5469*t+.3594)*t+1.0547)*t+.1014;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SiennaTones_poly(float t) {\n  float r = ((.9332*t-2.3181)*t+1.8609)*t+.4396;\n  float g = ((-.8034*t+.9394)*t+.5587)*t+.1755;\n  float b = ((-1.3461*t+2.5043)*t-.4416)*t+.0882;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 GrayTones_poly(float t) {\n  float r = (((-2.3695*t+4.3465)*t-2.0726)*t+.916)*t+.0881;\n  float g = (((-1.8715*t+3.5473)*t-1.8514)*t+1.0035)*t+.088;\n  float b = (((-1.6544*t+3.3064)*t-2.0154)*t+1.156)*t+.0857;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 ValentineTones_poly(float t) {\n  float r = ((-.4666*t+.628)*t+.2773)*t+.5297;\n  float g = ((-.7171*t+1.526)*t-.0865)*t+.1236;\n  float b = ((-.7567*t+1.4386)*t-.0124)*t+.2132;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 GrayYellowTones_poly(float t) {\n  float r = ((-1.5713*t+1.7901)*t+.5203)*t+.1803;\n  float g = ((-2.0787*t+2.1608)*t+.4212)*t+.2188;\n  float b = (((-1.218*t-.7375)*t+1.2299)*t+.6435)*t+.294;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 DarkTerrain_poly(float t) {\n  float r = (((((-23.162*t+67.8011)*t-72.846)*t+38.6091)*t-12.5808)*t+3.2298)*t-.0316;\n  float g = (((((-30.4365*t+85.6295)*t-87.1837)*t+44.12)*t-14.8493)*t+3.7107)*t+.0308;\n  float b = (((((-31.1409*t+85.9958)*t-83.1945)*t+36.9212)*t-9.0114)*t+1.0112)*t+.4503;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 LightTerrain_poly(float t) {\n  float r = ((-1.3464*t+1.9755)*t-.2865)*t+.5392;\n  float g = ((-1.8479*t+3.2093)*t-1.2544)*t+.7753;\n  float b = ((-1.8626*t+4.125)*t-2.2288)*t+.8628;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 GreenBrownTerrain_poly(float t) {\n  float r = (((5.6637*t-9.7934)*t+4.0203)*t+1.1257)*t-.001;\n  float g = (((6.0318*t-7.7796)*t+.5409)*t+2.2681)*t-.0218;\n  float b = (((2.0523*t+1.2794)*t-5.021)*t+2.7336)*t-.0178;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SandyTerrain_poly(float t) {\n  float r = (((((11.6277*t-25.3882)*t+19.3813)*t-7.6909)*t+.8571)*t+.8688)*t+.6525;\n  float g = (((((15.2926*t-48.5603)*t+63.2318)*t-42.4573)*t+12.7141)*t-.1831)*t+.3282;\n  float b = (((1.7612*t-3.2498)*t+1.3671)*t+.0933)*t+.2139;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BrightBands_poly(float t) {\n  float r = (((((((((8998.8583*t-49148.5979)*t+113169.766)*t-142764.1957)*t+107280.4242)*t-48843.9544)*t+13047.9439)*t-1836.6485)*t+96.2916)*t+.2077)*t+.8784;\n  float g = (((((((((-6544.3325*t+27440.9056)*t-46329.6516)*t+39629.1458)*t-17242.5062)*t+2843.1945)*t+332.9976)*t-126.6414)*t-7.4364)*t+4.9893)*t+.0552;\n  float b = (((((((((-17547.6824*t+76171.838)*t-135233.3159)*t+125335.9495)*t-63345.4239)*t+15640.6153)*t-520.9382)*t-618.847)*t+121.0207)*t-3.0992)*t+.255;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 DarkBands_poly(float t) {\n  float r = (((((((((20520.3381*t-97309.7443)*t+195239.1345)*t-216386.7528)*t+145275.046)*t-61042.3498)*t+16058.8484)*t-2591.3151)*t+250.8522)*t-13.9418)*t+.8142;\n  float g = (((((((((13309.4153*t-56888.8281)*t+97883.5556)*t-85126.8126)*t+37253.5854)*t-5613.9766)*t-1317.2487)*t+549.3605)*t-47.6141)*t-1.4492)*t+.8927;\n  float b = (((((((((13552.2468*t-77124.4239)*t+185770.9488)*t-246696.4601)*t+197022.6538)*t-96790.4391)*t+28694.9819)*t-4821.233)*t+406.6765)*t-15.7224)*t+1.0781;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 Aquamarine_poly(float t) {\n  float r = ((2.6585*t-3.7732)*t+1.099)*t+.6663;\n  float g = ((1.6239*t-2.4244)*t+.8204)*t+.7256;\n  float b = ((1.3883*t-1.781)*t+.4094)*t+.8449;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 Pastel_poly(float t) {\n  float r = ((((5.2009*t-13.1895)*t+10.3882)*t-3.8203)*t+1.0842)*t+.7443;\n  float g = ((((11.3496*t-28.7271)*t+24.2837)*t-8.6129)*t+1.9676)*t+.4536;\n  float b = ((((((81.1379*t-335.7778)*t+549.8404)*t-459.1507)*t+208.0687)*t-47.4446)*t+3.3375)*t+.8986;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BlueGreenYellow_poly(float t) {\n  float r = ((.4391*t+.7429)*t-.3715)*t+.1259;\n  float g = ((.4035*t-1.4246)*t+1.931)*t-.0115;\n  float b = ((.7818*t-1.8058)*t+.9888)*t+.3849;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 Rainbow_poly(float t) {\n  float r = (((((33.1682*t-100.819)*t+116.5922)*t-68.1086)*t+23.5624)*t-4.0345)*t+.5004;\n  float g = (((((39.9235*t-129.2811)*t+161.5151)*t-98.6707)*t+27.9692)*t-1.4611)*t+.1237;\n  float b = (((((32.0783*t-103.1114)*t+118.4876)*t-53.2624)*t+3.2454)*t+2.1766)*t+.516;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 DarkRainbow_poly(float t) {\n  float r = ((((((-142.7682*t+504.7613)*t-673.8783)*t+417.3468)*t-119.8578)*t+15.5088)*t-.6262)*t+.2451;\n  float g = (((((((-295.4882*t+1082.7516)*t-1527.3968)*t+1039.6297)*t-348.4437)*t+47.7262)*t+1.4318)*t-.2983)*t+.3454;\n  float b = ((((22.3956*t-58.3336)*t+52.199)*t-17.6266)*t+1.0502)*t+.5638;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 TemperatureMap_poly(float t) {\n  float r = ((((((73.3388*t-260.9259)*t+359.9373)*t-234.9464)*t+67.8889)*t-6.3532)*t+1.7211)*t+.1696;\n  float g = (((((((((3485.2098*t-18023.2923)*t+39456.71)*t-47558.8722)*t+34370.0882)*t-15199.1139)*t+4025.5905)*t-602.6056)*t+45.9028)*t+.1792)*t+.3085;\n  float b = (((((((((-4137.3382*t+21576.6987)*t-47304.9115)*t+56646.4862)*t-40360.5338)*t+17540.4075)*t-4608.7472)*t+701.0157)*t-55.8117)*t+1.986)*t+.9185;\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 LightTemperatureMap_poly(float t) {\n  float r = ((((((-61.3907*t+194.8151)*t-231.6686)*t+128.1464)*t-34.7571)*t+3.9043)*t+1.6238)*t+.1561;\n  float g = ((.1405*t-2.9854)*t+2.93)*t+.2676;\n  float b = ((((((((-1033.7746*t+4810.3542)*t-9316.0651)*t+9689.002)*t-5820.2607)*t+2024.9855)*t-392.1307)*t+38.5609)*t-1.4433)*t+.9519;\n  return vec3(clp(r),clp(g),clp(b));\n}\n\n\n/* ====================== trigonometric series color functions ====================== */\n\nvec3 AlpineColors_trig(float x) {\n  float r = .388+.512*x+.181*cos(3.142*x+2.181);\n  float g = .199+.976*x+.199*cos(3.142*x+.662);\n  float b = -.512+2.345*x+.963*cos(3.142*x+.199)+.226*cos(6.283*x+1.363);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 LakeColors_trig(float x) {\n  float r = .247+.739*x+.063*cos(3.142*x-.917);\n  float g = -.182+1.301*x+.32*cos(3.142*x-.825)+.058*cos(6.283*x+1.498);\n  float b = .468+.592*x+.179*cos(3.142*x-.667)+.06*cos(6.283*x-2.996)+.021*cos(12.566*x+2.472);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 ArmyColors_trig(float x) {\n  float r = .947-.552*x+.451*cos(3.142*x+2.811)+.108*cos(6.283*x-2.077);\n  float g = 1.304-1.217*x+.7*cos(3.142*x+2.945)+.181*cos(6.283*x-1.622);\n  float b = 1.051-.861*x+.551*cos(3.142*x+2.71)+.115*cos(6.283*x-1.862);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 MintColors_trig(float x) {\n  float r = .474+.436*x+.14*cos(3.142*x-1.635);\n  float g = .99-.38*x+.089*cos(3.142*x-1.67);\n  float b = .644+.141*x+.133*cos(3.142*x-1.611);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 AtlanticColors_trig(float x) {\n  float r = 1.607-2.72*x+1.547*cos(3.142*x-2.941)+.28*cos(6.283*x-1.388);\n  float g = 1.575-2.507*x+1.453*cos(3.142*x-2.883)+.236*cos(6.283*x-1.572);\n  float b = 1.633-2.506*x+1.51*cos(3.142*x-2.895)+.23*cos(6.283*x-1.544);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 NeonColors_trig(float x) {\n  float r = .83-.148*x+.135*cos(3.142*x-2.509);\n  float g = 1.636-2.115*x+.729*cos(3.142*x+2.815)+.088*cos(6.283*x-1.428)+.036*cos(12.566*x-2.08);\n  float b = .532-.185*x+.339*cos(3.142*x+2.888)+.123*cos(6.283*x-.801);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 AuroraColors_trig(float x) {\n  float r = 1.176-.831*x+.83*cos(3.142*x+2.616)+.257*cos(6.283*x-2.45);\n  float g = .036+.564*x+.317*cos(3.142*x-.493)+.248*cos(6.283*x+1.791);\n  float b = .017+.711*x+.26*cos(3.142*x-1.555)+.235*cos(6.283*x+.008);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 PearlColors_trig(float x) {\n  float r = .111+1.453*x+.701*cos(3.142*x+.168)+.105*cos(6.283*x+.473);\n  float g = .159+1.111*x+.562*cos(3.142*x-.105)+.111*cos(6.283*x+.216);\n  float b = .069+1.266*x+.543*cos(3.142*x-.288)+.182*cos(6.283*x+.31);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 AvocadoColors_trig(float x) {\n  float r = -1.482+3.952*x+1.476*cos(3.142*x+.133)+.38*cos(6.283*x+1.559)+.028*cos(12.566*x+1.368);\n  float g = -.251+1.483*x+.299*cos(3.142*x-.687);\n  float b = -.106+.439*x+.098*cos(3.142*x+.065);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 PlumColors_trig(float x) {\n  float r = -.729+2.374*x+.71*cos(3.142*x-.046);\n  float g = -.192+1.267*x+.263*cos(3.142*x+.825);\n  float b = .453-.47*x+.48*cos(3.142*x-2.748);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BeachColors_trig(float x) {\n  float r = .325+1.524*x+.779*cos(3.142*x+.527)+.147*cos(6.283*x+3.076);\n  float g = .03+1.694*x+.623*cos(3.142*x+.36)+.116*cos(6.283*x+3.087);\n  float b = .535-.062*x+.406*cos(3.142*x-2.94)+.121*cos(6.283*x-.024);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 RoseColors_trig(float x) {\n  float r = .299+.486*x+.117*cos(3.142*x-1.852)+.109*cos(6.283*x+3.069);\n  float g = .503-.377*x+.171*cos(3.142*x-2.184)+.089*cos(6.283*x+3.038);\n  float b = .165-.021*x+.174*cos(3.142*x-1.691)+.054*cos(6.283*x+3.058);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 CandyColors_trig(float x) {\n  float r = .774-.379*x+.371*cos(3.142*x-2.605)+.154*cos(6.283*x-1.902);\n  float g = .605-.004*x+.36*cos(3.142*x+2.765)+.052*cos(6.283*x-3.058);\n  float b = .8-.375*x+.452*cos(3.142*x-3.047);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SolarColors_trig(float x) {\n  float r = .257+.951*x+.306*cos(3.142*x-.869);\n  float g = .266+.288*x+.26*cos(3.142*x+3.012);\n  float b = .062+.016*x+.06*cos(3.142*x+2.445);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 CMYKColors_trig(float x) {\n  float r = 1.548-3.031*x+1.765*cos(3.142*x-2.507)+.221*cos(6.283*x-.724);\n  float g = -1.734+3.258*x+2.223*cos(3.142*x-.534)+.851*cos(6.283*x+1.026)+.05*cos(12.566*x+.109);\n  float b = 1.389-2.952*x+1.531*cos(3.142*x-2.345)+.546*cos(6.283*x-.206)+.056*cos(12.566*x+.462);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SouthwestColors_trig(float x) {\n  float r = -1.089+2.726*x+1.514*cos(3.142*x-.434)+.337*cos(6.283*x+1.286);\n  float g = .992-.784*x+.529*cos(3.142*x+3.123)+.144*cos(6.283*x+3.137);\n  float b = -.355+2.292*x+1.067*cos(3.142*x+.711)+.312*cos(6.283*x+2.973)+.046*cos(12.566*x+.005)+.016*cos(18.85*x+.014)+.007*cos(25.133*x+2.161);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 DeepSeaColors_trig(float x) {\n  float r = -.865+2.54*x+.968*cos(3.142*x+.133)+.081*cos(6.283*x+1.016)+.025*cos(12.566*x+1.009)+.021*cos(18.85*x+1.301);\n  float g = .323+.28*x+.339*cos(3.142*x+2.74);\n  float b = .35+.599*x+.187*cos(3.142*x-1.847);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 StarryNightColors_trig(float x) {\n  float r = -.092+1.192*x+.18*cos(3.142*x-.53)+.115*cos(6.283*x+1.394);\n  float g = .469+.021*x+.379*cos(3.142*x-2.529);\n  float b = .368-.19*x+.393*cos(3.142*x-2.022);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 FallColors_trig(float x) {\n  float r = .404+.222*x+.286*cos(3.142*x-2.557)+.088*cos(6.283*x+.067);\n  float g = .272+.386*x+.009*cos(3.142*x+2.949)+.123*cos(6.283*x+.009);\n  float b = .477-.312*x+.136*cos(3.142*x+2.254);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SunsetColors_trig(float x) {\n  float r = 1.002-.806*x+.937*cos(3.142*x-2.848)+.246*cos(6.283*x-1.979);\n  float g = -.166+1.201*x+.124*cos(3.142*x-.699)+.089*cos(6.283*x+.827);\n  float b = 7.061-13.028*x+7.02*cos(3.142*x+3.092)+1.788*cos(6.283*x-1.526)+.194*cos(12.566*x-1.916)+.049*cos(18.85*x-2.292)+.015*cos(25.133*x-2.897);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 FruitPunchColors_trig(float x) {\n  float r = .666+.482*x+.261*cos(3.142*x+.185)+.072*cos(6.283*x+.1);\n  float g = .087+.841*x+.481*cos(3.142*x-.074)+.076*cos(6.283*x+3.028);\n  float b = .743-1.307*x+.97*cos(3.142*x-2.782)+.17*cos(6.283*x-.077);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 ThermometerColors_trig(float x) {\n  float r = 1.011-1.233*x+.9*cos(3.142*x-2.659)+.105*cos(6.283*x-2.117);\n  float g = .121+.077*x+.664*cos(3.142*x-1.49)+.084*cos(6.283*x-2.796);\n  float b = .428+.096*x+.501*cos(3.142*x-.759);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 IslandColors_trig(float x) {\n  float r = 2.031-2.229*x+1.09*cos(3.142*x+2.856)+.201*cos(6.283*x-2.984);\n  float g = -.421+1.871*x+.847*cos(3.142*x-.565)+.123*cos(6.283*x+1.123);\n  float b = -1.173+2.65*x+1.509*cos(3.142*x-.584)+.207*cos(6.283*x+1.087);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 WatermelonColors_trig(float x) {\n  float r = .245+.256*x+.467*cos(3.142*x-2.172)+.108*cos(6.283*x+.008);\n  float g = .418-.663*x+.956*cos(3.142*x-2.066)+.123*cos(6.283*x-.028);\n  float b = .814-1.542*x+1.128*cos(3.142*x-2.473)+.167*cos(6.283*x-.048);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BrassTones_trig(float x) {\n  float r = .978-1.276*x+.796*cos(3.142*x-2.527)+.183*cos(6.283*x-2.455)+.043*cos(12.566*x+2.614)+.018*cos(18.85*x-.696)+.017*cos(25.133*x-3.093);\n  float g = .83-1.005*x+.637*cos(3.142*x-2.484)+.156*cos(6.283*x-2.603)+.04*cos(12.566*x+2.521)+.017*cos(18.85*x-.656)+.015*cos(25.133*x-3.096);\n  float b = .28-.554*x+.504*cos(3.142*x-2.152)+.043*cos(6.283*x-1.134)+.012*cos(12.566*x+1.422)+.015*cos(18.85*x-.354);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 GreenPinkTones_trig(float x) {\n  float r = -2.248+5.087*x+2.457*cos(3.142*x-.168)+.833*cos(6.283*x+1.801)+.085*cos(12.566*x+1.321)+.01*cos(18.85*x-2.587);\n  float g = 1.323-2.151*x+1.112*cos(3.142*x-2.654)+.483*cos(6.283*x-1.783)+.032*cos(12.566*x-1.064)+.024*cos(18.85*x+2.64);\n  float b = -1.316+3.182*x+1.554*cos(3.142*x-.302)+.619*cos(6.283*x+1.822)+.056*cos(12.566*x+1.205)+.019*cos(18.85*x-2.531);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BrownCyanTones_trig(float x) {\n  float r = .112+.45*x+.534*cos(3.142*x-1.153);\n  float g = .491-.278*x+.691*cos(3.142*x-2.124)+.07*cos(6.283*x-.394);\n  float b = .601-.427*x+.746*cos(3.142*x-2.41)+.061*cos(6.283*x-.967);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 PigeonTones_trig(float x) {\n  float r = .72-.517*x+.673*cos(3.142*x-2.916)+.166*cos(6.283*x-.687);\n  float g = .568-.146*x+.497*cos(3.142*x-2.923)+.134*cos(6.283*x-.864);\n  float b = .655-.321*x+.563*cos(3.142*x-2.921)+.163*cos(6.283*x-.847);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 CherryTones_trig(float x) {\n  float r = -.408+1.868*x+.664*cos(3.142*x-.658)+.074*cos(6.283*x+.212);\n  float g = .341+.514*x+.309*cos(3.142*x+2.032);\n  float b = .363+.469*x+.314*cos(3.142*x+2.1);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 RedBlueTones_trig(float x) {\n  float r = -.186+1.151*x+.811*cos(3.142*x-.463)+.142*cos(6.283*x+2.33);\n  float g = 1.249-1.858*x+1.086*cos(3.142*x-2.732)+.163*cos(6.283*x-2.135);\n  float b = .737-.701*x+.616*cos(3.142*x-2.543);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 CoffeeTones_trig(float x) {\n  float r = .277+.715*x+.196*cos(3.142*x-1.224)+.05*cos(6.283*x-.153);\n  float g = .118+.933*x+.154*cos(3.142*x-.647)+.073*cos(6.283*x-.119);\n  float b = -.123+1.359*x+.333*cos(3.142*x+.43)+.083*cos(6.283*x-.343);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 RustTones_trig(float x) {\n  float r = .018+.905*x+.269*cos(3.142*x-1.772)+.011*cos(6.283*x-1.846)+.022*cos(12.566*x-.025);\n  float g = .058+.452*x+.03*cos(3.142*x-1.911)+.041*cos(6.283*x-3.104);\n  float b = .193-.155*x+.04*cos(3.142*x+1.542);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 FuchsiaTones_trig(float x) {\n  float r = .206+.665*x+.186*cos(3.142*x-2.168);\n  float g = .152+.539*x+.184*cos(3.142*x-2.488)+.086*cos(6.283*x+.228);\n  float b = .228+.626*x+.165*cos(3.142*x-2.404);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SiennaTones_trig(float x) {\n  float r = .245+.889*x+.305*cos(3.142*x-.818);\n  float g = .357+.339*x+.191*cos(3.142*x-2.797);\n  float b = .38+.12*x+.323*cos(3.142*x+2.769);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 GrayTones_trig(float x) {\n  float r = .074+.728*x+.067*cos(3.142*x-2.376)+.064*cos(6.283*x+.119);\n  float g = .061+.784*x+.055*cos(3.142*x-2.002)+.051*cos(6.283*x+.078);\n  float b = .025+.821*x+.082*cos(3.142*x-1.403)+.049*cos(6.283*x+.057);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 ValentineTones_trig(float x) {\n  float r = .634+.233*x+.105*cos(3.142*x-2.985);\n  float g = .277+.406*x+.194*cos(3.142*x+2.54);\n  float b = .377+.335*x+.184*cos(3.142*x+2.726);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 GrayYellowTones_trig(float x) {\n  float r = .534+.045*x+.376*cos(3.142*x-2.768);\n  float g = .689-.413*x+.517*cos(3.142*x-2.678);\n  float b = .997-1.658*x+1.04*cos(3.142*x-2.436)+.091*cos(6.283*x-.185);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 DarkTerrain_trig(float x) {\n  float r = -.096+1.159*x+.07*cos(3.142*x+.46)+.173*cos(6.283*x-1.572)+.024*cos(12.566*x-.787);\n  float g = -.016+1.058*x+.103*cos(3.142*x+1.144)+.269*cos(6.283*x-1.574)+.031*cos(12.566*x-.719);\n  float b = 1.314-.929*x+.996*cos(3.142*x+2.413)+.42*cos(6.283*x-1.854)+.033*cos(12.566*x-1.018);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 LightTerrain_trig(float x) {\n  float r = .836-.25*x+.299*cos(3.142*x-3.102);\n  float g = 1.177-.708*x+.424*cos(3.142*x+2.892);\n  float b = 1.373-.879*x+.631*cos(3.142*x+2.385)+.05*cos(6.283*x-2.97);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 GreenBrownTerrain_trig(float x) {\n  float r = -.456+2.198*x+.593*cos(3.142*x+.15)+.153*cos(6.283*x+2.825);\n  float g = -.72+2.757*x+.875*cos(3.142*x+.189)+.162*cos(6.283*x-3.03);\n  float b = -1.619+4.383*x+1.686*cos(3.142*x+.155)+.116*cos(6.283*x+2.243);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SandyTerrain_trig(float x) {\n  float r = .856-.492*x+.237*cos(3.142*x-1.829)+.115*cos(6.283*x+3.084)+.026*cos(12.566*x-2.294);\n  float g = .956-.856*x+.46*cos(3.142*x-2.901)+.187*cos(6.283*x-2.624)+.022*cos(12.566*x-3.008);\n  float b = -.238+.949*x+.478*cos(3.142*x-.063)+.09*cos(6.283*x+2.03);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BrightBands_trig(float x) {\n  float r = -15.094+28.349*x+14.303*cos(3.142*x-.183)+3.387*cos(6.283*x+1.15)+.301*cos(12.566*x+.968)+.118*cos(18.85*x+.097)+.084*cos(25.133*x+.329);\n  float g = 31.195-61.605*x+31.094*cos(3.142*x-3.125)+6.593*cos(6.283*x-1.576)+.723*cos(12.566*x-1.552)+.246*cos(18.85*x-1.496)+.111*cos(25.133*x-1.355);\n  float b = -5.6+14.722*x+7.402*cos(3.142*x+.254)+1.395*cos(6.283*x+2.297)+.335*cos(12.566*x+2.606)+.09*cos(18.85*x-2.44)+.075*cos(25.133*x+1.97);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 DarkBands_trig(float x) {\n  float r = -25.372+53.463*x+26.644*cos(3.142*x+.041)+5.688*cos(6.283*x+1.658)+.614*cos(12.566*x+1.508)+.243*cos(18.85*x+1.638)+.143*cos(25.133*x+2.06);\n  float g = -15.718+32.09*x+16.082*cos(3.142*x-.029)+3.459*cos(6.283*x+1.462)+.349*cos(12.566*x+1.378)+.214*cos(18.85*x+1.376)+.062*cos(25.133*x+1.487);\n  float b = 17.533-34.788*x+17.058*cos(3.142*x-3.103)+3.391*cos(6.283*x-1.454)+.303*cos(12.566*x-1.417)+.182*cos(18.85*x-1.31)+.016*cos(25.133*x-1.29);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 Aquamarine_trig(float x) {\n  float r = .078+1.156*x+.593*cos(3.142*x+.088);\n  float g = .368+.735*x+.361*cos(3.142*x+.008);\n  float b = .535+.628*x+.317*cos(3.142*x+.232);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 Pastel_trig(float x) {\n  float r = .52+.009*x+.523*cos(3.142*x-1.23)+.113*cos(6.283*x+1.097);\n  float g = -.471+2.033*x+.965*cos(3.142*x-.398)+.247*cos(6.283*x+1.404);\n  float b = -1.284+3.613*x+1.841*cos(3.142*x-.199)+.54*cos(6.283*x+.874)+.067*cos(12.566*x+.6);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BlueGreenYellow_trig(float x) {\n  float r = .011+1.004*x+.353*cos(3.142*x+1.29);\n  float g = -.091+1.088*x+.218*cos(3.142*x-1.145);\n  float b = .221+.31*x+.232*cos(3.142*x-.722);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 Rainbow_trig(float x) {\n  float r = 2.01-2.371*x+1.427*cos(3.142*x+2.85)+.147*cos(6.283*x-2.611)+.03*cos(12.566*x+3.114);\n  float g = 2.007-3.531*x+1.814*cos(3.142*x-2.908)+.29*cos(6.283*x-1.923)+.034*cos(12.566*x-3.051);\n  float b = -.15+.385*x+.767*cos(3.142*x-1.048)+.281*cos(6.283*x-.393);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 DarkRainbow_trig(float x) {\n  float r = -.032+1.237*x+.371*cos(3.142*x+.131)+.256*cos(6.283*x+1.942)+.046*cos(12.566*x-1.755);\n  float g = .258+1.012*x+.689*cos(3.142*x+.645)+.441*cos(6.283*x+2.625)+.082*cos(12.566*x-2.507)+.009*cos(18.85*x-2.116);\n  float b = -1.472+3.662*x+1.998*cos(3.142*x+.024)+.488*cos(6.283*x+1.466);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 TemperatureMap_trig(float x) {\n  float r = 1.23-1.227*x+.958*cos(3.142*x-2.875)+.227*cos(6.283*x-2.127);\n  float g = 2.512-4.882*x+2.553*cos(3.142*x-2.731)+.391*cos(6.283*x-1.308)+.035*cos(12.566*x-1.27)+.021*cos(18.85*x-.69);\n  float b = -1.384+4.044*x+2.401*cos(3.142*x-.028)+.387*cos(6.283*x+1.914)+.09*cos(12.566*x+.862)+.028*cos(18.85*x+2.287);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 LightTemperatureMap_trig(float x) {\n  float r = 1.034-1.062*x+.955*cos(3.142*x-2.715)+.165*cos(6.283*x-1.705)+.031*cos(12.566*x-1.065);\n  float g = .056+.33*x+.875*cos(3.142*x-1.433)+.089*cos(6.283*x+.194);\n  float b = -.49+2.209*x+1.485*cos(3.142*x-.14)+.271*cos(6.283*x+1.846)+.039*cos(12.566*x+1.116);\n  return vec3(clp(r),clp(g),clp(b));\n}\n\n\n/* ====================== cosine color plaettes ====================== */\n\nvec3 AlpineColors_cosine(float t) {\n  float r = .34+.562*t+.15*cos(3.468*t+1.969);\n  float g = .257+.75*t+.093*cos(4.562*t+.16);\n  float b = .431+.302*t+.173*cos(4.864*t+1.108);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 LakeColors_cosine(float t) {\n  float r = .254+.731*t+.058*cos(3.275*t-1.005);\n  float g = .132+.669*t+.25*cos(3.073*t-1.904);\n  float b = .338+.725*t+.297*cos(3.358*t-.976);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 ArmyColors_cosine(float t) {\n  float r = .43+.296*t+.017*cos(12.935*t+.408);\n  float g = .427+.427*t+.144*cos(4.132*t+.063);\n  float b = .886+2.688*t+3.539*cos(.851*t+1.682);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 MintColors_cosine(float t) {\n  float r = -.968+.087*t+1.813*cos(.817*t-.666);\n  float g = .699-.492*t+.447*cos(1.321*t-.899);\n  float b = .071+.083*t+.736*cos(1.242*t-.702);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 AtlanticColors_cosine(float t) {\n  float r = -.359-4.384*t+7.369*cos(.729*t-1.507);\n  float g = .309-.072*t+.477*cos(2.921*t-1.956);\n  float b = .464-.507*t+.749*cos(2.484*t-2.026);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 NeonColors_cosine(float t) {\n  float r = .772+.066*t+.044*cos(5.935*t+2.729);\n  float g = .832-.792*t+.139*cos(5.937*t+.756);\n  float b = .142+.513*t+.133*cos(5.692*t+.064);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 AuroraColors_cosine(float t) {\n  float r = .209+.586*t+.05*cos(10.516*t+1.428);\n  float g = .511-.234*t+.282*cos(5.461*t+2.466);\n  float b = .167+.704*t+.122*cos(7.581*t-.642);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 PearlColors_cosine(float t) {\n  float r = .721+.133*t+.197*cos(5.404*t-.179);\n  float g = .784-.07*t+.112*cos(6.567*t-.891);\n  float b = .713+.151*t+.11*cos(7.189*t-.772);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 AvocadoColors_cosine(float t) {\n  float r = .655-.2*t+.649*cos(2.755*t+2.923);\n  float g = -.678+2.051*t+.657*cos(2.279*t-.098);\n  float b = -.013+.246*t+.022*cos(5.897*t-1.248);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 PlumColors_cosine(float t) {\n  float r = -1.019+2.938*t+1.008*cos(2.766*t+.148);\n  float g = -2.843+17.04*t+30.478*cos(.544*t+1.478);\n  float b = 2.035-4.714*t+3.865*cos(1.482*t-2.124);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BeachColors_cosine(float t) {\n  float r = -40.164+87.818*t+202.129*cos(.4371*t+1.3668);\n  float g = .559+.364*t+.081*cos(7.608*t-2.555);\n  float b = .149+.801*t+.105*cos(6.822*t+.376);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 RoseColors_cosine(float t) {\n  float r = .324+.541*t+.17*cos(5.629*t-2.919);\n  float g = .482-.211*t+.17*cos(5.382*t-2.917);\n  float b = .221+.002*t+.159*cos(4.866*t-2.524);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 CandyColors_cosine(float t) {\n  float r = .43+.468*t+.213*cos(4.928*t-1.749);\n  float g = 19.473-36.595*t+79.305*cos(.474*t-1.816);\n  float b = .483+.298*t+.165*cos(4.659*t+2.531);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SolarColors_cosine(float t) {\n  float r = -.325+1.625*t+.778*cos(2.093*t-.134);\n  float g = .027+.73*t+.077*cos(5.134*t+1.925);\n  float b = .172-.13*t+.155*cos(2.134*t+3.136);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 CMYKColors_cosine(float t) {\n  float r = 21.344-109.661*t+274.797*cos(.4044*t-1.6474);\n  float g = .963-.695*t+.363*cos(6.257*t+1.694);\n  float b = .857-.536*t+.098*cos(9.08*t-1.018);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SouthwestColors_cosine(float t) {\n  float r = 2.153-26.755*t+51.145*cos(.542*t-1.604);\n  float g = .441+.304*t+.174*cos(6.236*t+2.533);\n  float b = .167+.385*t+.124*cos(11.285*t+1.021);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 DeepSeaColors_cosine(float t) {\n  float r = -.452+1.772*t+.586*cos(3.484*t+.168);\n  float g = .395+.166*t+.399*cos(2.951*t+2.859);\n  float b = .216+.37*t+.472*cos(1.93*t-1.406);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 StarryNightColors_cosine(float t) {\n  float r = .188+.741*t+.121*cos(5.253*t+2.268);\n  float g = .494-.068*t+.427*cos(2.988*t-2.477);\n  float b = .391-.019*t+.267*cos(3.939*t-2.331);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 FallColors_cosine(float t) {\n  float r = .207+.806*t+.041*cos(8.621*t-.258);\n  float g = .262+.403*t+.124*cos(6.28*t+.023);\n  float b = 6.498-7.166*t+12.763*cos(.571*t-2.069);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SunsetColors_cosine(float t) {\n  float r = .138+1.15*t+.267*cos(5.058*t-2.215);\n  float g = -.054+1.068*t+.043*cos(7.883*t+.103);\n  float b = -.065+.734*t+.322*cos(7.069*t-1.202);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 FruitPunchColors_cosine(float t) {\n  float r = .895-.02*t+.109*cos(5.773*t-.213);\n  float g = .569-.095*t+.137*cos(5.769*t-2.086);\n  float b = -.038+.685*t+.136*cos(6.989*t+1.023);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 ThermometerColors_cosine(float t) {\n  float r = .453+.122*t+.385*cos(4.177*t-2.507);\n  float g = .284+.142*t+.554*cos(4.181*t-1.918);\n  float b = .464+.05*t+.475*cos(3.217*t-.809);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 IslandColors_cosine(float t) {\n  float r = .67+.125*t+.142*cos(7.543*t+1.454);\n  float g = -8.587+7.996*t+12.196*cos(.712*t+.746);\n  float b = -35.367+32.875*t+68.157*cos(.508*t+1.022);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 WatermelonColors_cosine(float t) {\n  float r = 8.384-23.701*t+45.905*cos(.542*t-1.752);\n  float g = 6.221-56.236*t+127.225*cos(.4551*t-1.6188);\n  float b = 80.008-209.122*t+639.314*cos(.3292*t-1.696);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BrassTones_cosine(float t) {\n  float r = .16+.07*t+.727*cos(3.313*t-1.671);\n  float g = .238+.004*t+.595*cos(3.492*t-1.798);\n  float b = .118-.036*t+.312*cos(3.548*t-1.885);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 GreenPinkTones_cosine(float t) {\n  float r = .529-.054*t+.55*cos(5.498*t+2.779);\n  float g = .21+.512*t+.622*cos(4.817*t-1.552);\n  float b = .602-.212*t+.569*cos(5.266*t+2.861);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BrownCyanTones_cosine(float t) {\n  float r = .203+.373*t+.472*cos(3.367*t-1.293);\n  float g = -1.135-14.824*t+26.533*cos(.626*t-1.521);\n  float b = .587-3.096*t+3.441*cos(1.409*t-1.721);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 PigeonTones_cosine(float t) {\n  float r = .115+.864*t+.065*cos(7.663*t-.48);\n  float g = .134+.845*t+.042*cos(7.904*t-.989);\n  float b = .166+.795*t+.057*cos(7.722*t-.96);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 CherryTones_cosine(float t) {\n  float r = -33.955+52.149*t+107.832*cos(.4822*t+1.2484);\n  float g = 11.897-9.82*t+19.465*cos(.588*t-2.214);\n  float b = 13.784-12.632*t+25.214*cos(.562*t-2.139);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 RedBlueTones_cosine(float t) {\n  float r = .649-.248*t+.33*cos(4.743*t-2.171);\n  float g = .46+.013*t+.388*cos(4.495*t-2.538);\n  float b = .912-1.304*t+.961*cos(2.624*t-2.37);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 CoffeeTones_cosine(float t) {\n  float r = -2.682+4.95*t+5.693*cos(.799*t+.997);\n  float g = .32+.635*t+.04*cos(7.862*t-1.389);\n  float b = .064+.864*t+.199*cos(5.276*t-.159);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 RustTones_cosine(float t) {\n  float r = .122+1.015*t+.12*cos(5.857*t-2.927);\n  float g = .062+.473*t+.056*cos(5.844*t-2.93);\n  float b = .17-.157*t+.019*cos(5.848*t+.205);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 FuchsiaTones_cosine(float t) {\n  float r = .387-3.144*t+5.33*cos(.828*t-1.625);\n  float g = .034+.905*t+.05*cos(7.864*t-.057);\n  float b = 1.444-4.925*t+8.111*cos(.747*t-1.737);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SiennaTones_cosine(float t) {\n  float r = -.412+1.682*t+.857*cos(2.03*t-.038);\n  float g = .327+.416*t+.153*cos(3.422*t-2.907);\n  float b = .397+.093*t+.337*cos(3.09*t+2.801);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 GrayTones_cosine(float t) {\n  float r = .043+.841*t+.044*cos(7.064*t-.075);\n  float g = .061+.84*t+.03*cos(7.431*t-.36);\n  float b = .088+.793*t+.017*cos(9.001*t-1.351);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 ValentineTones_cosine(float t) {\n  float r = 2.391-3.682*t+5.193*cos(.817*t-1.937);\n  float g = .135+.605*t+.1*cos(4.255*t+1.819);\n  float b = .173+.657*t+.053*cos(5.679*t+1.147);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 GrayYellowTones_cosine(float t) {\n  float r = .6-.129*t+.468*cos(2.889*t-2.671);\n  float g = 22.003-61.926*t+141.553*cos(.4457*t-1.7253);\n  float b = 40.32-135.252*t+364.051*cos(.3746*t-1.6809);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 DarkTerrain_cosine(float t) {\n  float r = -119.592+246.859*t+786.342*cos(.3139*t+1.4182);\n  float g = -5.317+12.06*t+7.188*cos(1.751*t+.736);\n  float b = -180.095+452.81*t+1665.276*cos(.27247*t+1.4622);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 LightTerrain_cosine(float t) {\n  float r = .585+.263*t+.087*cos(5.119*t+2.234);\n  float g = 27.294-45.823*t+94.808*cos(.49*t-1.854);\n  float b = 39.021-51.942*t+114.118*cos(.4623*t-1.9117);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 GreenBrownTerrain_cosine(float t) {\n  float r = .117+.953*t+.119*cos(6.758*t-2.887);\n  float g = .12+.881*t+.181*cos(6.804*t-2.345);\n  float b = -205.56+434.262*t+1593.101*cos(.27279*t+1.44143);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 SandyTerrain_cosine(float t) {\n  float r = .903-.539*t+.319*cos(4.28*t-2.369);\n  float g = .481+.071*t+.271*cos(4.704*t-2.322);\n  float b = .264-.027*t+.058*cos(5.68*t-2.617);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BrightBands_cosine(float t) {\n  float r = .631+.13*t+.314*cos(7.388*t-.03);\n  float g = .52+.312*t+.288*cos(5.462*t-3.023);\n  float b = -577.524+1052.6*t+4334.341*cos(.24336*t+1.43714);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 DarkBands_cosine(float t) {\n  float r = .516+.307*t+.147*cos(11.59*t+.777);\n  float g = .621+.214*t+.262*cos(4.299*t+.764);\n  float b = 1.077-.984*t+.355*cos(5.115*t+1.765);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 Aquamarine_cosine(float t) {\n  float r = -.304+1.962*t+1.037*cos(2.567*t+.358);\n  float g = .262+.949*t+.472*cos(2.849*t+.153);\n  float b = -.204+2.356*t+1.507*cos(1.8*t+.802);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 Pastel_cosine(float t) {\n  float r = 5.992-30.909*t+57.315*cos(.549*t-1.662);\n  float g = 1.695-3.634*t+2.889*cos(1.558*t-1.995);\n  float b = .813-.068*t+.215*cos(5.582*t+.594);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 BlueGreenYellow_cosine(float t) {\n  float r = 2.083+4.676*t+6.451*cos(.818*t+1.879);\n  float g = -.467+1.408*t+.504*cos(2.071*t-.424);\n  float b = -1.062+1.975*t+1.607*cos(1.481*t+.447);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 Rainbow_cosine(float t) {\n  float r = 132.228-245.968*t+755.627*cos(.3275*t-1.7461);\n  float g = .385-1.397*t+1.319*cos(2.391*t-1.839);\n  float b = -142.825+270.693*t+891.307*cos(.3053*t+1.4092);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 DarkRainbow_cosine(float t) {\n  float r = .25+.638*t+.163*cos(7.885*t+1.194);\n  float g = .655-.343*t+.28*cos(5.831*t+2.688);\n  float b = .523-.4*t+.113*cos(6.931*t+.596);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 TemperatureMap_cosine(float t) {\n  float r = .372+.707*t+.265*cos(5.201*t-2.515);\n  float g = .888-2.123*t+1.556*cos(2.483*t-1.959);\n  float b = 1.182-.943*t+.195*cos(8.032*t+2.875);\n  return vec3(clp(r),clp(g),clp(b));\n}\nvec3 LightTemperatureMap_cosine(float t) {\n  float r = .385+.619*t+.238*cos(4.903*t-2.61);\n  float g = -5.491+.959*t+6.089*cos(.968*t-.329);\n  float b = 1.107-.734*t+.172*cos(6.07*t-2.741);\n  return vec3(clp(r),clp(g),clp(b));\n}\n\n\n/* ====================== main ====================== */\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (vec2(0,1)-(fragCoord/iResolution.xy))*vec2(-4, 13);\n    int i = int(uv.x)*13+int(uv.y);\n    float t = fract(uv.x);\n    vec3 col = vec3(0);\n    if (i==0) col=AlpineColors_trig(t);\n    if (i==1) col=LakeColors_trig(t);\n    if (i==2) col=ArmyColors_trig(t);\n    if (i==3) col=MintColors_trig(t);\n    if (i==4) col=AtlanticColors_trig(t);\n    if (i==5) col=NeonColors_trig(t);\n    if (i==6) col=AuroraColors_trig(t);\n    if (i==7) col=PearlColors_trig(t);\n    if (i==8) col=AvocadoColors_trig(t);\n    if (i==9) col=PlumColors_trig(t);\n    if (i==10) col=BeachColors_trig(t);\n    if (i==11) col=RoseColors_trig(t);\n    if (i==12) col=CandyColors_trig(t);\n    if (i==13) col=SolarColors_trig(t);\n    if (i==14) col=CMYKColors_trig(t);\n    if (i==15) col=SouthwestColors_trig(t);\n    if (i==16) col=DeepSeaColors_trig(t);\n    if (i==17) col=StarryNightColors_trig(t);\n    if (i==18) col=FallColors_trig(t);\n    if (i==19) col=SunsetColors_trig(t);\n    if (i==20) col=FruitPunchColors_trig(t);\n    if (i==21) col=ThermometerColors_trig(t);\n    if (i==22) col=IslandColors_trig(t);\n    if (i==23) col=WatermelonColors_trig(t);\n    if (i==24) col=BrassTones_trig(t);\n    if (i==25) col=GreenPinkTones_trig(t);\n    if (i==26) col=BrownCyanTones_trig(t);\n    if (i==27) col=PigeonTones_trig(t);\n    if (i==28) col=CherryTones_trig(t);\n    if (i==29) col=RedBlueTones_trig(t);\n    if (i==30) col=CoffeeTones_trig(t);\n    if (i==31) col=RustTones_trig(t);\n    if (i==32) col=FuchsiaTones_trig(t);\n    if (i==33) col=SiennaTones_trig(t);\n    if (i==34) col=GrayTones_trig(t);\n    if (i==35) col=ValentineTones_trig(t);\n    if (i==36) col=GrayYellowTones_trig(t);\n    if (i==37) col=DarkTerrain_trig(t);\n    if (i==38) col=LightTerrain_trig(t);\n    if (i==39) col=GreenBrownTerrain_trig(t);\n    if (i==40) col=SandyTerrain_trig(t);\n    if (i==41) col=BrightBands_cosine(t);\n    if (i==42) col=DarkBands_cosine(t);\n    if (i==43) col=Aquamarine_trig(t);\n    if (i==44) col=Pastel_trig(t);\n    if (i==45) col=BlueGreenYellow_trig(t);\n    if (i==46) col=Rainbow_trig(t);\n    if (i==47) col=DarkRainbow_trig(t);\n    if (i==48) col=TemperatureMap_trig(t);\n    if (i==49) col=LightTemperatureMap_trig(t);\n    fragColor = vec4(col, 0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "slfXR7",
    "date": "1625345952",
    "viewed": 79,
    "name": "IdentiEgg",
    "description": "Random dyed egg generator inspired by WordPress/Gravatar identicon.\n",
    "likes": 14,
    "published": "Public",
    "usePreview": 1,
    "tags": [
     "color",
     "random",
     "egg",
     "pysanky",
     "pysanka"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Random dyed egg generator inspired by WordPress/Gravatar identicon.\n\n// Common: random egg generation\n// Image: rendering\n\n// Interactive Javascript version:\n// https://harry7557558.github.io/art/dyed-egg/index.html\n\n// =============================== end of description\n\n\n// MODELING\n\nvec3 uEggParameters = vec3(0.0499, 1.1173, -0.1602);\nmat3 uEggOrientation = mat3(1,0,0,0,0.0,1.0,0,-1.0,0.0);\nvec3 uEggTranslation = vec3(0,0,1);\n\nfloat eggEquationPolar(float t) {\n    float s = sin(t);\n    vec3 r = (s*s) * vec3(1.0, exp(-t), cos(t));\n    return 1.0 - dot(r, uEggParameters);\n}\n\nfloat eggSDF(vec3 p) {\n    p = uEggOrientation * (p - uEggTranslation);\n    float d = length(p.xy), z = p.z;\n    float a = atan(abs(d), z);\n    float r = length(vec2(d, z));\n    return r - eggEquationPolar(a);\n}\n\nvec3 getEggNormal(vec3 p) {\n    const float eps = 0.01;\n    return normalize(vec3(\n        eggSDF(p+vec3(eps,0,0))-eggSDF(p-vec3(eps,0,0)),\n        eggSDF(p+vec3(0,eps,0))-eggSDF(p-vec3(0,eps,0)),\n        eggSDF(p+vec3(0,0,eps))-eggSDF(p-vec3(0,0,eps))));\n}\n\n\nbool intersectSphere(vec3 ce, float r, in vec3 ro, in vec3 rd, out float t) {\n    vec3 p = ro-ce;\n    float b = dot(p,rd), c = dot(p,p)-r*r;\n    float delta = b*b-c; if (delta<=0.0) return false;\n    delta = sqrt(delta);\n    t = -b-delta;\n    return true;\n}\n\nbool raymarch(in vec3 ro, in vec3 rd, out float t) {\n    const float eps = 0.001;\n    if (!intersectSphere(uEggTranslation, 1.0+eps, ro, rd, t)) return false;\n    t = max(t, 0.0);\n    ro = ro + rd*t;\n    float t0 = t;\n    t = eps;\n    for (int i=0; i<64; i++) {\n        float dt = 0.9*eggSDF(ro+rd*t);\n        t += dt;\n        if (dt < eps) {\n            vec3 p = ro+rd*t;\n            t += t0;\n            return true;\n        }\n        if (dt>2.0) break;\n    }\n    return false;\n}\n\n\n#define ID_PLANE 0\n#define ID_EGG 1\n\nbool intersectScene(in vec3 ro, in vec3 rd, out float min_t, out vec3 min_n, out vec3 fcol, out int intersect_id) {\n    float t;\n    vec3 n;\n    min_t = 1e+6;\n    intersect_id = -1;\n\n    // intersect with the egg\n    if (raymarch(ro, rd, t)) {\n        min_t = t, min_n = getEggNormal(ro+rd*t);\n        vec3 p = uEggOrientation*(ro+rd*t-uEggTranslation);\n        fcol = eggTexture(p);\n        fcol *= vec3(0.99, 0.95, 0.81);\n        intersect_id = ID_EGG;\n    }\n\n    // intersect with the plane\n    t = -(ro.z+0.0)/rd.z;\n    if (t > 0.0 && t < min_t) {\n        min_t = t, min_n = vec3(0, 0, 1);\n        fcol = vec3(1.0, 1.0, 0.9);\n        vec2 p = ro.xy+rd.xy*t;\n        if (mod(floor(p.x)+floor(p.y),2.0)==0.0) fcol*=0.9;\n        intersect_id = ID_PLANE;\n    }\n\n    if (dot(rd, min_n) > 0.0) min_n = -min_n;\n\n    return intersect_id != -1;\n}\n\n\n// RENDERING\n\nconst vec3 light = vec3(3, 3, 10);\n\n\nfloat calcSoftShadow(vec3 ro, float k) {\n    vec3 rd = light - ro;\n    float col = 1.0;\n    float t = 0.1;\n    float maxt = length(rd);\n    for (int i=0; i<8; i++){\n        float h = eggSDF(ro + rd*t);\n        col = min(col, smoothstep(0.0, 1.0, k*h/t));\n        t += clamp(h, 0.01, 0.2);\n        if (h<0. || t>maxt) break;\n    }\n    return max(col, 0.);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float t = 0.12;\n    vec3 q = p+n*t;\n    float sd = min(eggSDF(q), q.z);\n    float occ = (t - sd)*2.0;\n    return smoothstep(0.0, 1.0, 1.0-occ);\n}\n\n\nvec3 getShade(vec3 pos, vec3 rd, vec3 n, vec3 fcol, int intersect_id) {\n    vec3 lightdir = light - pos;\n    vec3 ambient = (0.5+0.2*dot(n,vec3(0.5,0.5,0.5)))*vec3(1.0,1.0,1.0)*fcol / (0.02*dot(pos,pos)+1.0);\n    vec3 direct = 3.0*max(dot(n,lightdir)/dot(lightdir,lightdir), 0.0) * fcol;\n    vec3 specular = (intersect_id==ID_EGG?0.05:0.1) * vec3(1.0,0.95,0.9)*pow(max(dot(rd, normalize(lightdir)), 0.0), (intersect_id==ID_EGG?5.0:40.0));\n    float shadow = calcSoftShadow(pos, 0.2);\n    float ao = calcAO(pos, n);\n    return ao*(ambient+shadow*(direct+specular));\n}\n\nvec3 traceRay(vec3 ro, vec3 rd) {\n\n    float t;\n    vec3 n;\n    vec3 fcol;\n    int intersect_id;\n    if (!intersectScene(ro, rd, t, n, fcol, intersect_id)) {\n        return vec3(0.0);\n    }\n\n    ro = ro + rd*t;\n    vec3 refl = rd - 2.0*dot(rd, n)*n;\n    vec3 col_direct = getShade(ro, refl, n, fcol, intersect_id);\n    vec3 n0 = n;\n\n    if (intersect_id==ID_EGG) return col_direct;\n\n    vec3 col_refl = vec3(0.0);\n    if (intersectScene(ro+0.01*refl, refl, t, n, fcol, intersect_id)) {\n        col_refl = getShade(ro+refl*t, refl-2.0*dot(refl,n)*n, n, fcol, intersect_id);\n    }\n    else col_refl = vec3(pow(max(dot(refl, normalize(light-ro)), 0.0), 2.0)/(0.02*dot(ro,ro)+1.0));\n\n    return mix(col_direct, col_refl, 0.3+0.2*pow(1.0-abs(dot(refl,n0)),5.0));\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    uint seed = uint(iTime);\n    if (seed>1u) {\n        // random egg texture\n        calcTextureParameters(seed);\n    \n        // random egg shape\n        // the Javascript version has a physically-based (but probably buggy) shape orientation calculation\n        uEggParameters = randomEggShape(seed);\n    }\n    uEggTranslation = vec3(0,0,eggEquationPolar(.5*PI));\n\n    // between -1 and 1\n    vec2 uv = 2. * fragCoord/iResolution.xy - 1.;\n\n    // barrel distortion from https://www.shadertoy.com/view/wslcDS by Shane\n    float r = dot(uv, uv);\n    uv *= 1. + vec2(.03,.02)*(r*r + r);\n\n    // calculate projection\n    float rx = iMouse.w>=0. ? 0.2 : 1.7*iMouse.y/iResolution.y-0.1;\n    float rz = iMouse.w>=0. ? -0.5 : 6.3*iMouse.x/iResolution.x-2.8;\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n\n    // camera position\n    vec3 cam = 6.*w + vec3(0, 0, 0.6);\n    if (cam.z < 0.) {\n        cam -= w * (cam.z/w.z+1e-3);  // prevent below horizon\n    }\n\n    // generate ray\n    vec3 rd = normalize(mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.*length(iResolution)));\n    vec3 col = traceRay(cam, rd);\n\n    // adjustment\n    float gamma = 1.2;\n    col = vec3(pow(col.x,gamma), pow(col.y,gamma), pow(col.z,gamma));\n    col = 1.2*col-0.05;\n    fragColor = vec4(col, 1);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "#define PI 3.1415926\n\n// egg texture parameters\nint uCapShape = 11;\nivec4 uCapShapeOrient = ivec4(0,1,1,0);\nvec3 uCapCol1 = vec3(0.9,0.5,0.5);\nvec3 uCapCol2 = vec3(0.5,0.9,0.9);\nint uRingShape = 21;\nivec4 uRingShapeOrient = ivec4(1,1,0,1);\nvec3 uRingCol1 = vec3(0.5,0.5,0.9);\nvec3 uRingCol2 = vec3(0.5,0.9,0.5);\nint uBodyShape = 43;\nivec4 uBodyShapeOrient = ivec4(1,1,1,0);\nvec3 uBodyCol1 = vec3(0.9,0.9,0.5);\nvec3 uBodyCol2 = vec3(0.5,0.9,0.9);\nint uMidShape = 28;\nivec4 uMidShapeOrient = ivec4(0,0,0,1);\nvec3 uMidCol1 = vec3(0.9,0.8,0.7);\nvec3 uMidCol2 = vec3(0.7,0.5,1.0);\n\n// random\nuint randint(inout uint seed) {\n    return seed = seed*1664525u+1013904223u;\n}\nfloat randfloat(inout uint seed) {\n    return float(randint(seed))/4294967296.0;\n}\nivec4 randvec4(inout uint seed) {\n    uint k = randint(seed)>>4u;\n    return ivec4(k&1u,(k>>1u)&1u,(k>>2u)&1u,(k>>3u)&1u);\n}\nfloat hue2rgb(float t) {\n    if (t<0.0) t+=6.0;\n    if (t>6.0) t-=6.0;\n    if (t<1.0) return t;\n    if (t<3.0) return 1.0;\n    if (t<4.0) return 4.0-t;\n    return 0.0;\n}\nvec3 hsl2rgb(float h, float s, float l) {\n    h*=6.0;\n    float mx = l<=0.5 ? l*(s+1.0) : l+s-l*s;\n    float mn = 2.0*l-mx;\n    float r = mn+(mx-mn)*hue2rgb(h+2.0);\n    float g = mn+(mx-mn)*hue2rgb(h);\n    float b = mn+(mx-mn)*hue2rgb(h-2.0);\n    return vec3(r,g,b);\n}\nvec3 randcol(inout uint seed) {\n    float hue = randfloat(seed);\n    float sat = 0.7+0.3*randfloat(seed);\n    float bri = 0.7+0.25*randfloat(seed);\n    return hsl2rgb(hue, sat, bri);\n}\n\n// random texture parameters\nvoid calcTextureParameters(inout uint seed) {\n    randint(seed);\n    uCapShape = int(randint(seed)%44u);\n    uCapShapeOrient = randvec4(seed);\n    uCapCol1 = randcol(seed);\n    uCapCol2 = randcol(seed);\n    uRingShape = int(randint(seed)%44u);\n    uRingShapeOrient = randvec4(seed);\n    uRingCol1 = randcol(seed);\n    uRingCol2 = randcol(seed);\n    uBodyShape = int(randint(seed)%44u);\n    uBodyShapeOrient = randvec4(seed);\n    uBodyCol1 = randcol(seed);\n    uBodyCol2 = randcol(seed);\n    uMidShape = int(randint(seed)%44u);\n    uMidShapeOrient = randvec4(seed);\n    uMidCol1 = randcol(seed);\n    uMidCol2 = randcol(seed);\n}\n\n\n// Gravatar identicon components, total 44\n// Reference: https://barro.github.io/2018/02/avatars-identicons-and-hash-visualization/\n\n// return a signed number, -1 < u,v < 1\nfloat identiconComponent_raw(int id, float u, float v) {\n    if (id==0) return v;\n    if (id==1) return u-v-2.0;\n    if (id==2) return u+v;\n    if (id==3) return abs(v)-0.5*(u+1.0);\n    if (id==4) return abs(u)+abs(v)-1.0;\n    if (id==5) return abs(u+v)-(u-v+2.0)/3.0;\n    if (id==6) return max(abs(v)-0.5*(u+1.0),-max(abs(v)-0.5*(-u+1.0),-u));\n    if (id==7) return max(abs(u+v)-(u-v+2.0)/3.0,u-v-1.0);\n    if (id==8) return max(abs(u),abs(v))-0.5;\n    if (id==9) return max(min(-u,v),u-v);\n    if (id==10) return max(u,-v);\n    if (id==11) return max(u+abs(v)-1.0,-u);\n    if (id==12) return max(v-u,-v-u);\n    if (id==13) return max(v-u-1.0,max(u,-v));\n    if (id==14) return u-v+1.0;\n    if (id==15) return u*v;\n    if (id==16) return (v+u)*(v-u);\n    if (id==17) return u-2.0*v+1.0;\n    if (id==18) return min(u-2.0*v+1.0,max(u-2.0*v-1.0,v));\n    if (id==19) return min(u-2.0*v+1.0,max(u-v,v));\n    if (id==20) return max(-u-v,u+2.0*v-1.0);\n    if (id==21) return min(max(min(-u,v),u-v),max(max(-u,v),u-v-1.0));\n    if (id==22) return max(1.0-2.0*abs(v)-u,-1.0+2.0*abs(v)-u);\n    if (id==23) return abs(u)-2.0*abs(v)+1.0;\n    if (id==24) return min(abs(u)-2.0*abs(v)+1.0,abs(u)+2.0*abs(v)-1.0);\n    if (id==25) return abs(u)+abs(v)-0.5;\n    if (id==26) return min(1.0+abs(u)-2.0*abs(v),abs(v)-2.0*abs(u)+1.0);\n    if (id==27) return min(max(abs(v)-u-1.0,u),abs(v)-u);\n    if (id==28) return min(max(2.0*v-u-1.0,u-v),max(2.0*v+u-1.0,-u-v));\n    if (id==29) return min(u-2.0*v+1.0,-u+2.0*v+1.0);\n    if (id==30) return min(min(1.0+abs(u)-2.0*abs(v),abs(v)-2.0*abs(u)+1.0),abs(u)+abs(v)-0.5);\n    if (id==31) return max(abs(abs(u)+abs(v)-0.75)-0.25,min(u,-v));\n    if (id==32) return abs(u)+2.0*abs(v)-1.0;\n    if (id==33) return min(u-v+1.0,min(max(u-v-1.0,max(-u,v)),max(min(-u,v),u-v)));\n    if (id==34) return abs(abs(u)+abs(v)-0.75)-0.25;\n    if (id==35) return min(max(u+2.0*v+1.0,u-2.0*v-1.0),min(max(v-2.0*u+1.0,v+2.0*u-1.0),max(-u-2.0*v+1.0,-u+2.0*v-1.0)));\n    if (id==36) return min(max(u+2.0*v+1.0,u-2.0*v-1.0),max(v-2.0*u+1.0,v+2.0*u-1.0));\n    if (id==37) return min(max(u+2.0*v+1.0,u-2.0*v-1.0),max(-u-2.0*v+1.0,-u+2.0*v-1.0));\n    if (id==38) return max(-u+2.0*abs(v)-1.0,u-abs(v));\n    if (id==39) return max(2.0*abs(v)-u-1.0,min(0.5-u,u-abs(v)));\n    if (id==40) return min(u-v+1.0,v-u+1.0);\n    if (id==41) return min(max(u-2.0*v+1.0,u),max(2.0*v-u+1.0,-u));\n    if (id==42) return max(abs(u)+abs(v)-1.0,abs(u)-abs(v));\n    if (id==43) return min(max(max(u-v,-u-v),v-u-1.0),max(max(v-u,u+v),u-v-1.0));\n    return 0.0;\n}\n\nfloat identiconComponent(vec2 uv, int id, ivec4 orient) {\n    float u = uv.x, v = uv.y;\n    if (orient.x==1) u = uv.y, v = uv.x;\n    if (orient.y==1) u = -u;\n    if (orient.z==1) v = -v;\n    return (orient.w==1?-1.0:1.0) * identiconComponent_raw(id, u, v);\n}\n\n\n// texture on different parts of the egg\n// 0<u,v<1 for all functions except textureCap\n\nvec3 textureCap(float u, float v) {\n    float x = v*cos(4.0*u), y = v*sin(4.0*u);\n    float sd = identiconComponent(vec2(x,y), uCapShape, uCapShapeOrient);\n    return sd<0.0 ? uCapCol1 : uCapCol2;\n    return sd<0.0 ? vec3(0.9, 0.5, 0.5) : vec3(0.5, 0.9, 0.9);\n}\n\nvec3 textureRing(float u, float v) {\n    u = 2.0*u-1.0, v=2.0*v-1.0;\n    float sd = identiconComponent(vec2(u,v), uRingShape, ivec4(0));\n    return sd<0.0 ? uRingCol1 : uRingCol2;\n    return sd<0.0 ? vec3(0.5, 0.5, 0.9) : vec3(0.5, 0.9, 0.5);\n}\n\nvec3 textureBody(float u, float v) {\n    u = 2.0*u-1.0, v=2.0*v-1.0;\n    float sd = identiconComponent(vec2(u,v), uBodyShape, ivec4(0));\n    return sd<0.0 ? uBodyCol1 : uBodyCol2;\n    return sd<0.0 ? vec3(0.9, 0.9, 0.5) :  vec3(0.5, 0.9, 0.9);\n}\n\nvec3 textureMiddle(float u, float v) {\n    u = 2.0*u-1.0, v=2.0*v-1.0;\n    vec3 k = abs(v)<0.4 ? vec3(1.0) : vec3(0.9);\n    float sd = identiconComponent(vec2(u,v), uMidShape, ivec4(0));\n    vec3 col = sd<0.0 ? vec3(0.9,0.8,0.7) : vec3(0.7,0.5,1.0);\n    col = sd<0.0 ? uMidCol1 : uMidCol2;\n    return k * col;\n}\n\n// final egg texture\n\nvec3 eggTexture(vec3 p) {\n    float u = atan(p.x, -p.y), v = (PI-atan(length(p.xy), p.z))/PI;\n    float vn = min(v, 1.0-v);\n\n    vec3 col = vec3(1.0);\n\n    if (vn<0.1) {\n        col = textureCap(v<0.5?u:1.0-u, vn/0.1);\n    }\n    else if (vn<0.2) {\n        float un8r = acos(cos(4.0*u))/PI;\n        col = textureRing(v<0.5?un8r:1.0-un8r, (vn-0.1)/(0.2-0.1));\n    }\n    else if (vn<0.38) {\n        float un8 = fract(u * 4.0 / PI);\n        col = textureBody(v<0.5?un8:1.0-un8, (vn-0.2)/(0.38-0.2));\n    }\n    else {\n        float un8 = u * 4.0 + 0.5*PI;\n        float vn = sin(un8)<0.0 ? v : 1.0-v;\n        col = textureMiddle(fract(un8/PI), (vn-0.38)/(1.0-2.0*0.38));\n    }\n\n    return col;\n}\n\n\n// egg geometry\n\n// generated by tracing+fitting real-world egg pictures and find the distribution of the parameters\n// uniform random inside an ellipsoid, not quite perfect\n\n// return three numbers a,b,c\n// the equation of the section of the egg in polar coordinate is\n// r(t) = 1-sin(t)²(a+b*exp(-t)+c*cos(t)), c(t)=r(t)*vec2(sin(t),cos(t))\nvec3 randomEggShape(inout uint seed) {\n    float u = 2.0*PI * randfloat(seed);\n    float v = 2.0*randfloat(seed)-1.0;\n    float w = pow(randfloat(seed), 1.0/3.0);\n    float x = w * sqrt(1.0-v*v) * cos(u);\n    float y = w * sqrt(1.0-v*v) * sin(u);\n    float z = w * v;\n    return vec3(0.050482,1.191725,-0.211361)\n       + x*vec3(-0.112119,0.866281,-0.16593)\n       + y*vec3(0.0514355,0.0009434,-0.0298296)\n       + z*vec3(0.0212091,0.0098094,0.0368813);\n}\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "slSXz1",
    "date": "1627062342",
    "viewed": 19,
    "name": "dmojistan logo",
    "description": "hehe",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "render",
     "main"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Dmojistan logo\n\nvec3 Render_Main(float x, float y) {\n    float m = x*x + y*y;\n    float t = acos(cos(5.0*atan(x,-y)));\n    float r = -0.032*log(exp(-0.03*exp(3.1*t)-2.7*t-6.8)+exp(0.46*abs(t)-25.2));\n    float d = min(max(m-1.7,1.45-m), sqrt(m)-r);\n    float sd = 1.0-d/length(vec2(dFdx(d),dFdy(d)));\n    return clamp(sd, 0.0, 1.0) * vec3(0.98, 0.86, 0.02);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/min(iResolution.x, iResolution.y);\n    float t = mix(0.0, 3.1415926, smoothstep(0.0,1.0,min(mod(iTime,4.0),3.5)/3.5));\n    float a = 2.0*t-1.375 - 1.7*sin(2.0*t-0.942);\n    uv = 1.8*mat2(cos(a),sin(a),-sin(a),cos(a))*uv;\n    vec3 col = Render_Main(uv.x, uv.y);\n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "sljSzD",
    "date": "1627249345",
    "viewed": 64,
    "name": "Gamma (complex function grapher)",
    "description": "Manipulated from [url]https://harry7557558.github.io/tools/complex_webgl.html[/url], but for 3D.",
    "likes": 12,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "domain",
     "complex",
     "gamma"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\n#define ZERO min(int(iTime),0)\n\nconst vec3 CTR = vec3(0.0, 0.0, 1.0);  // center of viewport\nconst vec3 RAD = vec3(3.0, 2.0, 1.5);  // bounding box radius\n\n\n// function to graph\nvec2 fun(vec2 z) {\n    // some interesting functions you may try\n    //return CSC(2.0*z);\n    //return TAN(2.0*z);\n    //return SIN(INV(MUL(z,z)));\n    //return 0.5*SQR(LOG(POW(z,vec2(6,0))));\n    \n    // gamma function product formula, zoom to fit\n    z *= 1.5;\n    vec2 c = INV(z);\n    for (float n=float(ZERO)+1.; n<10.; n++) {\n        c = MUL(c, DIV(POW(vec2(1.+1./n,0),z), vec2(1,0)+z/n) );\n    }\n    return c/2.0;\n}\n\n\n// sdf and gradient\nvec3 sdf_grad(vec3 p) {\n    const float eps = 0.01;\n    float dh_x = length(fun(p.xy+vec2(eps,0)))-length(fun(p.xy-vec2(eps,0)));\n    float dh_y = length(fun(p.xy+vec2(0,eps)))-length(fun(p.xy-vec2(0,eps)));\n    return vec3(vec2(dh_x,dh_y)/(2.*eps), 1.0);\n}\nfloat sdf(vec3 p) {\n    float h = length(fun(p.xy));\n    vec3 n = sdf_grad(p);\n    return (p.z-h)/length(n);\n}\n\n// raymarching shape\nfloat raymarch(vec3 ro, vec3 rd, float tmin, float tmax) {\n    float t = tmin + 1e-2;\n    for (int i=ZERO; i<100; i++) {\n        float dt = 0.2*sdf(ro+rd*t);\n        t += dt;\n        if (abs(dt) < 1e-2) return t;\n        if (t > tmax || t < tmin) return -1.0;\n    }\n    //return -1.0;\n    return t;\n}\n\n\n// complex domain coloring\nfloat hue2rgb(float p, float q, float t) {\n    if (t < 0.) t += 1.;\n    if (t > 1.) t -= 1.;\n    if (t < 1./6.) return p + (q - p) * 6. * t;\n    if (t < 1./2.) return q;\n    if (t < 2./3.) return p + (q - p) * (2./3. - t) * 6.;\n    return p;\n}\nvec3 hslToRgb(float h, float s, float l) {\n    if (s == 0.) return vec3(l);\n    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\n    float p = 2. * l - q;\n    return vec3(\n        hue2rgb(p, q, h + 1./3.),\n        hue2rgb(p, q, h),\n        hue2rgb(p, q, h - 1./3.)\n    );\n}\nvec3 complexColor(vec2 z) {\n    float h = Arg(z) * 0.159;\n    float s = 1.0;\n    // s *= 0.5 + 0.5 * sqrt(abs(sin(3.141592653569793 * Mag(z))));  // linear contour\n    // s *= 0.5 + 0.5 * sqrt(abs(sin(1.364 * logMag(z))));   // logarithmic contour\n    float l = 1.0 - pow(1.0 - 0.5, log(log(Mag(z) + 1.0) + 1.05));\n    return hslToRgb(h, s, l);\n}\n\n// box intersection function from iq\nvec2 boxIntersection(vec3 ro, vec3 rd) {\n    vec3 inv_rd = 1.0/rd;\n    vec3 n = inv_rd*(ro-CTR), k = abs(inv_rd)*RAD;\n    vec3 t1 = -n - k, t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if(tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n\n// main rendering function\nvec3 render(vec3 ro, vec3 rd) {\n\n    // raymarching surface\n    vec2 tnf = boxIntersection(ro, rd);\n    float tmin = tnf.x, tmax = tnf.y;\n    if (tmax < 0.0) return vec3(0.0);\n    float t = raymarch(ro, rd, tmin, tmax);\n    if (t < tmin) return vec3(0.1);\n    \n    // shading\n    vec3 p = ro + rd*t;\n    vec3 light = normalize(vec3(10.,10.,20.) - p);\n    vec3 n = normalize(sdf_grad(p));\n    vec3 col = 1.5*sqrt(complexColor(fun(p.xy)));\n    vec3 bkg = 0.8 * col;\n    vec3 dif = max(dot(n, light), 0.0) * col;\n    vec3 spc = pow(max(dot(rd-2.0*dot(rd,n)*n, light),0.0), 10.0) * vec3(1.0);\n    return 0.5*bkg+0.5*dif+0.2*spc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float rx = iMouse.z>0.?1.57*(iMouse.y/iResolution.y):0.3;\n    float rz = iMouse.z>0.?-iMouse.x/iResolution.x*4.0*3.14:0.5*iTime-2.0;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u=vec3(-sin(rz),cos(rz),0);\n    vec3 v=cross(w,u);\n\n    vec3 ro = CTR + 10.0*w;\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution));\n\n    vec3 col = render(ro, normalize(rd));\n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// elementary complex functions for GLSL\n// from https://harry7557558.github.io/tools/complex_webgl.html\n\nfloat Mag(vec2 a) { return length(a); }\nfloat Arg(vec2 a) { return atan(a.y, a.x); }\nfloat logMag(vec2 a) {\n    //return 0.5*log(dot(a,a));\n    return log(length(a));\n}\nvec2 REL(vec2 e) { return vec2(e.x, 0); }\nvec2 IMA(vec2 e) { return vec2(e.y, 0); }\nvec2 CNJ(vec2 e) { return vec2(e.x, -e.y); }\nvec2 ADD(vec2 a, vec2 b) { return a + b; }\nvec2 SUB(vec2 a, vec2 b) { return a - b; }\nvec2 MUL(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\nvec2 DIV(vec2 a, vec2 b) { return (1.0/dot(b,b)) * vec2(a.x*b.x+a.y*b.y, a.y*b.x-a.x*b.y); }\nvec2 POW(vec2 e, vec2 t) {\n    float a = Arg(e), r = logMag(e), c = exp(t.x*r-t.y*a), s = t.x*a+t.y*r;\n    return c * vec2(cos(s), sin(s));\n}\nvec2 CBR(vec2 e) { return POW(e, vec2(1.0/3.0,0)); }\nvec2 EXP(vec2 e) { return exp(e.x) * vec2(cos(e.y),sin(e.y)); }\nvec2 LOG(vec2 e) { return vec2(logMag(e), Arg(e)); }\nvec2 SQR(vec2 e) {\n    float m = Mag(e);\n    return e.y>0. ? vec2(sqrt(0.5*(m+e.x)), sqrt(0.5*(m-e.x))) :\n        vec2(sqrt(0.5*(m+e.x)), -sqrt(0.5*(m-e.x)));\n}\nvec2 INV(vec2 e) { return (1./dot(e,e)) * vec2(e.x, -e.y); }\n\nvec2 SIN(vec2 e) { return vec2(sin(e.x)*cosh(e.y), cos(e.x)*sinh(e.y)); }\nvec2 COS(vec2 e) { return vec2(cos(e.x)*cosh(e.y), -sin(e.x)*sinh(e.y)); }\nvec2 TAN(vec2 e) {\n    float a = 2.*e.x, b = 2.*e.y, d = cos(a)+cosh(b);\n    return (1./d) * vec2(sin(a), sinh(b));\n}\nvec2 COT(vec2 e) {\n    float a = 2.*e.x, b = 2.*e.y, d = cos(a)-cosh(b);\n    return (1./d) * vec2(-sin(a), sinh(b));\n}\nvec2 SEC(vec2 e) {\n    float a = e.x, b = e.y, d = 0.5*cosh(2.*b) + 0.5*cos(2.*a);\n    return (1./d) * vec2(cos(a)*cosh(b), sin(a)*sinh(b));\n}\nvec2 CSC(vec2 e) {\n    float a = e.x, b = e.y, d = 0.5*cosh(2.*b) - 0.5*cos(2.*a);\n    return (1./d) * vec2(sin(a)*cosh(b), -cos(a)*sinh(b));\n}\nvec2 SNH(vec2 e) { return vec2(sinh(e.x)*cos(e.y), cosh(e.x)*sin(e.y)); }\nvec2 CSH(vec2 e) { return vec2(cosh(e.x)*cos(e.y), sinh(e.x)*sin(e.y)); }\nvec2 TNH(vec2 e) {\n    float a = 2.*e.x, b = 2.*e.y, d = cosh(a)+cos(b);\n    return (1./d) * vec2(sinh(a), sin(b));\n}\nvec2 CTH(vec2 e) {\n    float a = 2.*e.x, b = 2.*e.y, d = cosh(a)-cos(b);\n    return (1./d) * vec2(sinh(a), -sin(b));\n}\nvec2 CCH(vec2 e) {\n    float d = cos(2.*e.y) - cosh(2.*e.x);\n    return (2./d) * vec2(-sinh(e.x)*cos(e.y), cosh(e.x)*sin(e.y));\n}\nvec2 SCH(vec2 e) {\n    float d = cos(2.*e.y) + cosh(2.*e.x);\n    return (2./d) * vec2(cosh(e.x)*cos(e.y), -sinh(e.x)*sin(e.y));\n}\n\nvec2 ASN(vec2 e) {\n    float a = e.x, b = e.y;\n    vec2 t1 = SQR(vec2(b*b-a*a+1., -2.*a*b));\n    vec2 t2 = LOG(vec2(t1.x-b, t1.y+a));\n    return vec2(t2.y, -t2.x);\n}\nvec2 ACS(vec2 e) {\n    float a = e.x, b = e.y;\n    vec2 t1 = SQR(vec2(b*b-a*a+1., -2.*a*b));\n    vec2 t2 = LOG(vec2(t1.x-b, t1.y+a));\n    return vec2(1.570796327-t2.y, t2.x);\n}\nvec2 ATN(vec2 e) {\n    float a = e.x, b = e.y, d = a*a + (1.-b)*(1.-b);\n    vec2 t1 = LOG(vec2((1.-b*b-a*a)/d, -2.*a/d));\n    return vec2(-0.5*t1.y, 0.5*t1.x);\n}\nvec2 ACT(vec2 e) { return ATN(INV(e)); }\nvec2 ASC(vec2 e) { return ACS(INV(e)); }\nvec2 ACC(vec2 e) { return ASN(INV(e)); }\nvec2 ASH(vec2 e) { vec2 r = ASN(vec2(e.y,-e.x)); return vec2(-r.y,r.x); }\nvec2 ACH(vec2 e) { vec2 r = ACS(e); return r.y<=0.?vec2(-r.y,r.x):vec2(r.y,-r.x); }\nvec2 ATH(vec2 e) {\n    float a = e.x, b = e.y;\n    float oneMinus = 1.-a, onePlus = 1.+a, d = oneMinus*oneMinus + b*b;\n    vec2 x = (1./d) * vec2(onePlus*oneMinus-b*b, b*oneMinus+b*onePlus);\n    return vec2(0.5*logMag(x), 0.5*Arg(x));\n}\nvec2 AKH(vec2 e) { return ATH(INV(e)); }\nvec2 AXH(vec2 e) { return ASH(INV(e)); }\nvec2 AGH(vec2 e) { return ACH(INV(e)); }\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "7st3Rr",
    "date": "1629064414",
    "viewed": 2,
    "name": "Scratch Pipes",
    "description": "Replicate an old effect made in visual programming tool Scratch when I just started to learn to code. I have lost the original file but I still feel the old one looks nicer.",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "discard",
     "pipe"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define sc (iResolution.xy/length(vec2(800,450)))\n\nfloat hash(float x, float y) {\n    return fract(43758.5453*sin(12.9898*x+78.233*y));\n}\nfloat noise(float x, float s) {\n    int i0 = int(floor(x)+0.5), i1 = i0+1;\n    return mix(hash(float(i0),s), hash(float(i1),s), smoothstep(0.,1.,fract(x)));\n}\n\nvec2 circle_pos(float i) {\n    float t = 0.001*i;\n    vec2 p = vec2(cos(1.5*t),sin(1.7*t));\n    p += vec2(noise(t,0.0),noise(t+0.5,0.05));\n    p = acos(cos(3.1415926*15.0*p/sc))/3.1415926;\n    return iResolution.xy*p;\n}\nvec3 circle_color(float i) {\n    float t = 0.1*i;\n    //vec3 c = vec3(noise(t,0.1),noise(t+0.5,0.1),noise(t+1.0,0.1));\n    vec3 c = vec3(noise(t,0.1),noise(t+0.5,0.2),noise(t+1.0,0.3));\n    return pow(c,vec3(1.5));\n}\nfloat circle_size(float i) {\n    return length(sc)*(20.0+40.0*noise(0.01*i, 0.4));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    if (iFrame==0) { fragColor=vec4(1.0); return; }\n\n    float t = float(iFrame);\n    vec2 pos = circle_pos(t);\n    vec3 color = circle_color(t);\n    float size = circle_size(t);\n    \n    float sd = length(fragCoord-pos);\n    if (sd>size) discard;\n\n    vec3 col = color;\n    //col = mix(vec3(0),col,clamp(sd-5.0,0.0,1.0));\n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Nd33zB",
    "date": "1630026712",
    "viewed": 133,
    "name": "Natural RYB Color Wheel",
    "description": "The idea comes from a picture on my art teacher's color theory intro slide.\nIgnore my terrible tracing skill.",
    "likes": 5,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "color",
     "space",
     "rgb",
     "wheel",
     "ryb"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Desmos version:\n// https://www.desmos.com/calculator/w4thzt4ofr\n\n#define PI 3.1415926\n\n// RYB/RGB\n#define RYB 1\n\n// smoothed color gradient or not\n#define SMOOTH 0\n\n\n// Color space conversion\n\nfloat hue2rgb(float p, float q, float t) {\n    if (t < 0.) t += 1.;\n    if (t > 1.) t -= 1.;\n    if (t < 1./6.) return mix(p, q, 6. * t);\n    if (t < 1./2.) return q;\n    if (t < 2./3.) return mix(p, q, (2./3. - t) * 6.);\n    return p;\n}\nvec3 hsl2rgb(float h, float s, float l) {\n    float q = l < 0.5 ? l * (1.0 + s) : l + s - l * s;\n    float p = 2. * l - q;\n    return vec3(\n        hue2rgb(p, q, h + 1./3.),\n        hue2rgb(p, q, h),\n        hue2rgb(p, q, h - 1./3.)\n    );\n}\n\nvec3 ryb2rgb(vec3 ryb) {\n    const vec3 ryb000 = vec3(1, 1, 1);\n    const vec3 ryb001 = vec3(0.163, 0.373, 0.6);\n    const vec3 ryb010 = vec3(1, 1, 0);\n    const vec3 ryb100 = vec3(1, 0, 0);\n    const vec3 ryb011 = vec3(0, 0.66, 0.2);\n    const vec3 ryb101 = vec3(0.5, 0, 0.5);\n    const vec3 ryb110 = vec3(1, 0.5, 0);\n    const vec3 ryb111 = vec3(0, 0, 0);\n    return mix(mix(\n        mix(ryb000, ryb001, ryb.z),\n        mix(ryb010, ryb011, ryb.z),\n        ryb.y), mix(\n        mix(ryb100, ryb101, ryb.z),\n        mix(ryb110, ryb111, ryb.z),\n        ryb.y), ryb.x);\n}\n\n\n// Mask layer - please ignore my terrible tracing skill\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat mask(float x, float y) {\n    float head = smax(x+0.25*y-0.65, -0.27*x+y-0.94-0.01*cos(3.0*x), 0.6); // head back\n    float face = -x-0.08*y-0.6 + 0.03*cos(6.0*y-1.0);  // face\n    face -= -0.2+0.2*tanh(18.0*(y+0.4)) + 0.1*exp(-3.0*y-2.2); // chin/neck\n    face -= 0.04*exp(-100.0*(y-0.1)*y)*(0.8-x+10.0*y);  // nose\n    face -= 0.03*sin(40.0*(y-0.03))*exp(-100.0*y*y);  // mouth\n    float d = smax(head, face, 0.2);\n    d = smax(d, 0.3*x-y-0.87 - 0.1*x*x, 0.05);  // bottom\n    float back = x+0.7*y+0.05 - 0.1*exp(-3.0*y-2.2);  // bottom-right block\n    back = smax(-back, -0.6*x+y+0.72-0.05*sin(8.0*x), 0.02);\n    d = smax(d, -back, 0.02);\n    return d;\n}\n\n\n// Noise\n\nvec2 hash22(vec2 p) {\n    // from David Hoskins's https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat SimplexNoise(vec2 xy) {\n    const float K1 = 0.3660254038;  // (sqrt(3)-1)/2\n    const float K2 = 0.2113248654;  // (-sqrt(3)+3)/6\n    vec2 p = xy + (xy.x + xy.y)*K1;\n    vec2 i = floor(p);\n    vec2 f1 = xy - (i - (i.x + i.y)*K2);\n    vec2 s = f1.x < f1.y ? vec2(0.0, 1.0) : vec2(1.0, 0.0);\n    vec2 f2 = f1 - s + K2;\n    vec2 f3 = f1 - 1.0 + 2.0*K2;\n    vec2 n1 = 2.0 * hash22(i) - 1.0;\n    vec2 n2 = 2.0 * hash22(i + s) - 1.0;\n    vec2 n3 = 2.0 * hash22(i + 1.0) - 1.0;\n    vec3 v = vec3(dot(f1, n1), dot(f2, n2), dot(f3, n3));\n    vec3 w = max(-vec3(dot(f1, f1), dot(f2, f2), dot(f3, f3)) + 0.5, vec3(0.0));\n    return dot((w*w*w*w) * v, vec3(32.0));\n}\n\n\n// Main\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Cartesian coordinate\n    vec2 pos = 2.0 * fragCoord/iResolution.xy - 1.0;\n    pos *= iResolution.xy / min(iResolution.x, iResolution.y);\n\n    // polar coordinate\n    vec2 p = pos - vec2(-0.0, 0.15);\n    float r = length(p);\n    float a = atan(p.x, p.y) / (2.0*PI);\n    if (a < 0.0) a += 1.0;\n\n    // color\n    float noise = SimplexNoise(vec2(40.0*a, 8.0*sqrt(r)));\n#if !SMOOTH\n    a = round(12.0*a)/12.0;\n    r = round(3.0*r)/3.0;\n#endif\n    vec3 col = hsl2rgb(a, 1.0, (1.0-0.1*noise)*(1.0-0.8*exp(-0.8*r)));\n#if RYB\n    col = ryb2rgb(col);\n#endif\n\n    // apply mask\n    float m = mask(pos.x, pos.y);\n    if (m > 0.0) col = vec3(1.0);\n\n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "sdc3R2",
    "date": "1630185108",
    "viewed": 115,
    "name": "Tooth (neural volume)",
    "description": "I just see a lot of siren shaders and want to have a try.",
    "likes": 11,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "volume",
     "tooth",
     "neural",
     "network",
     "siren"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Volume source: https://klacansky.com/open-scivis-datasets/ (1.43MB, modified)\n\n// Ground truth:\n// https://harry7557558.github.io/Graphics/raytracing/webgl_volume/index.html#volume=tooth&visual=skinbone&colormap=cThermometer&iso=0.500\n// (much faster rendering, looks better/worse?)\n\n// Trained in TensorFlow with Adam optimizer, mean squared error, equal weight for each voxel\n\n\n// Siren neural net, defined in -1 < x,y,z < 1\nfloat neuralVolume(in vec3 p) {\nvec4 f00=sin(p.x*vec4(.135,-.92,.997,.893)+p.y*vec4(.345,.911,-.651,-1.521)+p.z*vec4(-.825,.656,-.139,.463)+vec4(-.428,.988,-.046,-.945));\nvec4 f01=sin(p.x*vec4(.025,1.443,-1.637,.75)+p.y*vec4(-1.56,-1.163,-.861,.431)+p.z*vec4(-1.054,.9,.071,.182)+vec4(-.201,1.218,-.115,-.13));\nvec4 f02=sin(p.x*vec4(1.734,-.576,-2.458,1.011)+p.y*vec4(.851,.527,.45,3.14)+p.z*vec4(-1.08,-.05,.364,.691)+vec4(.826,-.068,.883,.768));\nvec4 f03=sin(p.x*vec4(.613,-1.078,-.187,-1.355)+p.y*vec4(.051,-2.254,1.874,-.106)+p.z*vec4(1.081,-1.454,2.599,1.164)+vec4(1.106,-.922,-.243,.976));\nvec4 f10=sin(mat4(.237,1.184,-.33,-.309,.159,-.064,-1.225,.508,-.225,-.165,.229,-.875,.076,.21,.066,-.435)*f00\n    +mat4(.314,1.199,.731,-.684,-.823,-.291,-.164,-.045,-.91,-.19,.737,-.423,-.123,.186,-.421,.414)*f01\n    +mat4(-.115,-.24,-.15,-.717,.602,.069,-.02,1.011,.675,.108,.622,-.361,.271,-.1,-.129,.324)*f02\n    +mat4(-.423,-.41,.885,-.368,.071,.488,.829,1.093,-.33,-.02,.687,.951,-.645,-.794,1.003,-1.404)*f03\n    +vec4(-.314,.42,.682,.317));\nvec4 f11=sin(mat4(.623,-.917,-.059,-.484,.052,-.276,.139,-.057,.517,.572,-.709,-.641,-.634,.198,-.309,.73)*f00\n    +mat4(.848,-.171,-1.178,-.745,-.204,-.572,-.527,-.213,1.727,.241,.068,.143,-.447,.469,.724,.306)*f01\n    +mat4(.76,-.992,.072,-.405,-.568,-.705,.697,.529,-.335,.303,.432,.145,.04,-.056,.288,.171)*f02\n    +mat4(-.274,.7,-.054,-.363,.056,-.209,.752,.272,-.394,.361,.048,.035,-.176,.607,-.182,.402)*f03\n    +vec4(.498,.69,.346,.271));\nvec4 f12=sin(mat4(-.002,-.7,.11,-.593,1.26,-.066,-.275,-.545,-.502,.698,.187,-.258,-.593,-.014,.767,.504)*f00\n    +mat4(-.788,-.514,-.677,.159,-.181,.25,1.02,.09,.432,-.637,-.284,-1.395,-.355,.422,.785,.94)*f01\n    +mat4(.921,1.168,-.1,-.368,.65,-.37,-.272,-.237,.1,-.382,-1.027,-.366,.283,-.588,.271,.115)*f02\n    +mat4(-.317,1.604,.237,.099,.279,-.171,-.186,-.055,-.186,.185,.531,.769,-1.034,-.079,.731,.179)*f03\n    +vec4(.315,.32,.234,-.247));\nvec4 f13=sin(mat4(.432,.461,-.251,-.908,.118,.238,-.62,.765,.697,.838,.623,-.889,.589,-1.182,.556,.012)*f00\n    +mat4(.439,.094,.068,-.764,-.284,-.376,-.227,.695,-.842,.786,.325,.366,.96,-.432,-1.067,-.669)*f01\n    +mat4(-1.989,-.098,-.284,-.049,.168,.028,-.32,.836,-.263,.361,.243,-.538,.396,.685,-.115,-.6)*f02\n    +mat4(.142,.179,-.491,-.033,.666,-.194,.313,-.496,.953,-.925,.257,.116,-.007,-.351,-.388,1.296)*f03\n    +vec4(-.286,.268,.283,.384));\nvec4 f20=sin(mat4(1.067,.576,.5,-1.351,1.617,.496,-.806,-.089,-.99,.11,.77,-.887,.573,.052,-1.012,1.272)*f10\n    +mat4(-.509,.281,.883,-.813,-.399,-1.383,-.242,1.315,-.499,.01,-.12,1.965,-.121,-.214,-2.116,-1.099)*f11\n    +mat4(.901,.547,.566,-2.171,-.461,-.476,.454,.768,-1.299,-.416,.3,-.383,.142,-.181,-.009,.49)*f12\n    +mat4(-.097,.154,.28,1.032,-.722,.505,-.243,-.543,-.404,-.341,-1.44,.607,-1.119,-.307,.489,-1.45)*f13\n    +vec4(-.528,.114,-1.355,.252));\nvec4 f21=sin(mat4(-.557,1.041,-.158,.194,-.752,.698,-.197,-.19,-.001,-.476,-.422,.448,-.181,.869,.953,-.999)*f10\n    +mat4(.201,.42,-.784,-.225,.706,-.481,-.053,-.872,.126,-.226,-.153,-.126,-.046,.366,-.939,-.012)*f11\n    +mat4(-.417,-.122,-1.034,.703,.524,-.386,.321,-.627,.381,.476,.171,-.402,.319,.038,.652,-.168)*f12\n    +mat4(-.266,.401,1.156,-.259,-.405,1.071,.893,.748,-.134,.318,.808,.448,.217,-.316,-.825,.276)*f13\n    +vec4(.122,.251,-.471,-.455));\nvec4 f22=sin(mat4(-.305,1.162,.973,-.676,.767,-1.133,1.428,-.979,-1.136,1.027,-1.219,.286,.618,.265,1.458,-.905)*f10\n    +mat4(.54,-.608,-.982,.567,.95,-.17,-.41,.435,-.303,.344,.365,.071,.476,-1.229,.844,-.176)*f11\n    +mat4(.638,-.702,.295,.409,.565,-.454,-1.215,.15,.073,-.058,-1.183,.654,.733,-.836,-.686,-.318)*f12\n    +mat4(.014,-.521,.263,-.234,-1.002,.819,.821,-.636,-1.256,-1.13,1.972,-.295,-.522,.21,-1.572,.714)*f13\n    +vec4(.185,-.447,.147,.098));\nvec4 f23=sin(mat4(-1.731,.056,.409,.383,.686,-.257,-.788,.816,-.286,.455,-.436,-.631,-.877,-.547,-.16,1.115)*f10\n    +mat4(.72,.585,1.283,-.416,-.108,.838,.228,-.616,-.188,-.517,-1.421,.339,-.07,.594,.406,1.143)*f11\n    +mat4(-.033,.243,1.652,.793,-.308,1.091,.522,-.488,-.253,.923,.113,-.276,-.714,-.292,-.316,-.049)*f12\n    +mat4(-.091,-.93,-.056,.757,-.748,-.943,-.746,.662,.657,-.903,-.781,.594,.302,.593,-1.175,-.572)*f13\n    +vec4(.231,-.572,.081,.417));\nvec4 f30=sin(mat4(.315,.409,.083,.363,-1.403,.808,-.4,-.939,-.884,.19,-.307,-.108,.514,-.2,.185,-.058)*f20\n    +mat4(-.128,.494,.029,-.702,.599,-.318,-.25,-.187,1.227,-.095,.094,-.128,.654,-.295,-.511,.316)*f21\n    +mat4(.183,.325,.106,.282,-.856,.088,-.24,-.001,.817,-.571,.114,-.437,-.973,.449,-.11,.282)*f22\n    +mat4(-.667,-.02,-.083,.162,.015,-.363,-.605,-.683,.239,-.088,.156,.159,.832,-.301,.224,.395)*f23\n    +vec4(.043,-.11,-.304,-.07));\nvec4 f31=sin(mat4(.473,.023,.568,.182,-.401,-.025,-.402,-1.307,-.338,-.286,.112,-.784,.107,.184,-.12,.415)*f20\n    +mat4(.373,-.005,-.018,-.133,.135,.298,-.421,.479,-.151,.395,-.615,.995,-.139,.448,-.313,.08)*f21\n    +mat4(.062,.051,.221,-.043,-.012,-.262,.467,-.65,.416,.164,-.003,.844,.042,-.205,-.186,-.835)*f22\n    +mat4(-.154,-.283,.331,-.52,-.621,.373,-.804,-.261,.298,-.063,.369,.261,.243,.142,-.225,.765)*f23\n    +vec4(-.224,-.446,.427,-.272));\nvec4 f32=sin(mat4(1.812,-.311,-.889,-.265,-2.924,-.344,2.515,-1.312,-2.656,.39,1.888,-.736,1.839,-.226,-1.219,.338)*f20\n    +mat4(.158,-.342,-.45,-.489,1.195,-.193,-.442,.789,1.664,-.668,-1.055,.804,.585,-.828,.254,-.43)*f21\n    +mat4(1.203,-.327,-.743,-.423,-2.251,.4,1.369,-.552,2.255,-.175,-1.347,.844,-.784,.501,.619,-.266)*f22\n    +mat4(-2.196,.307,1.213,-.512,-2.076,-.619,1.82,-.405,.963,-.051,-.593,.212,2.068,-.046,-1.471,.712)*f23\n    +vec4(1.433,-.302,-1.556,-.575));\nvec4 f33=sin(mat4(-1.071,.971,.6,-.127,.287,-.307,-.569,.175,.125,-.304,-.32,.016,-.145,.22,.04,-.074)*f20\n    +mat4(.326,-.204,.429,-.039,.521,-.318,-.023,-.054,.328,-.067,-.014,.046,.457,-.352,.354,-.259)*f21\n    +mat4(-.581,.496,.36,-.008,.203,-.336,-.024,.028,-.571,.695,-.111,-.28,.407,-.416,-.112,-.023)*f22\n    +mat4(.312,-.463,.008,-.018,.911,-.82,-.581,-.062,-.469,.448,.222,-.078,-.069,.165,.629,.03)*f23\n    +vec4(-.116,-.003,-.303,.134));\nreturn dot(vec4(-.43,-.112,-.491,.23),f30)+dot(vec4(.378,-.747,-.252,.696),f31)+dot(vec4(-.065,-.318,.122,-.303),f32)+dot(vec4(-.521,-.659,-.376,.469),f33)-.324;\n}\n\nconst vec3 BoxRadius = vec3(0.424, 0.398, 0.678);\n\nfloat map(vec3 p) {\n    p = p / BoxRadius;\n    return neuralVolume(-p);\n}\nvec3 mapNormal(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return -normalize(map(p) - vec3(map(k[0]),map(k[1]),map(k[2])));\n}\n\n// rendering quality\n#define STEP 0.01\n#define MAX_STEP 120.\n\n// adjust this number to see what happens\n#define uIso 0.5\n\n// light, comment the line in mainImage if you like\nvec3 light = normalize(vec3(0.5,0.5,1.0));\n\n// colormap - https://www.shadertoy.com/view/NsSSRK\nvec3 cThermometer(float t) {\n  float r = .453+.122*t+.385*cos(4.177*t-2.507);\n  float g = .284+.142*t+.554*cos(4.181*t-1.918);\n  float b = .464+.05*t+.475*cos(3.217*t-.809);\n  return vec3(r, g, b);\n}\n\n// constant step raymarching + volume sampling\nvec3 vSkinBone(in vec3 ro, in vec3 rd, float t0, float t1) {\n    float step_count = min(ceil((t1-t0)/STEP), MAX_STEP);\n    float t = t0, dt = (t1-t0) / step_count;\n    float iso1 = 1.0-uIso;\n    float iso2 = 0.5-0.5*uIso;\n    vec3 totcol = vec3(0.0);\n    float totabs = 1.0;\n    float v_old = 0.0, v;\n    for (t = t0; t < t1; t += dt) {\n        v = map(ro+rd*t);\n        vec3 col = clamp(cThermometer(v), 0.0, 1.0);\n        float absorb = abs(v-iso2)<0.2*(1.0-uIso) ? 20.0*uIso : 0.0;\n        totabs *= exp(-absorb*dt);\n        totcol += col*absorb*totabs*dt;\n        if (v > iso1) break;\n        v_old = v;\n    }\n    if (v < iso1) return totcol;\n    for (int s = 0; s < 4; s += 1) {\n        v_old = v;\n        dt *= -0.5;\n        for (int i = 0; i < 2; i++) {\n            t += dt;\n            v = map(ro+rd*t);\n            if ((v-iso1)*(v_old-iso1)<0.0) break;\n        }\n    }\n    vec3 n = mapNormal(ro+rd*t);\n    float col = 0.2+0.05*n.y+0.6*max(dot(n, light),0.0);\n    return totcol + col * totabs;\n}\n\n// ray intersection with a box\nbool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {\n    vec3 inv_rd = 1.0 / rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*BoxRadius;\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\n\n// main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // set camera\n    float rx = iMouse.z>0.?3.14*(iMouse.y/iResolution.y)-1.57:0.0;\n    float rz = iMouse.z>0.?-iMouse.x/iResolution.x*4.0*3.14:0.5*iTime-2.0;\n    rx += 1e-4, rz += 1e-4;  // prevent dividing by zero\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y);\n    vec3 ro = 4.0*w + 0.8*(uv.x*u+uv.y*v);\n    vec3 rd = -w;\n\n    // comment this line if you wish\n    light = normalize(w+0.5*u+0.1*v);\n\n    // calculate pixel color\n    float t0, t1;\n    if (!boxIntersection(ro, rd, t0, t1)) {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    vec3 col = vSkinBone(ro, rd, t0, t1);;\n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "fsGGzh",
    "date": "1631027887",
    "viewed": 71,
    "name": "Piecewise Linear Simplex Terrain",
    "description": "Demonstrate a noise generated by interpolating hash values on a simplex grid.\nSee Common tab for 2D and 3D noise functions and their analytical gradient.",
    "likes": 9,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "noise",
     "terrain",
     "simplex"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// I attempted to find a combination of simplex noise and value noise\n// but failed to produced one with continuous gradient.\n\n// The idea is to interpolate hash values on a simplex grid.\n// The noise (2D+3D) and their analytical gradient can be found in the Common tab.\n\n// The 3D noise seems to be cheaper than 3D Perlin noise\n// and about the same cost as 3D value noise.\n// The 2D noise is more expensive than most common 2D noise functions\n// but cheaper than standard 2D simplex noise.\n\n// I created this shader to demonstrate this piecewise linear simplex noise.\n\n\n// scene\nfloat map(in vec3 p) {\n    float base = p.z - 0.1*SimplexValueNoise2D(p.xy);\n    float top = p.z - (0.05 * 2.0*SimplexValueNoise2D(0.5*p.xy) + 3.0);\n    float blob = 0.6*5.0*SimplexValueNoise3D(0.2*p) + 0.2*SimplexValueNoise3D(p);\n    return min(max(blob, top), base);\n}\n\n// to show that analytical gradient works\nvec3 mapNormal(vec3 p) {\n    vec3 t = SimplexValueNoise2Dg(p.xy);\n    vec4 base = vec4(0, 0, 1, p.z) - 0.1*vec4(t.xy, 0.0, t.z);\n    t = 2.0 * vec3(0.5,0.5,1)*SimplexValueNoise2Dg(0.5*p.xy);\n    vec4 top = vec4(0, 0, 1, p.z) - (0.05 * vec4(t.xy, 0.0, t.z) + vec4(vec3(0), 3.0));\n    vec4 blob = 0.6*5.0*vec4(vec3(0.2),1)*SimplexValueNoise3Dg(0.2*p) + 0.2*SimplexValueNoise3Dg(p);\n    vec4 r = blob.w > top.w ? blob : top;\n    r = r.w < base.w ? r : base;\n    return normalize(r.xyz);\n}\n\n\n\n#define ZERO min(int(iTime),0)\n\nconst vec3 sundir = normalize(vec3(0.5, 0.5, 1.0));\n\nbool raymarch(vec3 ro, inout vec3 rd, inout float t) {\n    float t0 = 0.01, t1 = 120.0;\n    for (int i=ZERO; i<120; i++) {\n        float dt = map(ro+rd*t);\n        t += dt;\n        if (abs(dt) < 1e-2) break;\n        if (t > t1) {\n            return false;\n        }\n        rd = normalize(rd + vec3(0, 0, .001*dt));\n    }\n    return true;\n}\n\nfloat calcShadow(vec3 ro) {\n    float t = 0.1;\n    for (int i=ZERO; i<20; i++) {\n        float dt = map(ro+sundir*t);\n        if (dt < 0.) return 0.1;\n        t += max(dt, 0.1);\n    }\n    return 1.0;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float rx = iMouse.z>0. ? 1.8*(iMouse.y/iResolution.y)-0.2 : 0.28;\n    float rz = iMouse.z>0. ? -iMouse.x/iResolution.x*4.0*3.14 : 0.5+0.1*iTime;\n    float ry = iMouse.z>0. ? 0.0 : 0.1;\n\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = vec3(-sin(rx)*vec2(cos(rz),sin(rz)), cos(rx));\n    vec3 w = cross(u, v);\n    u = cos(ry)*u + sin(ry)*v;\n    v = cross(w, u);\n\n    vec3 ro = vec3(2.0*iTime, 0, 2.5) + 14.0*w;\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);\n\n    float t = 0.0;\n    vec3 col;\n    if (raymarch(ro, rd, t)) {\n        ro += rd * t;\n        vec3 n = mapNormal(ro);\n        vec3 basecol = 0.5+0.4*(1.0-abs(n.z))*hash33(n);\n        float shadow = calcShadow(ro);\n        vec3 sunlight = basecol * shadow * max(dot(n, sundir), 0.0) * vec3(1.2,1.1,0.8);\n        vec3 skylight = basecol * max(n.z, 0.0) * vec3(0.6,0.6,0.8);\n        vec3 indirect = basecol * max(-dot(n, sundir), 0.0) * vec3(0.6) + 0.2*max(-n.z, 0.0);\n        col = sunlight + skylight + indirect;\n    }\n    else {\n        t = 1e12;\n    }\n    col = mix(vec3(0.5, 0.6, 0.7)-0.3*max(rd.z, 0.0), col, exp(-0.015*t));\n    col += vec3(0.8, 0.6, 0.4) * pow(max(dot(rd, sundir), 0.0), 1.5);\n    col = 1.1*pow(col, vec3(1.2));\n    fragColor = vec4(vec3(col), 1.0);\n    return;\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// hash functions from https://www.shadertoy.com/view/4djSRW by David Hoskins\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// for solving interpolation\nfloat det(vec2 a, vec2 b) {\n    return a.x*b.y - a.y*b.x;\n}\nfloat det(vec3 a, vec3 b, vec3 c) {\n    return dot(a, cross(b, c));\n}\n\n// noise functions and their analytical gradient\n\nfloat SimplexValueNoise2D(vec2 xy) {\n\t// simplex grid\n\tconst float K1 = 0.3660254038;  // (sqrt(3)-1)/2\n\tconst float K2 = 0.2113248654;  // (-sqrt(3)+3)/6\n\tvec2 p = xy + (xy.x + xy.y)*K1;\n\tvec2 p1 = floor(p);\n\tvec2 s = xy.x-p1.x < xy.y-p1.y ? vec2(0., 1.) : vec2(1., 0.);\n\tvec2 p2 = p1 + s;\n\tvec2 p3 = p1 + 1.0;\n\tfloat v1 = 2.0 * hash12(p1) - 1.0;\n\tfloat v2 = 2.0 * hash12(p2) - 1.0;\n\tfloat v3 = 2.0 * hash12(p3) - 1.0;\n\t// interpolation\n\tvec2 f = p - p1, c = -s + 1.0;\n\tfloat m = 1.0 / det(s, c);\n\tfloat u = m * det(f, c);\n\tfloat uv = m * det(s, f);\n\treturn v1 + u * (v2 - v1) + uv * (v3 - v2);  // mix(v1, mix(v2, v3, v), u)\n}\n\nvec3 SimplexValueNoise2Dg(vec2 xy) {\n\t// simplex grid\n\tconst float K1 = 0.3660254038;  // (sqrt(3)-1)/2\n\tconst float K2 = 0.2113248654;  // (-sqrt(3)+3)/6\n\tvec2 p = xy + (xy.x + xy.y)*K1;\n\tvec2 p1 = floor(p);\n\tvec2 s = xy.x-p1.x < xy.y-p1.y ? vec2(0., 1.) : vec2(1., 0.);\n\tvec2 p2 = p1 + s;\n\tvec2 p3 = p1 + 1.0;\n\tfloat v1 = 2.0 * hash12(p1) - 1.0;\n\tfloat v2 = 2.0 * hash12(p2) - 1.0;\n\tfloat v3 = 2.0 * hash12(p3) - 1.0;\n\t// interpolation\n\tvec2 f = p - p1, c = -s + 1.0;\n\tfloat m = 1.0 / det(s, c);\n\tfloat u = m * det(f, c);\n\tfloat uv = m * det(s, f);\n\tvec2 grad_u = m * vec2(c.y, -c.x);\n\tvec2 grad_uv = m * vec2(-s.y, s.x);\n\tfloat val = v1 + u * (v2 - v1) + uv * (v3 - v2);\n\tvec2 grad = grad_u * (v2 - v1) + grad_uv * (v3 - v2);\n\treturn vec3(grad + (grad.x + grad.y)*K1, val);\n}\n\nfloat SimplexValueNoise3D(vec3 xyz) {\n\t// simplex grid\n\tconst float K1 = 0.3333333333;\n\tconst float K2 = 0.1666666667;\n\tvec3 p = xyz + (xyz.x + xyz.y + xyz.z)*K1;\n\tvec3 i = floor(p), f = p - i;\n\tvec3 f0 = xyz - (i - (i.x + i.y + i.z)*K2);\n\t//vec3 e = step(f0.yzx, f0);  // possibly result in degenerated simplex\n\tvec3 e = vec3(f0.y > f0.x ? 0.0 : 1.0, f0.z >= f0.y ? 0.0 : 1.0, f0.x > f0.z ? 0.0 : 1.0);\n\tvec3 i1 = e * (vec3(1.0) - e.zxy);\n\tvec3 i2 = vec3(1.0) - e.zxy * (vec3(1.0) - e);\n\tvec3 p0 = i;\n\tvec3 p1 = i + i1;\n\tvec3 p2 = i + i2;\n\tvec3 p3 = i + 1.0;\n\tfloat v0 = 2.0 * hash13(p0) - 1.0;\n\tfloat v1 = 2.0 * hash13(p1) - 1.0;\n\tfloat v2 = 2.0 * hash13(p2) - 1.0;\n\tfloat v3 = 2.0 * hash13(p3) - 1.0;\n\t// interpolation\n\tvec3 p01 = p1 - p0, p12 = p2 - p1, p23 = p3 - p2;\n\tfloat m = 1.0 / det(p01, p12, p23);\n\tfloat w = m * det(f, p12, p23);\n\tfloat uw = m * det(p01, f, p23);\n\tfloat uvw = m * det(p01, p12, f);\n\treturn v0 + (v1 - v0) * w + (v2 - v1) * uw + (v3 - v2) * uvw;  // mix(v0, mix(mix(v1, v2, u), mix(v1, v3, u), v), w)\n}\n\nvec4 SimplexValueNoise3Dg(vec3 xyz) {\n\t// simplex grid\n\tconst float K1 = 0.3333333333;\n\tconst float K2 = 0.1666666667;\n\tvec3 p = xyz + (xyz.x + xyz.y + xyz.z)*K1;\n\tvec3 i = floor(p), f = p - i;\n\tvec3 f0 = xyz - (i - (i.x + i.y + i.z)*K2);\n\tvec3 e = vec3(f0.y > f0.x ? 0.0 : 1.0, f0.z >= f0.y ? 0.0 : 1.0, f0.x > f0.z ? 0.0 : 1.0);\n\tvec3 i1 = e * (vec3(1.0) - e.zxy);\n\tvec3 i2 = vec3(1.0) - e.zxy * (vec3(1.0) - e);\n\tvec3 p0 = i;\n\tvec3 p1 = i + i1;\n\tvec3 p2 = i + i2;\n\tvec3 p3 = i + 1.0;\n\tfloat v0 = 2.0 * hash13(p0) - 1.0;\n\tfloat v1 = 2.0 * hash13(p1) - 1.0;\n\tfloat v2 = 2.0 * hash13(p2) - 1.0;\n\tfloat v3 = 2.0 * hash13(p3) - 1.0;\n\t// interpolation\n\tvec3 p01 = p1 - p0, p12 = p2 - p1, p23 = p3 - p2;\n\tfloat m = 1.0 / det(p01, p12, p23);\n\tfloat w = m * det(f, p12, p23);\n\tfloat uw = m * det(p01, f, p23);\n\tfloat uvw = m * det(p01, p12, f);\n\tvec3 grad_w = m * cross(p12, p23);\n\tvec3 grad_uw = m * cross(p23, p01);\n\tvec3 grad_uvw = m * cross(p01, p12);\n\tfloat val = v0 + (v1 - v0) * w + (v2 - v1) * uw + (v3 - v2) * uvw;\n\tvec3 grad = (v1 - v0) * grad_w + (v2 - v1) * grad_uw + (v3 - v2) * grad_uvw;\n\treturn vec4(grad + (grad.x + grad.y + grad.z)*K1, val);\n}\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ssKGWR",
    "date": "1631369800",
    "viewed": 90,
    "name": "3D SDF Visualizer",
    "description": "Debugging an SDF, try to use a previous volume rendering shader to visualize its discontinuity.\n\nmouse-able",
    "likes": 10,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "volume",
     "sdf",
     "debug",
     "discontinuity"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Debugging an SDF, visualize its discontinuity\n\n// orange-blue: SDF isosurfaces\n// red-black: discontinuity (high numerical gradient)\n// green-pink: surface gradient lower/higher than 1\n\n#define PI 3.1415926\n\n\n// a debugging SDF, heavily inspired by iq's Snail\nfloat mapShell(in vec3 p0) {\n    p0 -= vec3(1.3, 0, 0);\n    vec3 p = p0;\n\n    const float b = 0.17;\n\n    float r = length(p.xy);\n    float a = mix(0.0, 0.8, smoothstep(0.0, 1.0, 0.5*(r-0.6)));\n    p.xy = mat2(cos(a),-sin(a),sin(a),cos(a))*p.xy;\n    float t = atan(p.y, p.x);\n \n    float n = (log(r)/b-t)/(2.0*PI);\n    n = min(n, 0.0);\n\n    float n0 = floor(n), n1 = ceil(n);\n    float x0 = exp(b*(t+2.0*PI*n0));\n    float x1 = exp(b*(t+2.0*PI*n1));\n    float r0 = 1.0*x0;\n    float r1 = 1.0*x1;\n\n    float h0 = p.z + 0.4*(x0-1.0);\n    float h1 = p.z + 0.4*(x1-1.0);\n    float d0 = length(vec2(x0-r,h0)) - r0;\n    float d1 = length(vec2(x1-r,h1)) - r1;\n\n    float d, dx, dy;\n    if (d0 < 0.0) d = d0, dx = x0-r, dy = h0;\n    else if (d1 < 0.0 && d1<-d0) d = -d0, dx = x0-r, dy = h0;\n    else if (d1 < 0.0) d = d1, dx = x1-r, dy = h1;\n    else if (d0 < d1) d = d0, dx = x0-r, dy = h0;\n    else d = d1, dx = x1-r, dy = h1;\n\n    d += 0.002*r*sin(40.*t);\n    d += 0.002*r*sin(40.*atan(dy,dx));\n\n    d = abs(d)-0.1*r;\n    d = max(d, p0.x);\n    return d;\n}\n\n// test SDF\nfloat mapTest(vec3 p) {\n    vec3 r = vec3(1.5,1.0,0.6);\n    float k1 = length(p/r);\n    float k2 = length(p/(r*r));\n    return k1*(k1-1.0)/k2+0.1*sign(p.x+p.y+p.z);\n}\n\nfloat sdf(in vec3 p) {\n    //return mapTest(p);\n    return mapShell(p);\n}\n\nvec3 sdfGrad(in vec3 p, in float e) {\n\tfloat a = sdf(p+vec3(e,e,e));\n\tfloat b = sdf(p+vec3(e,-e,-e));\n\tfloat c = sdf(p+vec3(-e,e,-e));\n\tfloat d = sdf(p+vec3(-e,-e,e));\n\treturn (.25/e)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n\n\n// raymarching parameters\nconst vec3 BoxRadius = vec3(2.0, 2.0, 2.0);\n#define STEP 0.01\n#define MAX_STEP 120.\n\n\n// rendering parameters\n#define FIELD_EMISSION 0.3\n#define DISCONTINUITY_OPACITY 0.1\n#define SURFACE_GRADIENT 10.0\n\n// light direction as global variable\nvec3 light = normalize(vec3(0.5,0.5,1.0));\n\n// colormaps - https://www.shadertoy.com/view/NsSSRK\nvec3 colorSdf(float t) {\n  float r = .385+.619*t+.238*cos(4.903*t-2.61);\n  float g = -5.491+.959*t+6.089*cos(.968*t-.329);\n  float b = 1.107-.734*t+.172*cos(6.07*t-2.741);\n  return clamp(vec3(r, g, b), 0.0, 1.0);\n}\nvec3 colorNormal(float t) {\n  float r = .529-.054*t+.55*cos(5.498*t+2.779);\n  float g = .21+.512*t+.622*cos(4.817*t-1.552);\n  float b = .602-.212*t+.569*cos(5.266*t+2.861);\n  return clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\n\n// modified from a volume rendering demo\n// https://github.com/harry7557558/Graphics/blob/master/raytracing/webgl_volume/fs-source.glsl\nvec3 render(in vec3 ro, in vec3 rd, float t0, float t1) {\n    float step_count = min(ceil((t1-t0)/STEP), MAX_STEP);\n    float t = t0, dt = (t1-t0) / step_count;\n    vec3 totcol = vec3(0.0);\n    float totabs = 1.0;\n    float v_old, v;\n    for (t = t0; t < t1; t += dt) {\n        v = sdf(ro+rd*t);\n        vec3 col = colorSdf(0.5+0.5*sin(8.0*PI*v));\n        //float grad = length(sdfGrad(ro+rd*t,dt));\n        float grad = t==t0 ? 0.0 : abs(v-v_old)/dt;\n        float grad_abs = (1.0-grad)/dt;\n        col = mix(vec3(1,0,0), col, clamp(exp(grad_abs),0.0,1.0));\n        float absorb = FIELD_EMISSION+DISCONTINUITY_OPACITY*max(-grad_abs,0.0);\n        totabs *= exp(-absorb*dt);\n        totcol += col*absorb*totabs*dt;\n        if (v < 0.0) break;\n        v_old = v;\n    }\n    if (v > 0.0) return totcol;\n    for (int s = 0; s < 4; s += 1) {\n        v_old = v;\n        dt *= -0.5;\n        for (int i = 0; i < 2; i++) {\n            t += dt;\n            v = sdf(ro+rd*t);\n            if (v*v_old<0.0) break;\n        }\n    }\n    vec3 grad = sdfGrad(ro+rd*t, 1e-3);\n    vec3 col = colorNormal(0.5+0.5*tanh(SURFACE_GRADIENT*(0.5*length(grad)-0.5)));\n    col = 0.2+0.05*grad.y+col*max(dot(normalize(grad), light),0.0);\n    return totcol + col * totabs;\n}\n\n\n// ray intersection with a box\nbool boxIntersection(vec3 ro, vec3 rd, out float tn, out float tf) {\n    vec3 inv_rd = 1.0 / rd;\n    vec3 n = inv_rd*(ro);\n    vec3 k = abs(inv_rd)*BoxRadius;\n    vec3 t1 = -n - k, t2 = -n + k;\n    tn = max(max(t1.x, t1.y), t1.z);\n    tf = min(min(t2.x, t2.y), t2.z);\n    if (tn > tf) return false;\n    return true;\n}\n\n// main\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // set camera\n    float rx = iMouse.z>0. ? 3.14*(iMouse.y/iResolution.y)-1.57 : 0.3;\n    float rz = iMouse.z>0. ? -iMouse.x/iResolution.x*4.0*3.14 : -0.6;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = cross(w,u);\n\n    vec3 ro = 10.0*w;\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);\n\n    // calculate pixel color\n    light = normalize(w+0.5*u+0.1*v);\n\n    float t0, t1;\n    if (!boxIntersection(ro, rd, t0, t1)) {\n        fragColor = vec4(vec3(0.0), 1.0);\n        return;\n    }\n    vec3 col = render(ro, rd, t0, t1);;\n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "sdVGWh",
    "date": "1631492623",
    "viewed": 223,
    "name": "Nautilus Shell",
    "description": "My first attempt to model a sea snail with a spiral. (should note that a nautilus is not a gastropod snail)\n\nThanks this visualizer for helping me debugging the SDF: https://www.shadertoy.com/view/ssKGWR",
    "likes": 38,
    "published": "Public API",
    "usePreview": 0,
    "tags": [
     "spiral",
     "logarithmic",
     "interior",
     "beach",
     "nautilus",
     "seashell",
     "conch"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// I have always been facinated with seashells,\n// nautilus is probably the most mathematical one to get my seashell shader journey stated\n\n\n#define PI 3.1415926\n#define ZERO min(iTime,0.)\n\n\nvec2 cut;  // when modeling the nautilus, cut z<cut.x and z>cut.y to show its interior\n\n\n// calculate the signed distance and color of the nautilus shell\n// this function calculates color only when @req_color is true\nfloat mapShell(in vec3 p, out vec3 col, bool req_color) {\n    p -= vec3(0.7, 0, 0);\n\n    // r=exp(b*θ)\n    const float b = 0.17;\n\n    // Catesian to cylindrical\n    float r = length(p.xy);  // r\n    float a = mix(0.0, 0.45, smoothstep(0.0, 1.0, 0.5*(r-0.6)));  // rotate by this angle\n    p.xy = mat2(cos(a),-sin(a),sin(a),cos(a))*p.xy;  // rotation\n    float t = atan(p.y, p.x);  // θ\n\n    // shell opening, kill discontinuities of the spiral\n    float ro = exp(b*PI);  // center of the \"ring\"\n    float d = length(vec2(length(p.xz-vec2(-ro,0))-ro,p.y));  // distance to the \"ring\"\n    float u = t, dx = r-ro, dy = p.z;  // longitude and two numbers to determine latitude\n\n    // spiral\n    // r(n) = exp(b*(2.*PI*n+t)), (x-r)^2+y^2=r^2, solve for n\n    float n = (log((r*r+p.z*p.z)/(2.*r))/b-t)/(2.0*PI);  // decimal n\n    n = min(n, 0.0);  // clamp to opening\n    float n0 = floor(n), n1 = ceil(n);  // test two boundaries\n    float r0 = exp(b*(2.*PI*n0+t)), r1 = exp(b*(2.*PI*n1+t));  // two r\n    float d0 = abs(length(vec2(r-r0,p.z))-r0);  // distance to inner\n    float d1 = abs(length(vec2(r-r1,p.z))-r1);  // distance to outer\n    if (d0 < d) d = d0, u = 2.*PI*n0+t, dx = r-r0, dy = p.z;  // update distance\n    if (d1 < d) d = d1, u = 2.*PI*n1+t, dx = r-r1, dy = p.z;  // update distance\n\n    // septa/chambers\n    const float f = 2.4;  // \"frequency\" of chambers\n    float s0 = t + 2.0*PI*(n0+0.5);  // longitude parameter\n    float v = fract(n);  // 0-1, distance from inner circle\n    float s = f*s0 + 1.0*pow(0.25-(v-0.5)*(v-0.5), 0.5)+0.5*v;  // curve of septa\n    s += pow(min(1.0/(40.0*length(vec2(v-0.5,p.z))+1.0), 0.5), 2.0);  // hole on septa\n    float sf = fract(s);  // periodic\n    sf = s0>-1.8 ? abs(s+3.25) :  // outer-most septa, possibly cause discontinuities\n         min(sf, 1.0-sf);  // inner septa\n    float w = sf/f*exp(b*(s0+PI));  // adjust distance field\n    if (length(p*vec3(1,1,1.5))<3.0)  // prevent outer discontinuity\n        d = min(d, 0.5*w+0.012);  // union chambers\n\n    d += 0.00012*r*sin(200.*u);  // geometric texture\n    d = abs(d)-0.8*max(0.02*pow(r,0.4),0.02);  // thickness of shell\n    d = max(d, max(cut.x-p.z,p.z-cut.y));  // cut it open\n    if (!req_color) return d;  // distance calculation finished\n\n    // color\n    v = atan(dy, dx);  // latitude parameter\n    w = length(vec2(dx,dy)) / exp(b*u);  // section radius parameter\n    for (float i=0.;i<6.;i+=1.) {  // distort the parameters\n        float f = pow(2., i);\n        float du = 0.15/f*sin(f*u)*cos(f*v);\n        float dv = 0.15/f*cos(f*u)*sin(f*v);\n        u+=du, v+=dv;\n    }\n    float f1 = cos(50.*u);  // middle stripes\n    float f2 = cos(21.3*u)+0.1;  // side stripes\n    float tex = mix(f1, f2, 0.5-0.5*tanh(1.0-3.0*sin(v)*sin(v)))  // blend stripes\n         + 0.5-0.6*cos(v);  // fading at sides\n    tex += 0.5+0.5*tanh(4.0*(u-2.0));  // fading near opening\n    col = n==0.0 ? vec3(0.9,0.85,0.8) : vec3(0.95,0.85,0.7);  // base color, outer and inner\n    if (w>1.0 && w<1.1)  // on the surface of the shell\n        col = (u-0.3*cos(v)<-2.6 ? 1.0-0.6*min(exp(2.+0.5*u),1.0) : 1.0)  // black inside the opening\n            * mix(vec3(0.6,0.3,0.2), col, clamp(8.0*tex+0.5,0.,1.));  // apply stripes\n\n    return d;\n}\n\n// calculate the signed distance and color of the scene\nfloat map(in vec3 p, out vec3 col, bool req_color) {\n    vec3 shell_col;\n    float shell_d = mapShell(p.yzx, shell_col, req_color);  // call mapShell\n    float beach_d = p.z+1.5;  // beach surface: z=-1.5\n    beach_d += 0.001*sin(20.0*p.x)*sin(20.0*p.y) + 0.0005*(sin(51.0*p.x)+sin(50.0*p.y));  // deform the surface of the beach\n    vec3 beach_col = vec3(0.95,0.8,0.5);  // color of the beach\n    float d = min(shell_d, beach_d);  // final signed distance\n    if (d==shell_d) col = shell_col;  // closer to nautilus shell\n    else col = beach_col;  // closer to beach\n    return d;\n}\n\n// calculate signed distance only\nfloat mapDist(vec3 p) {\n    vec3 col;\n    return map(p, col, false);\n}\n\n// numerical gradient of the SDF\nvec3 mapGrad(vec3 p) {\n    const float e = 0.001;\n\tfloat a = mapDist(p+vec3(e,e,e));\n\tfloat b = mapDist(p+vec3(e,-e,-e));\n\tfloat c = mapDist(p+vec3(-e,e,-e));\n\tfloat d = mapDist(p+vec3(-e,-e,e));\n\treturn (.25/e)*vec3(a+b-c-d,a-b+c-d,a-b-c+d);\n}\n\n\n// \"standard\" raymarching\nbool raymarch(vec3 ro, vec3 rd, inout float t, float t1, float step_size, float eps) {\n    for (int i=int(ZERO); i<100; i++) {\n        float dt = step_size*mapDist(ro+rd*t);\n        t += dt;\n        if (abs(dt) < eps) break;\n        if (t > t1) return false;\n    }\n    return true;\n}\n\n// soft shadow - https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcShadow(vec3 ro, vec3 rd) {\n    float sh = 1.;\n    float t = 0.1;\n    for (int i = int(ZERO); i<20; i++){\n        float h = mapDist(ro + rd*t);\n        sh = min(sh, smoothstep(0., 1., 4.0*h/t));\n        t += clamp(h, 0.1, 0.3);\n        if (h<0. || t>8.0) break; \n    }\n    return max(sh, 0.);\n}\n\n// AO - from Shane's https://www.shadertoy.com/view/wslcDS\nfloat calcAO(vec3 p, vec3 n){\n\tfloat sca = 1.5;\n    float occ = 0.;\n    for(float i=ZERO+1.; i<=5.; i+=1.){\n        float t = 0.07*i;\n        float d = mapDist(p+n*t);\n        occ += (t-d)*sca;\n        sca *= .5;\n    }\n    return 1.0 - clamp(occ, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // set cut to view interior\n    float at = mod(iTime, 8.0);  // animation time\n    cut = vec2(-1.8, 1.8);  // show all\n    cut = mix(cut, vec2(-1.8, 0.0), clamp(at-1.0, 0., 1.));  // half\n    cut = mix(cut, vec2(-0.1, 0.1), clamp(at-3.0, 0., 1.));  // slice in the middle\n    cut = mix(cut, vec2(-1.0, -0.8), clamp(at-5.0, 0., 1.));  // slice at the side\n    cut = mix(cut, vec2(-1.8, 1.8), clamp(at-7.0, 0., 1.));  // show all\n\n    // set camera\n    float rx = iMouse.z!=0.0 ? 1.8*(iMouse.y/iResolution.y)-0.2 : 0.3;\n    float rz = iMouse.z!=0.0 ? -iMouse.x/iResolution.x*4.0*3.14 : -0.3;\n\n    vec3 w = vec3(cos(rx)*vec2(cos(rz),sin(rz)), sin(rx));  // far to near\n    vec3 u = vec3(-sin(rz),cos(rz),0);  // left to right\n    vec3 v = cross(w,u);  // down to up\n\n    vec3 ro = 12.0*w;  // ray origin\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);  // ray direction\n\n    // ray intersection\n    float t0 = 0.01;  // start at t=t0\n    float t1 = 3.0*length(ro);  // end distance\n    float t = t0;\n    if (!raymarch(ro, rd, t, t1, 0.8, 1e-3)) {  // raymarch\n        t = 100.;  // miss, set t to a large number so it fades\n    }\n    vec3 p = ro+rd*t;  // current position\n\n    const vec3 sundir = normalize(vec3(0.5, -0.5, 0.5));  // direction of the sun\n    vec3 n = normalize(mapGrad(p));  // get normal\n    vec3 col; map(p, col, true);  // get color\n    float shadow = calcShadow(p, sundir);  // soft shadow\n    float ao = calcAO(p, n);  // ao\n    vec3 sunlight = shadow * max(dot(n, sundir), 0.0) * vec3(0.9, 0.8, 0.6);  // sunlight, yellowish\n    vec3 skylight = ao * max(n.z, 0.0) * vec3(0.6, 0.7, 0.8);  // skylight, blueish\n    vec3 backlit = ao * (vec3(0.2)  // background lighting\n        + vec3(0.3)*max(-dot(n,sundir),0.0)  // opposite of sunlight\n        + vec3(0.4,0.3,0.2)*max(-n.z,0.0));  // opposite of skylight, warm\n    col *= sunlight + skylight + backlit;  // sum three lights\n    float fresnel = 0.2+1.4*pow(1.0+dot(rd,n),2.0);  // faked Fresnel reflectance\n    vec3 refl = 0.8*col+vec3(0.4,0.3,0.2)*pow(max(dot(rd-2.0*dot(rd,n)*n,sundir),0.0),100.);  // reflection, blend with col\n    if (!raymarch(p+0.2*reflect(rd, n), reflect(rd, n), t0, 8.0, 1.0, 0.02))  // not occluded\n        col = mix(col, refl, fresnel);  // add reflection\n    col = mix(vec3(0.5, 0.6, 0.7)-0.3*max(rd.z, 0.0), col, exp(-0.15*max(t-0.4*t1,0.)));  // sky/fog\n    col += 0.6*vec3(0.3,0.2,0.25) * max(dot(rd, sundir), 0.);  // sun haze\n    col = 0.9*pow(col, vec3(0.75));  // brightness/gamma\n    fragColor = vec4(vec3(col), 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  }
 ]
}